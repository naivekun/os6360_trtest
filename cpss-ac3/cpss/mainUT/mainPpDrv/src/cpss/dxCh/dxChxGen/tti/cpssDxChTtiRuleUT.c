/*******************************************************************************
*              Copyright 2001, GALILEO TECHNOLOGY, LTD.
*
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. NO RIGHTS ARE GRANTED
* HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT OF MARVELL OR ANY THIRD
* PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE DISCRETION TO REQUEST THAT THIS
* CODE BE IMMEDIATELY RETURNED TO MARVELL. THIS CODE IS PROVIDED "AS IS".
* MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED OR OTHERWISE, REGARDING ITS
* ACCURACY, COMPLETENESS OR PERFORMANCE. MARVELL COMPRISES MARVELL TECHNOLOGY
* GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, MARVELL INTERNATIONAL LTD. (MIL),
* MARVELL TECHNOLOGY, INC. (MTI), MARVELL SEMICONDUCTOR, INC. (MSI), MARVELL
* ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. (MJKK), GALILEO TECHNOLOGY LTD. (GTL)
* AND GALILEO TECHNOLOGY, INC. (GTI).
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChTtiRuleUT.c
*
* @brief Unit tests for cpssDxChTtiRule functions, that provides
* CPSS tunnel termination.
*
* @version   33
********************************************************************************
*/
/* the define of UT_FIXED_PORT_TO_SUPPORT_U32_TYPE_MAC must come from C files that
   already fixed the types of ports from GT_U8 !

   NOTE: must come before ANY include to H files !!!!
*/
#define UT_FIXED_PORT_TO_SUPPORT_U32_TYPE_MAC

/* includes */
#include <cpss/dxCh/dxChxGen/tti/cpssDxChTti.h>
#include <cpss/generic/bridge/private/prvCpssBrgVlanTypes.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/private/routerTunnelTermTcam/prvCpssDxChRouterTunnelTermTcam.h>

#include <utf/utfMain.h>
#include <utf/private/prvUtfExtras.h>
#include <cpssCommon/cpssPresteraDefs.h>
#include <trafficEngine/tgfTrafficEngine.h>

extern GT_U32 appDemoDxChTcamTtiConvertedIndexGet
(
    IN     GT_U8                            devNum,
    IN     GT_U32                           index
);

extern GT_VOID appDemoDxChNewTtiTcamSupportSet
(
    IN  GT_BOOL             useAppdemoOffset
);

/* defines */
#define TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(dev) (PRV_CPSS_SIP_5_20_CHECK_MAC(dev) ? BIT_7 : BIT_6)
/* Default valid value for port/trunk id */
#define TTI_VALID_PORT_TRUNK_CNS        20

/* Default valid value for vlan id */
#define TTI_VALID_VLAN_ID_CNS           100

/* Default valid value for port id */
#define TTI_VALID_PHY_PORT_CNS          0

/* maximum value for IPv4 tunnel type field */
#define IPV4_TUNNEL_TYPE_MAX_CNS        7

/* maximum value for MPLS label field */
#define MPLS_LABEL_MAX_CNS              1048575

/* maximum value for MPLS labels field */
#define MPLS_LABELS_MAX_CNS             3

/* maximum value for MPLS protocol above MPLS field */
#define MPLS_PROTOCOL_ABOVE_MAX_CNS     2

/* maximum value for ETH cfi field */
#define ETH_CFI_MAX_CNS                 1

/* maximum value for QOS profile field */
#define QOS_PROFILE_MAX_CNS             127

/* maximum value for DP field */
#define DP_MAX_CNS                      1

/* maximum value for MIM ISID field */
#define MIM_ISID_MAX_CNS                16777215

/* maximum value for MIM iRES field */
#define MIM_IRES_MAX_CNS                3

/* maximum value for source id field */
#define SOURCE_ID_MAX_CNS               31

/* maximum value for IPCL index */
#define IPCL_INDEX_MAX_CNS              8191

/* maximum value for IPCL index */
#define IPCL_INDEX_MAX_FOR_VPLS_CNS     2047

/* maximum value for central counter index */
#define CENTRAL_COUNTER_MAX_CNS         16383

/* maximum value for time to live (TTL) field */
#define TTL_MAX_CNS                     255

/* minimum value for cpu code base field */
#define CPU_CODE_BASE_MIN_CNS           192

/* maximum value for cpu code base field */
#define CPU_CODE_BASE_MAX_CNS           255

/* the size of tti Adjacency table entry in words */
#define TTI_ADJACENCY_SIZE_CNS          8

#define TCAM_MAX_RULE_SIZE_CNS         20

/* Private function forward declaration */
static GT_U32 prvGetMaxRuleIndex
(
    IN GT_U8                            devNum
);

static GT_VOID prvSetDefaultCommonPattern
(
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
);

static GT_VOID prvSetRandomValuesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
);

static GT_VOID prvSetMaximumValuesAndPortCasesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
);

static GT_VOID prvSetDefaultIpv4Pattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetRandomValuesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndPortCasesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultMplsPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetRandomValuesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndPortCasesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultEthPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetRandomValuesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);


static GT_VOID prvSetMaximumValuesAndPortCasesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultMimPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetRandomValuesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndPortCasesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

/* TRILL TBD */
#if 0
static GT_VOID prvSetDefaultTrillPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetRandomValuesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndPortCasesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetMaximumValuesAndTrunkCasesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultTrillMask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultDeviceDependentTrillMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_STATUS prvCompareTrillStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC       *secondPtr
);

static GT_STATUS prvCompareTrillStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *firstPtr,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *secondPtr
);
#endif

static GT_VOID prvSetDefaultIpv4Mask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultDeviceDependentIpv4Mask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultMplsMask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultDeviceDependentMplsMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultDeviceDependentEthMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultMimMask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultDeviceDependentMimMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
);

static GT_VOID prvSetDefaultAction
(
    IN CPSS_DXCH_TTI_ACTION_UNT         *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
);

static GT_VOID prvSetRandomValuesAction
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_ACTION_UNT        *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
);

static GT_VOID prvSetMaximumValuesAction
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_ACTION_UNT        *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
);

static GT_STATUS prvCompareCommonRuleStructs
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_KEY_TYPE_ENT       keyType,
    IN GT_CHAR                          *unionName,
    IN GT_CHAR                          *unionMemberName,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *firstPtr,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *secondPtr
);

static GT_STATUS prvCompareIpv4StructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *secondPtr
);

static GT_STATUS prvCompareIpv4Structs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *secondPtr
);

static GT_STATUS prvCompareMplsStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *secondPtr
);

static GT_STATUS prvCompareMplsStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *secondPtr
);

static GT_STATUS prvCompareEthStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *secondPtr
);

static GT_STATUS prvCompareEthStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *secondPtr
);

static GT_STATUS prvCompareMimStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *secondPtr
);

static GT_STATUS prvCompareMimStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *secondPtr
);

static GT_STATUS prvCompareActionStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    actionType,
    IN CPSS_DXCH_TTI_ACTION_UNT         *firstPtr,
    IN CPSS_DXCH_TTI_ACTION_UNT         *secondPtr
);

static GT_U8 ttiGlobal_devNum = 0;

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleSet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              routerTtiTcamRow,
    IN  CPSS_DXCH_TTI_KEY_TYPE_ENT          keyType,
    IN  CPSS_DXCH_TTI_RULE_UNT              *patternPtr,
    IN  CPSS_DXCH_TTI_RULE_UNT              *maskPtr,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    IN  CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleSet_type2)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / max/2 / max],
                            keyType [CPSS_DXCH_TTI_KEY_IPV4_E,
                                     CPSS_DXCH_TTI_KEY_MPLS_E,
                                     CPSS_DXCH_TTI_KEY_ETH_E,
                                     CPSS_DXCH_TTI_KEY_MIM_E,
                                     CPSS_DXCH_TTI_KEY_TRILL_E,
                                     CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                            pattern { ipv4 {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                           tunneltype [0 / 3 / max],
                                                                srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                               destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                isArp [GT_FALSE / GT_TRUE]
                                           },
                                      mpls {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                               label0 [0 / max/2 / max],
                                                                 exp0 [0 / max/2 / max],
                                                               label1 [0 / max/2 / max],
                                                                 exp1 [0 / max/2 / max],
                                                               label2 [0 / max/2 / max],
                                                                 exp2 [0 / max/2 / max],
                                                          numOfLabels [0 / max/2 / max],
                                                    protocolAboveMPLS [0 / max/2 / max],
                                                   reservedLabelExist [GT_FALSE / GT_TRUE],
                                                   reservedLabelValue [0 / max/2 / max],
                                                   channelTypeProfile [0 / max/2 / max],
                                                        cwFirstNibble [0 / max/2 / max]
                                           },
                                       eth {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                                  up0 [0 / max/2 / max],
                                                                 cfi0 [0 / max/2 / max],
                                                        isVlan1Exists [GT_FALSE / GT_TRUE],
                                                                 vid1 [0 / max/2 / max],
                                                                  up1 [0 / max/2 / max],
                                                                 cfi1 [0 / max/2 / max],
                                                            etherType [0 / max/2 / max],
                                                              macToMe [GT_FALSE / GT_TRUE],
                                                                srcId [0 / max/2 / max],
                                                        dsaQosProfile [0 / max/2 / max],
                                                        tag0TpidIndex [0 / max/2 / max],
                                                        tag1TpidIndex [0 / max/2 / max]
                                           },
                                       mim {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                                  bUp [0 / max/2 / max],
                                                                  bDp [0 / max/2 / max],
                                                                 iSid [0 / max/2 / max],
                                                                  iUp [0 / max/2 / max],
                                                                  iDp [0 / max/2 / max],
                                                                iRes1 [0 / max/2 / max],
                                                                iRes2 [0 / max/2 / max],
                                                              macToMe [GT_FALSE / GT_TRUE],
                                                innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                   innerPacketTag0Vid [0 / max/2 / max],
                                                    innerPacketTag0Up [0 / max/2 / max],
                                                   innerPacketTag0Dei [0 / max]
                                           },
                                     trill {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                            trillMBit [GT_FALSE / GT_TRUE],
                                                      trillEgressRbid [0 / max/2 / max],
                                                     trillIngressRbid [0 / max/2 / max],
                                                     innerPacketMacDa [0 / max/2 / max],
                                                innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                   innerPacketTag0Vid [0 / max/2 / max],
                                            innerPacketFieldsAreValid [GT_FALSE / GT_TRUE],
                                            trillMcDescriptorInstance [GT_FALSE / GT_TRUE]
                                           },
                                      udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                           }
                                    },
                               mask { ipv4 {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                           tunneltype [0x00000007],
                                                                srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                               destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                isArp [0x01]
                                           },
                                      mpls {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                           },
                                       eth {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                                  up0 [0x00000007],
                                                                 cfi0 [0x00000001],
                                                        isVlan1Exists [0x01],
                                                                 vid1 [0x00000FFF],
                                                                  up1 [0x00000007],
                                                                 cfi1 [0x00000001],
                                                            etherType [0x0000FFFF],
                                                              macToMe [0x01],
                                                                srcId [0x0000001F],
                                                        dsaQosProfile [0x0000007F],
                                                        tag0TpidIndex [0x00000003],
                                                        tag1TpidIndex [0x00000003]
                                           },
                                       mim {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                                  bUp [0x00000007],
                                                                  bUp [0x00000001],
                                                                 iSid [0x00FFFFFF],
                                                                  iUp [0x00000FFF],
                                                                  iDp [0x00000001],
                                                                iRes1 [0x00000003],
                                                                iRes2 [0x00000003],
                                                              macToMe [0x01],
                                                innerPacketTag0Exists [0x01],
                                                   innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketTag0Up [0x00000007],
                                                   innerPacketTag0Dei [0x00000001]
                                           },
                                     trill {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                            trillMBit [0x01],
                                                      trillEgressRbid [0x0000FFFF],
                                                     trillIngressRbid [0x0000FFFF],
                                                     innerPacketMacDa [0x0000FFFF],
                                                innerPacketTag0Exists [0x01],
                                                   innerPacketTag0Vid [0x00000FFF],
                                            innerPacketFieldsAreValid [0x01],
                                            trillMcDescriptorInstance [0x01]
                                           },
                                      udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                           }
                                    },
                         actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                             action {
                                     type2 {              tunnelTerminate [GT_FALSE / GT_TRUE],
                                                    ttpassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E /
                                                                           CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                    tspassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E /
                                                                           CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                  copyTtlFromTunnelHeader [GT_FALSE / GT_TRUE],
                                                              mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E /
                                                                           CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E /
                                                                           CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                  mplsTtl [0 / 1 / max],
                                                       enableDecrementTtl [GT_FALSE / GT_TRUE],
                                                                  command [CPSS_PACKET_CMD_FORWARD_E /
                                                                           CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                                                           CPSS_PACKET_CMD_TRAP_TO_CPU_E],
                                                          redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E /
                                                                           CPSS_DXCH_TTI_NO_REDIRECT_E /
                                                                           CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E /
                                                                           CPSS_DXCH_TTI_VRF_ID_ASSIGN_E,
                                                                           CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
                                                          egressInterface {      type [CPSS_INTERFACE_PORT_E /
                                                                                       CPSS_INTERFACE_TRUNK_E /
                                                                                       CPSS_INTERFACE_VIDX_E],
                                                                              devPort {
                                                                                       devNum [0 / devNum / max],
                                                                                       portNum [TTI_VALID_PORT_TRUNK_CNS / max/2 / max]
                                                                                      },
                                                                              trunkId [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                 vidx [0 / max/2 / max],
                                                                               vlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                               devNum [0 / devNum / max],
                                                                           fabricVidx [0 / max/2 / max],
                                                                                index [0 / max/2 / max]
                                                                          },
                                                                   arpPtr [0],
                                                              tunnelStart [GT_TRUE / GT_FALSE],
                                                           tunnelStartPtr [0],
                                                             routerLttPtr [0],
                                                                    vrfId [0],
                                                        sourceIdSetEnable [GT_FALSE / GT_TRUE],
                                                                 sourceId [0 / max/2 / max],
                                                             tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                               tag0VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                              tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                               tag1VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                       tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                           CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                         nestedVlanEnable [GT_FALSE / GT_TRUE],
                                                       bindToPolicerMeter [GT_FALSE / GT_TRUE],
                                                            bindToPolicer [GT_FALSE / GT_TRUE],
                                                             policerIndex [0],
                                                            qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                           CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                          keepPreviousQoS [GT_TRUE / GT_FALSE],
                                                                  trustUp [GT_FALSE / GT_TRUE],
                                                                trustDscp [GT_FALSE / GT_TRUE],
                                                                 trustExp [GT_FALSE / GT_TRUE],
                                                               qosProfile [0 / max/2 /max],
                                                             modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E /
                                                                           CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E /
                                                                           CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                            tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E /
                                                                           CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E /
                                                                           CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                               modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E /
                                                                           CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E /
                                                                           CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                   tag0Up [0 / max/2 / max],
                                                                   tag1Up [0 / max/2 / max],
                                                                remapDSCP [GT_FALSE / GT_TRUE],
                                                  pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                  pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                          iPclConfigIndex [0 / max/2 /max],
                                            mirrorToIngressAnalyzerEnable [GT_FALSE / GT_TRUE],
                                             mirrorToIngressAnalyzerIndex [0 / max],
                                                       userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1 /
                                                                           CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                     bindToCentralCounter [GT_FALSE / GT_TRUE],
                                                      centralCounterIndex [0 / max/2 / max],
                                                                vntl2Echo [GT_FALSE / GT_TRUE],
                                                             bridgeBypass [GT_FALSE / GT_TRUE],
                                                        ingressPipeBypass [GT_FALSE / GT_TRUE],
                                                               actionStop [GT_FALSE / GT_TRUE],
                                                            hashMaskIndex [0 / max/2 / max],
                                                              modifyMacSa [GT_FALSE / GT_TRUE],
                                                              modifyMacDa [GT_FALSE / GT_TRUE],
                                                      ResetSrcPortGroupId [GT_FALSE / GT_TRUE],
                                                   multiPortGroupTtiEnable [GT_FALSE / GT_TRUE],
                                              sourceEPortAssignmentEnable [GT_FALSE / GT_TRUE],
                                                              sourceEPort [0 / max/2 / max],
                                                   unknownSaCommandEnable [GT_FALSE / GT_TRUE],
                                                         unknownSaCommand [CPSS_PACKET_CMD_FORWARD_E /
                                                                           CPSS_PACKET_CMD_DROP_SOFT_E /
                                                                           CPSS_PACKET_CMD_LOOPBACK_E],
                                                    sourceMeshIdSetEnable [GT_FALSE],
                                                             sourceMeshId [0 / 1 / 3]
                                           }
                                    }.
    Expected: GT_OK.
    1.2. Call cpssDxChTtiRuleGet.
    Expected: GT_OK and the same pattern, mask and action.
    1.3. Call with out of range ruleIndex and other valid params.
    Expected: NOT GT_OK.
    1.4. Call with out of range pattern.ipv4.common.pclId and
                   other valid params.
    Expected: NOT GT_OK.
    1.5. Call with pattern.ipv4.common.srcIsTrunk [GT_FALSE]
                   out of range pattern.ipv4.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.6. Call with pattern.ipv4.common.srcIsTrunk [GT_TRUE]
                   out of range pattern.ipv4.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.7. Call with out of range pattern.ipv4.common.vid and
                   other valid params.
    Expected: NOT GT_OK.
    1.8. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                   pattern.ipv4.common.dsaSrcIsTrunk [GT_FALSE]
                   out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                (do not constarint) and
                   other valid params.
    Expected: GT_OK.
    1.9. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                   pattern.ipv4.common.dsaSrcIsTrunk [GT_TRUE]
                   out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                (do not constraint) and
                   other valid params.
    Expected: GT_OK.
    1.10. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                    out of range pattern.ipv4.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.11. Call with wrong pattern.ipv4.tunneltype enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.12. Call with out of range pattern.mpls.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.13. Call with pattern.mpls.common.srcIsTrunk [GT_FALSE]
                    out of range pattern.mpls.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.14. Call with pattern.mpls.common.srcIsTrunk [GT_TRUE]
                    out of range pattern.mpls.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.15. Call with out of range pattern.mpls.common.vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.16. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    pattern.mpls.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.mpls.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.17. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    pattern.mpls.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.mpls.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.18. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    out of range pattern.mpls.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.19. Call with out of range pattern.mim.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.20. Call with pattern.mim.common.srcIsTrunk [GT_FALSE]
                   out of range pattern.mim.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.21. Call with pattern.mim.common.srcIsTrunk [GT_TRUE]
                   out of range pattern.mim.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.22. Call with out of range pattern.mim.common.vid and
                   other valid params.
    Expected: NOT GT_OK.
    1.23. Call with pattern.mim.common.isTagged [GT_TRUE]
                    pattern.mim.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.mim.common.dsaSrcPortTrunk
                                            (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.24. Call with pattern.mim.common.isTagged [GT_TRUE]
                    pattern.mim.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.mim.common.dsaSrcPortTrunk
                                            (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.25. Call with pattern.mim.common.isTagged [GT_TRUE]
                    out of range pattern.mim.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.26. Call with out of range pattern.mim.bUp and
                    other valid params.
    Expected: NOT GT_OK.
    1.27. Call with out of range pattern.mim.bDp and
                    other valid params.
    Expected: NOT GT_OK.
    1.28. Call with out of range pattern.mim.iSid and
                    other valid params.
    Expected: NOT GT_OK.
    1.29. Call with out of range pattern.mim.iUp and
                    other valid params.
    Expected: NOT GT_OK.
    1.30. Call with out of range pattern.mim.iDp and
                    other valid params.
    Expected: NOT GT_OK.
    1.31. Call with out of range pattern.mim.innerPacketTag0Vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.32. Call with out of range pattern.mim.innerPacketTag0Up and
                    other valid params.
    Expected: NOT GT_OK.
    1.33. Call with out of range pattern.mim.innerPacketTag0Dei and
                    other valid params.
    Expected: NOT GT_OK.
    1.34. Call with out of range pattern.trill.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.35. Call with pattern.trill.common.srcIsTrunk [GT_FALSE]
                    out of range pattern.trill.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.36. Call with pattern.trill.common.srcIsTrunk [GT_TRUE]
                    out of range pattern.trill.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.37. Call with out of range pattern.trill.common.vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.38. Call with pattern.trill.common.isTagged [GT_TRUE]
                    pattern.trill.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.trill.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.39. Call with pattern.trill.common.isTagged [GT_TRUE]
                    pattern.trill.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.trill.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.40. Call with pattern.trill.common.isTagged [GT_TRUE]
                    out of range pattern.trill.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.41. Call with out of range pattern.trill.trillEgressRbid and
                    other valid params.
    Expected: NOT GT_OK.
    1.42. Call with out of range pattern.trill.trillIngressRbid and
                    other valid params.
    Expected: NOT GT_OK.
    1.43. Call with out of range pattern.trill.innerPacketTag0Vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.44. Call with wrong action.type2.ttPassengerPacketType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.45. Call with wrong action.type2.tsPassengerPacketType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.46. Call with wrong action.type2.command enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.47. Call with wrong action.type2.redirectCommand enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.48. Call with wrong action.type2.tag2VlanCmd enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.49 Call with wrong action.type2.tag1VlanCmd enum values and
                   other valid params.
    Expected: GT_BAD_PARAM.
    1.50. Call with wrong action.type2.qosPrecedence enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.51. Call with wrong action.type2.userDefinedCpuCode enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.52. Call with wrong keyType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.53. Call with wrong keyType [CPSS_DXCH_TTI_KEY_TRILL_E] and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.54. Call with wrong actionType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.55. Call with NULL patternPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.56. Call with NULL maskPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.57. Call with NULL actionPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.58. Call with out of range action.type2.ttHeaderLength and
                    other valid params.
    Expected: NOT GT_OK.
    1.59. Call with wrong action.type2.passengerParsingOfTransitMplsTunnelMode enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.60. Call with out of range action.type2.ttHeaderLength and
                    other valid params.
    Expected: NOT GT_OK.
    1.61. Call with out of range action.type2.qosMappingTableIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.62. Call with wrong action.type2.iPclUdbConfigTableIndex enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.63. Call with out of range action.type2.qosMappingTableIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.64. Call with out of range action.type2.flowId and
                    other valid params.
    Expected: NOT GT_OK.
    1.65. Call with out of range action.type2.oamOffsetIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.66. Call with out of range action.type2.oamProfile and
                    other valid params.
    Expected: NOT GT_OK.
    1.67. Call with wrong action.type2.ptpTriggerType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.68. Call with out of range action.type2.ptpOffset and
                    other valid params.
    Expected: NOT GT_OK.
    1.69. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_FALSE](not relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_OK.
    1.70. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_TRUE](is relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_BAD_PARAM.
    1.71. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_FALSE](not relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_OK.
    1.72. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_TRUE](is relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_BAD_PARAM.
*/

    GT_STATUS                               st = GT_OK;
    GT_U8                                   devNum;

    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    CPSS_DXCH_TTI_KEY_TYPE_ENT              keyType;
    static CPSS_DXCH_TTI_RULE_UNT           pattern;
    static CPSS_DXCH_TTI_RULE_UNT           patternGet;
    static CPSS_DXCH_TTI_RULE_UNT           mask;
    static CPSS_DXCH_TTI_RULE_UNT           maskGet;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT           actionType;
    static CPSS_DXCH_TTI_ACTION_UNT         action;
    static CPSS_DXCH_TTI_ACTION_UNT         actionGet;
    GT_BOOL                                 isEqual;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern,        sizeof(pattern));
    cpssOsBzero((GT_VOID*) &patternGet,     sizeof(patternGet));
    cpssOsBzero((GT_VOID*) &mask,           sizeof(mask));
    cpssOsBzero((GT_VOID*) &maskGet,        sizeof(maskGet));
    cpssOsBzero((GT_VOID*) &action,         sizeof(action));
    cpssOsBzero((GT_VOID*) &actionGet,      sizeof(actionGet));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /*
            1.1. Call with routerTtiTcamRow [0 / max/2 / max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E,
                                             CPSS_DXCH_TTI_KEY_MPLS_E,
                                             CPSS_DXCH_TTI_KEY_ETH_E,
                                             CPSS_DXCH_TTI_KEY_MIM_E,
                                             CPSS_DXCH_TTI_KEY_TRILL_E,
                                             CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                                    pattern { ipv4 {                   common {
                                                                                           pclId [0 / max/2 / max],
                                                                                      srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0 / max/2 / max],
                                                                                        isTagged [GT_FLASE / GT_TRUE],
                                                                                   dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                    dsaSrcDevice [0 / max/2 / max],
                                                                               sourcePortGroupId [0 / max/2 / max]
                                                                              },
                                                                   tunneltype [0 / 3 / max],
                                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                        isArp [GT_FALSE / GT_TRUE]
                                                   },
                                              mpls {                   common {
                                                                                           pclId [0 / max/2 / max],
                                                                                      srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0 / max/2 / max],
                                                                                        isTagged [GT_FLASE / GT_TRUE],
                                                                                   dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                    dsaSrcDevice [0 / max/2 / max],
                                                                               sourcePortGroupId [0 / max/2 / max]
                                                                              },
                                                                       label0 [0 / max/2 / max],
                                                                         exp0 [0 / max/2 / max],
                                                                       label1 [0 / max/2 / max],
                                                                         exp1 [0 / max/2 / max],
                                                                       label2 [0 / max/2 / max],
                                                                         exp2 [0 / max/2 / max],
                                                                  numOfLabels [0 / max/2 / max],
                                                            protocolAboveMPLS [0 / max/2 / max],
                                                           reservedLabelExist [GT_FALSE / GT_TRUE],
                                                           reservedLabelValue [0 / max/2 / max],
                                                           channelTypeProfile [0 / max/2 / max],
                                                                cwFirstNibble [0 / max/2 / max]
                                                   },
                                               eth {                   common {
                                                                                           pclId [0 / max/2 / max],
                                                                                      srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0 / max/2 / max],
                                                                                        isTagged [GT_FLASE / GT_TRUE],
                                                                                   dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                    dsaSrcDevice [0 / max/2 / max],
                                                                               sourcePortGroupId [0 / max/2 / max]
                                                                              },
                                                                          up0 [0 / max/2 / max],
                                                                         cfi0 [0 / max/2 / max],
                                                                isVlan1Exists [GT_FALSE / GT_TRUE],
                                                                         vid1 [0 / max/2 / max],
                                                                          up1 [0 / max/2 / max],
                                                                         cfi1 [0 / max/2 / max],
                                                                    etherType [0 / max/2 / max],
                                                                      macToMe [GT_FALSE / GT_TRUE],
                                                                        srcId [0 / max/2 / max],
                                                                dsaQosProfile [0 / max/2 / max],
                                                                tag0TpidIndex [0 / max/2 / max],
                                                                tag1TpidIndex [0 / max/2 / max]
                                                   },
                                               mim {                   common {
                                                                                           pclId [0 / max/2 / max],
                                                                                      srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0 / max/2 / max],
                                                                                        isTagged [GT_FLASE / GT_TRUE],
                                                                                   dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                    dsaSrcDevice [0 / max/2 / max],
                                                                               sourcePortGroupId [0 / max/2 / max]
                                                                              },
                                                                          bUp [0 / max/2 / max],
                                                                          bDp [0 / max/2 / max],
                                                                         iSid [0 / max/2 / max],
                                                                          iUp [0 / max/2 / max],
                                                                          iDp [0 / max/2 / max],
                                                                        iRes1 [0 / max/2 / max],
                                                                        iRes2 [0 / max/2 / max],
                                                                      macToMe [GT_FALSE / GT_TRUE],
                                                        innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                           innerPacketTag0Vid [0 / max/2 / max],
                                                            innerPacketTag0Up [0 / max/2 / max],
                                                           innerPacketTag0Dei [0 / max]
                                                   },
                                             trill {                   common {
                                                                                           pclId [0 / max/2 / max],
                                                                                      srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0 / max/2 / max],
                                                                                        isTagged [GT_FLASE / GT_TRUE],
                                                                                   dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                    dsaSrcDevice [0 / max/2 / max],
                                                                               sourcePortGroupId [0 / max/2 / max]
                                                                              },
                                                                    trillMBit [GT_FALSE / GT_TRUE],
                                                              trillEgressRbid [0 / max/2 / max],
                                                             trillIngressRbid [0 / max/2 / max],
                                                             innerPacketMacDa [0 / max/2 / max],
                                                        innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                           innerPacketTag0Vid [0 / max/2 / max],
                                                    innerPacketFieldsAreValid [GT_FALSE / GT_TRUE],
                                                    trillMcDescriptorInstance [GT_FALSE / GT_TRUE]
                                                   },
                                              udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                                   }
                                            },
                                       mask { ipv4 {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                   tunneltype [0x00000007],
                                                                        srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                       destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                        isArp [0x01]
                                                   },
                                              mpls {                   common {
                                                                                            pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                       label0 [0x000FFFFF],
                                                                         exp0 [0x00000007],
                                                                       label1 [0x000FFFFF],
                                                                         exp1 [0x00000007],
                                                                       label2 [0x000FFFFF],
                                                                         exp2 [0x00000007],
                                                                  numOfLabels [0x00000003],
                                                            protocolAboveMPLS [0x00000003],
                                                           reservedLabelExist [0xFF],
                                                           reservedLabelValue [0x0000000F],
                                                           channelTypeProfile [0x00000007],
                                                                cwFirstNibble [0x0000000F]
                                                   },
                                               eth {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                          up0 [0x00000007],
                                                                         cfi0 [0x00000001],
                                                                isVlan1Exists [0x01],
                                                                         vid1 [0x00000FFF],
                                                                          up1 [0x00000007],
                                                                         cfi1 [0x00000001],
                                                                    etherType [0x0000FFFF],
                                                                      macToMe [0x01],
                                                                        srcId [0x0000001F],
                                                                dsaQosProfile [0x0000007F],
                                                                tag0TpidIndex [0x00000003],
                                                                tag1TpidIndex [0x00000003]
                                                   },
                                               mim {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                          bUp [0x00000007],
                                                                          bUp [0x00000001],
                                                                         iSid [0x00FFFFFF],
                                                                          iUp [0x00000FFF],
                                                                          iDp [0x00000001],
                                                                        iRes1 [0x00000003],
                                                                        iRes2 [0x00000003],
                                                                      macToMe [0x01],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                            innerPacketTag0Up [0x00000007],
                                                           innerPacketTag0Dei [0x00000001]
                                                   },
                                             trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   },
                                              udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                                   }
                                            },
                                 actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                     action {
                                             type2 {
                                                                  tunnelTerminate [GT_FALSE / GT_TRUE],
                                                            ttpassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E /
                                                                                   CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                            tspassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E /
                                                                                   CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                          copyTtlFromTunnelHeader [GT_FALSE / GT_TRUE],
                                                                      mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E /
                                                                                   CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E /
                                                                                   CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                          mplsTtl [0 / 1 / max],
                                                               enableDecrementTtl [GT_FALSE / GT_TRUE],
                                                                          command [CPSS_PACKET_CMD_FORWARD_E /
                                                                                   CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                                                                   CPSS_PACKET_CMD_TRAP_TO_CPU_E],
                                                                  redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E /
                                                                                   CPSS_DXCH_TTI_NO_REDIRECT_E /
                                                                                   CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E /
                                                                                   CPSS_DXCH_TTI_VRF_ID_ASSIGN_E,
                                                                                   CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
                                                                  egressInterface {      type [CPSS_INTERFACE_PORT_E /
                                                                                               CPSS_INTERFACE_TRUNK_E /
                                                                                               CPSS_INTERFACE_VIDX_E],
                                                                                      devPort {
                                                                                               devNum [0 / devNum / max],
                                                                                               portNum [TTI_VALID_PORT_TRUNK_CNS / max/2 / max]
                                                                                              },
                                                                                      trunkId [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                         vidx [0 / max/2 / max],
                                                                                       vlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                                       devNum [0 / devNum / max],
                                                                                   fabricVidx [0 / max/2 / max],
                                                                                        index [0 / max/2 / max]
                                                                                  },
                                                                           arpPtr [0],
                                                                      tunnelStart [GT_TRUE / GT_FALSE],
                                                                   tunnelStartPtr [0],
                                                                     routerLttPtr [0],
                                                                            vrfId [0],
                                                                sourceIdSetEnable [GT_FALSE / GT_TRUE],
                                                                         sourceId [0 / max/2 / max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E /
                                                                                   CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E /
                                                                                   CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                       tag0VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                      tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E /
                                                                                   CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                       tag1VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                               tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                   CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 nestedVlanEnable [GT_FALSE / GT_TRUE],
                                                               bindToPolicerMeter [GT_FALSE / GT_TRUE],
                                                                    bindToPolicer [GT_FALSE / GT_TRUE],
                                                                     policerIndex [0],
                                                                    qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                   CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                  keepPreviousQoS [GT_TRUE / GT_FALSE],
                                                                          trustUp [GT_FALSE / GT_TRUE],
                                                                        trustDscp [GT_FALSE / GT_TRUE],
                                                                         trustExp [GT_FALSE / GT_TRUE],
                                                                       qosProfile [0 / max/2 /max],
                                                                     modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E /
                                                                                   CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E /
                                                                                   CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                    tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E /
                                                                                   CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E /
                                                                                   CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                       modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E /
                                                                                   CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E /
                                                                                   CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                           tag0Up [0 / max/2 / max],
                                                                           tag1Up [0 / max/2 / max],
                                                                        remapDSCP [GT_FALSE / GT_TRUE],
                                                          pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                                   CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                        pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                                   CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                          pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                                   CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                  iPclConfigIndex [0 / max/2 /max],
                                                    mirrorToIngressAnalyzerEnable [GT_FALSE / GT_TRUE],
                                                     mirrorToIngressAnalyzerIndex [0 / max],
                                                               userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1 /
                                                                                   CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                             bindToCentralCounter [GT_FALSE / GT_TRUE],
                                                              centralCounterIndex [0 / max/2 / max],
                                                                        vntl2Echo [GT_FALSE / GT_TRUE],
                                                                     bridgeBypass [GT_FALSE / GT_TRUE],
                                                                ingressPipeBypass [GT_FALSE / GT_TRUE],
                                                                       actionStop [GT_FALSE / GT_TRUE],
                                                                    hashMaskIndex [0 / max/2 / max],
                                                                      modifyMacSa [GT_FALSE / GT_TRUE],
                                                                      modifyMacDa [GT_FALSE / GT_TRUE],
                                                              ResetSrcPortGroupId [GT_FALSE / GT_TRUE],
                                                           multiPortGroupTtiEnable [GT_FALSE / GT_TRUE],
                                                      sourceEPortAssignmentEnable [GT_FALSE / GT_TRUE],
                                                                      sourceEPort [0 / max/2 / max]
                                                   }
                                            }.
            Expected: GT_OK.
        */
        routerTtiTcamRow                            = 0;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                    (&pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                         (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max/2],
                                                                  srcIsTrunk [GT_FALSE],
                                                                srcPortTrunk [max/2],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max/2],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_FALSE],
                                                             dsaSrcPortTrunk [max/2],
                                                                dsaSrcDevice [max/2],
                                                           sourcePortGroupId [max/2]
                                                          },
                                               tunneltype [3],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_FALSE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0xFFFFFFFF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                               tunneltype [0x00000007],
                                                    srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                   destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                    isArp [0x01]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                     mplsTtl [1],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [devNum],
                                                                                          portNum [max/2]
                                                                                         },
                                                                                 trunkId [max/2],
                                                                                    vidx [max/2],
                                                                                  vlanId [max/2],
                                                                                  devNum [devNum],
                                                                              fabricVidx [max/2],
                                                                                   index [max/2]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_FALSE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max/2],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                  tag0VlanId [max/2],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                  tag1VlanId [max/2],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_TRUE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [max/2],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                      tag0Up [max/2],
                                                                      tag1Up [max/2],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                             iPclConfigIndex [max/2],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [max/2],
                                                          userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max/2],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max/2],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [max/2]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetRandomValuesIpv4Pattern               (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetRandomValuesAction                    (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_FALSE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_FALSE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                                keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_TRUE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_TRUE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
        /*
            Call with routerTtiTcamRow [max],
                                keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_FALSE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_FALSE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
        /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
        action.type2.egressInterface.vidx           -= 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
        /*
            Call with routerTtiTcamRow [max],
                                keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_TRUE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_TRUE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
        /*
            Call with routerTtiTcamRow [max],
                                keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_FALSE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_FALSE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
        /*
            Call with routerTtiTcamRow [max],
                                keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                               pattern { ipv4 {    common {
                                                                       pclId [max],
                                                                  srcIsTrunk [GT_TRUE],
                                                                srcPortTrunk [max],
                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                         vid [max],
                                                                    isTagged [GT_TRUE],
                                                               dsasrcIsTrunk [GT_TRUE],
                                                             dsaSrcPortTrunk [max],
                                                                dsaSrcDevice [max],
                                                           sourcePortGroupId [max]
                                                          },
                                               tunneltype [max],
                                                    srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                   destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                    isArp [GT_TRUE]
                                              }
                                       },
                                  mask { ipv4 {    common {
                                                                       pclId [0x000003FF],
                                                                  srcIsTrunk [0x01],
                                                                srcPortTrunk [0x00000FFF],
                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                         vid [0x0FFF],
                                                                    isTagged [0x01],
                                                               dsaSrcIsTrunk [0x01],
                                                             dsaSrcPortTrunk [0x7F],
                                                                dsaSrcDevice [0x7F],
                                                           sourcePortGroupId [0x00000007]
                                                          },
                                                             tunneltype [0x00000007],
                                                                 srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                 destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                  isArp [0x01]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                           &patternGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                           &maskGet.ipv4);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /*
            Call with routerTtiTcamRow [0],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [0],
                                                                          srcIsTrunk [GT_FALSE],
                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [0],
                                                                            isTagged [GT_FLASE],
                                                                       dsaSrcIsTrunk [GT_FALSE],
                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                        dsaSrcDevice [0],
                                                                   sourcePortGroupId [0]
                                                                  },
                                                           label0 [0],
                                                             exp0 [0],
                                                           label1 [0],
                                                             exp1 [0],
                                                           label2 [0],
                                                             exp2 [0],
                                                      numOfLabels [0],
                                                protocolAboveMPLS [0],
                                               reservedLabelExist [GT_FALSE],
                                               reservedLabelValue [0],
                                               channelTypeProfile [0],
                                                    cwFirstNibble [0]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007]
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = 0;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                    (&pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                         (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

            if(GT_OK == st)
            {
                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max/2],
                                                                          srcIsTrunk [GT_FALSE],
                                                                        srcPortTrunk [max/2],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max/2],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_FALSE],
                                                                     dsaSrcPortTrunk [max/2],
                                                                        dsaSrcDevice [max/2],
                                                                   sourcePortGroupId [max/2]
                                                                  },
                                                           label0 [max/2],
                                                             exp0 [max/2],
                                                           label1 [max/2],
                                                             exp1 [max/2],
                                                           label2 [max/2],
                                                             exp2 [max/2],
                                                      numOfLabels [max/2],
                                                protocolAboveMPLS [max/2],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max/2],
                                               channelTypeProfile [max/2],
                                                    cwFirstNibble [max/2]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                     mplsTtl [1],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [devNum],
                                                                                          portNum [max/2]
                                                                                         },
                                                                                 trunkId [max/2],
                                                                                    vidx [max/2],
                                                                                  vlanId [max/2],
                                                                                  devNum [devNum],
                                                                              fabricVidx [max/2],
                                                                                   index [max/2]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_FALSE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max/2],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                  tag0VlanId [max/2],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                  tag1VlanId [max/2],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_TRUE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [max/2],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                      tag0Up [max/2],
                                                                      tag1Up [max/2],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                             iPclConfigIndex [max/2],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [max/2],
                                                          userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max/2],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max/2],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [max/2]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetRandomValuesMplsPattern               (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetRandomValuesAction                    (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_FALSE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_FALSE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {
                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_TRUE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_TRUE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_FALSE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_FALSE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
        /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
        action.type2.egressInterface.vidx           -= 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_TRUE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_TRUE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_FALSE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_FALSE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }



        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                               pattern { mpls {            common {
                                                                               pclId [max],
                                                                          srcIsTrunk [GT_TRUE],
                                                                        srcPortTrunk [max],
                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                 vid [max],
                                                                            isTagged [GT_TRUE],
                                                                       dsasrcIsTrunk [GT_TRUE],
                                                                     dsaSrcPortTrunk [max],
                                                                        dsaSrcDevice [max],
                                                                   sourcePortGroupId [max]
                                                                  },
                                                           label0 [max],
                                                             exp0 [max],
                                                           label1 [max],
                                                             exp1 [max],
                                                           label2 [max],
                                                             exp2 [max],
                                                      numOfLabels [max],
                                                protocolAboveMPLS [max],
                                               reservedLabelExist [GT_TRUE],
                                               reservedLabelValue [max],
                                               channelTypeProfile [max],
                                                    cwFirstNibble [max]
                                              }
                                       },
                                  mask { mpls {            common {
                                                                               pclId [0xFFFFFFFF],
                                                                          srcIsTrunk [0x01],
                                                                        srcPortTrunk [0x00000FFF],
                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                 vid [0x0FFF],
                                                                            isTagged [0x01],
                                                                       dsaSrcIsTrunk [0x01],
                                                                     dsaSrcPortTrunk [0x7F],
                                                                        dsaSrcDevice [0x7F],
                                                                   sourcePortGroupId [0x00000007]
                                                                  },
                                                           label0 [0x000FFFFF],
                                                             exp0 [0x00000007],
                                                           label1 [0x000FFFFF],
                                                             exp1 [0x00000007],
                                                           label2 [0x000FFFFF],
                                                             exp2 [0x00000007],
                                                      numOfLabels [0x00000003],
                                                protocolAboveMPLS [0x00000003],
                                               reservedLabelExist [0xFF],
                                               reservedLabelValue [0x0000000F],
                                               channelTypeProfile [0x00000007],
                                                    cwFirstNibble [0x0000000F]
                                              }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
        prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                           &patternGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                           &maskGet.mpls);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /*
            Call with routerTtiTcamRow [0],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [0],
                                                                    srcIsTrunk [GT_FALSE],
                                                                  srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [0],
                                                                      isTagged [GT_FLASE],
                                                                 dsaSrcIsTrunk [GT_FALSE],
                                                               dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                  dsaSrcDevice [0],
                                                             sourcePortGroupId [0]
                                                            },
                                                        up0 [0],
                                                       cfi0 [0],
                                              isVlan1Exists [GT_FALSE],
                                                       vid1 [0],
                                                        up1 [0],
                                                       cfi1 [0],
                                                  etherType [0],
                                                    macToMe [GT_FALSE],
                                                      srcId [0],
                                              dsaQosProfile [0],
                                              tag0TpidIndex [0],
                                              tag1TpidIndex [0]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = 0;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetDefaultEthPattern                     (&pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                         (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max/2],
                                                                    srcIsTrunk [GT_FALSE],
                                                                  srcPortTrunk [max/2],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max/2],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_FALSE],
                                                               dsaSrcPortTrunk [max/2],
                                                                  dsaSrcDevice [max/2],
                                                             sourcePortGroupId [max/2]
                                                            },
                                                        up0 [max/2],
                                                       cfi0 [max/2],
                                              isVlan1Exists [GT_FALSE],
                                                       vid1 [max/2],
                                                        up1 [max/2],
                                                       cfi1 [max/2],
                                                  etherType [max/2],
                                                    macToMe [GT_TRUE],
                                                      srcId [max/2],
                                              dsaQosProfile [max/2],
                                              tag0TpidIndex [max/2],
                                              tag1TpidIndex [max/2]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                     mplsTtl [1],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [devNum],
                                                                                          portNum [max/2]
                                                                                         },
                                                                                 trunkId [max/2],
                                                                                    vidx [max/2],
                                                                                  vlanId [max/2],
                                                                                  devNum [devNum],
                                                                              fabricVidx [max/2],
                                                                                   index [max/2]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_FALSE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max/2],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                  tag0VlanId [max/2],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                  tag1VlanId [max/2],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_TRUE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [max/2],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                      tag0Up [max/2],
                                                                      tag1Up [max/2],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                             iPclConfigIndex [max/2],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [max/2],
                                                          userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max/2],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max/2],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [max/2]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetRandomValuesEthPattern                (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetRandomValuesAction                    (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_FALSE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_FALSE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_TRUE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_TRUE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_FALSE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_FALSE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
        /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
        action.type2.egressInterface.vidx           -= 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_TRUE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_TRUE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_FALSE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_FALSE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

            if(GT_OK == st)
            {
                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                               pattern { eth {       common {
                                                                         pclId [max],
                                                                    srcIsTrunk [GT_TRUE],
                                                                  srcPortTrunk [max],
                                                                           mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           vid [max],
                                                                      isTagged [GT_TRUE],
                                                                 dsasrcIsTrunk [GT_TRUE],
                                                               dsaSrcPortTrunk [max],
                                                                  dsaSrcDevice [max],
                                                             sourcePortGroupId [max]
                                                            },
                                                        up0 [max],
                                                       cfi0 [max],
                                              isVlan1Exists [GT_TRUE],
                                                       vid1 [max],
                                                        up1 [max],
                                                       cfi1 [max],
                                                  etherType [max],
                                                    macToMe [GT_TRUE],
                                                      srcId [max],
                                              dsaQosProfile [max],
                                              tag0TpidIndex [max],
                                              tag1TpidIndex [max]
                                             }
                                       },
                                  mask { eth {       common {
                                                                         pclId [0xFFFFFFFF],
                                                                    srcIsTrunk [0x01],
                                                                  srcPortTrunk [0x00000FFF],
                                                                           mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           vid [0x0FFF],
                                                                      isTagged [0x01],
                                                                 dsaSrcIsTrunk [0x01],
                                                               dsaSrcPortTrunk [0x7F],
                                                                  dsaSrcDevice [0x7F],
                                                             sourcePortGroupId [0x00000007]
                                                            },
                                                        up0 [0x00000007],
                                                       cfi0 [0x00000001],
                                              isVlan1Exists [0x01],
                                                       vid1 [0x00000FFF],
                                                        up1 [0x00000007],
                                                       cfi1 [0x00000001],
                                                  etherType [0x0000FFFF],
                                                    macToMe [0x01],
                                                      srcId [0x0000001F],
                                              dsaQosProfile [0x0000007F],
                                              tag0TpidIndex [0x00000003],
                                              tag1TpidIndex [0x00000003]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
        prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                          &patternGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareEthStructs(devNum, "mask", &mask.eth, &maskGet.eth);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.eth != maskGet.eth: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /*
            Call with routerTtiTcamRow [0],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [0],
                                                                            srcIsTrunk [GT_FALSE],
                                                                          srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [0],
                                                                              isTagged [GT_FLASE],
                                                                         dsaSrcIsTrunk [GT_FALSE],
                                                                       dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                          dsaSrcDevice [0],
                                                                     sourcePortGroupId [0]
                                                                    },
                                                                bUp [0],
                                                                bDp [0],
                                                               iSid [0],
                                                                iUp [0],
                                                                iDp [0],
                                                              iRes1 [0],
                                                              iRes2 [0],
                                                            macToMe [GT_FALSE],
                                              innerPacketTag0Exists [GT_FALSE],
                                                 innerPacketTag0Vid [0],
                                                  innerPacketTag0Up [0],
                                                 innerPacketTag0Dei [0]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = 0;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                    (&pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                         (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max/2],
                                                                            srcIsTrunk [GT_FALSE],
                                                                          srcPortTrunk [max/2],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max/2],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_FALSE],
                                                                       dsaSrcPortTrunk [max/2],
                                                                          dsaSrcDevice [max/2],
                                                                     sourcePortGroupId [max/2]
                                                                    },
                                                                bUp [max/2],
                                                                bDp [max/2],
                                                               iSid [max/2],
                                                                iUp [max/2],
                                                                iDp [max/2],
                                                              iRes1 [max/2],
                                                              iRes2 [max/2],
                                                            macToMe [GT_FALSE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max/2],
                                                  innerPacketTag0Up [max/2],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                     mplsTtl [1],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [devNum],
                                                                                          portNum [max/2]
                                                                                         },
                                                                                 trunkId [max/2],
                                                                                    vidx [max/2],
                                                                                  vlanId [max/2],
                                                                                  devNum [devNum],
                                                                              fabricVidx [max/2],
                                                                                   index [max/2]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_FALSE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max/2],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                  tag0VlanId [max/2],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                  tag1VlanId [max/2],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_TRUE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [max/2],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                      tag0Up [max/2],
                                                                      tag1Up [max/2],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                             iPclConfigIndex [max/2],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [max/2],
                                                          userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max/2],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max/2],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [max/2]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetRandomValuesMimPattern               (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetRandomValuesAction                    (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_FALSE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_FALSE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_TRUE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_TRUE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndTrunkCasesMimPattern (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_FALSE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_FALSE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
        /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
        action.type2.egressInterface.vidx           -= 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_TRUE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_TRUE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndTrunkCasesMimPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask         (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_FALSE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_FALSE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);
        }


        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                               pattern { mim {               common {
                                                                                 pclId [max],
                                                                            srcIsTrunk [GT_TRUE],
                                                                          srcPortTrunk [max],
                                                                                   mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                   vid [max],
                                                                              isTagged [GT_TRUE],
                                                                         dsasrcIsTrunk [GT_TRUE],
                                                                       dsaSrcPortTrunk [max],
                                                                          dsaSrcDevice [max],
                                                                     sourcePortGroupId [max]
                                                                    },
                                                                bUp [max],
                                                                bDp [max],
                                                               iSid [max],
                                                                iUp [max],
                                                                iDp [max],
                                                              iRes1 [max],
                                                              iRes2 [max],
                                                            macToMe [GT_TRUE],
                                              innerPacketTag0Exists [GT_TRUE],
                                                 innerPacketTag0Vid [max],
                                                  innerPacketTag0Up [max],
                                                 innerPacketTag0Dei [max]
                                             }
                                       },
                                  mask { mim {               common {
                                                                                 pclId [0xFFFFFFFF],
                                                                            srcIsTrunk [0x01],
                                                                          srcPortTrunk [0x00000FFF],
                                                                                   mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                   vid [0x0FFF],
                                                                              isTagged [0x01],
                                                                         dsaSrcIsTrunk [0x01],
                                                                       dsaSrcPortTrunk [0x7F],
                                                                          dsaSrcDevice [0x7F],
                                                                     sourcePortGroupId [0x00000007]
                                                                    },
                                                                bUp [0x00000007],
                                                                bUp [0x00000001],
                                                               iSid [0x00FFFFFF],
                                                                iUp [0x00000FFF],
                                                                iDp [0x00000001],
                                                              iRes1 [0x00000003],
                                                              iRes2 [0x00000003],
                                                            macToMe [0x01],
                                              innerPacketTag0Exists [0x01],
                                                 innerPacketTag0Vid [0x00000FFF],
                                                  innerPacketTag0Up [0x00000007],
                                                 innerPacketTag0Dei [0x00000001]
                                             }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
        keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetMaximumValuesAndTrunkCasesMimPattern (devNum, &pattern);
        prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetMaximumValuesAction                   (devNum, &action, actionType);
        action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if (prvUtfIsPbrModeUsed())
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
        }

        if(GT_OK == st)
        {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                    &patternGet, &maskGet, actionType,
                                    &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);
            if(GT_OK == st)
            {

                st = prvCompareMimStructs(devNum, "pattern", &pattern.mim,
                                          &patternGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareMimStructs(devNum, "mask", &mask.mim, &maskGet.mim);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.mim != maskGet.mim: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /*
            Call with routerTtiTcamRow [0],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_FALSE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_FALSE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_FALSE],
                                                          trillEgressRbid [0],
                                                         trillIngressRbid [0],
                                                         innerPacketMacDa [0],
                                                    innerPacketTag0Exists [GT_FALSE],
                                                       innerPacketTag0Vid [0],
                                                innerPacketFieldsAreValid [GT_FALSE],
                                                trillMcDescriptorInstance [GT_FALSE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        /* TRILL TBD */
        #if 0
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                    (&pattern);
            prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_FALSE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_FALSE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max/2],
                                                         trillIngressRbid [max/2],
                                                         innerPacketMacDa [max/2],
                                                    innerPacketTag0Exists [GT_FALSE],
                                                       innerPacketTag0Vid [max/2],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_FALSE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                     mplsTtl [1],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [devNum],
                                                                                          portNum [max/2]
                                                                                         },
                                                                                 trunkId [max/2],
                                                                                    vidx [max/2],
                                                                                  vlanId [max/2],
                                                                                  devNum [devNum],
                                                                              fabricVidx [max/2],
                                                                                   index [max/2]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_FALSE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max/2],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                  tag0VlanId [max/2],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                  tag1VlanId [max/2],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_TRUE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [max/2],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                      tag0Up [max/2],
                                                                      tag1Up [max/2],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                             iPclConfigIndex [max/2],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [max/2],
                                                          userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max/2],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max/2],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [max/2]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetRandomValuesTrillPattern               (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
            actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetRandomValuesAction                    (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_FALSE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_FALSE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndPortCasesTrillPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_TRUE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_TRUE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                       (devNum, &action, actionType);
            action.type2.egressInterface.type               = CPSS_INTERFACE_TRUNK_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
            /*
                1.2. Call cpssDxChTtiRuleGet.
                Expected: GT_OK and the same pattern, mask and action.
            */
            if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            {
                /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
            }
            st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType, &patternGet,
                                    &maskGet, actionType, &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                      keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                             &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_FALSE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_FALSE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndPortCasesTrillPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
            /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
            action.type2.egressInterface.vidx           -= 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet,
                                        &maskGet, actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                            &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_TRUE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_TRUE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                       (devNum, &action, actionType);
            action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_FALSE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_FALSE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndPortCasesTrillPattern     (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                       (devNum, &action, actionType);
            action.type2.redirectCommand                    = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
            }


            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                               pattern { trill {                   common {
                                                                                       pclId [0],
                                                                                  srcIsTrunk [GT_TRUE],
                                                                                srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                         mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                         vid [0],
                                                                                    isTagged [GT_FLASE],
                                                                               dsaSrcIsTrunk [GT_TRUE],
                                                                             dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                dsaSrcDevice [0],
                                                                           sourcePortGroupId [0]
                                                                          },
                                                                trillMBit [GT_TRUE],
                                                          trillEgressRbid [max],
                                                         trillIngressRbid [max],
                                                         innerPacketMacDa [max],
                                                    innerPacketTag0Exists [GT_TRUE],
                                                       innerPacketTag0Vid [max],
                                                innerPacketFieldsAreValid [GT_TRUE],
                                                trillMcDescriptorInstance [GT_TRUE]
                                               }
                                       },
                                  mask { trill {                   common {
                                                                                       pclId [0xFFFFFFFF],
                                                                                  srcIsTrunk [0x01],
                                                                                srcPortTrunk [0x00000FFF],
                                                                                         mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                         vid [0x0FFF],
                                                                                    isTagged [0x01],
                                                                               dsaSrcIsTrunk [0x01],
                                                                             dsaSrcPortTrunk [0x7F],
                                                                                dsaSrcDevice [0x7F],
                                                                           sourcePortGroupId [0x00000007]
                                                                          },
                                                                trillMBit [0x01],
                                                          trillEgressRbid [0x0000FFFF],
                                                         trillIngressRbid [0x0000FFFF],
                                                         innerPacketMacDa [0x0000FFFF],
                                                    innerPacketTag0Exists [0x01],
                                                       innerPacketTag0Vid [0x00000FFF],
                                                innerPacketFieldsAreValid [0x01],
                                                trillMcDescriptorInstance [0x01]
                                               }
                                       },
                            actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                action {
                                        type2 {
                                                             tunnelTerminate [GT_TRUE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_TRUE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                     mplsTtl [max],
                                                          enableDecrementTtl [GT_TRUE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [max],
                                                                                          portNum [max]
                                                                                         },
                                                                                 trunkId [max],
                                                                                    vidx [max],
                                                                                  vlanId [max],
                                                                                  devNum [max],
                                                                              fabricVidx [max],
                                                                                   index [max]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_TRUE],
                                                                    sourceId [max],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag0VlanId [max],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [max],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                              CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_TRUE],
                                                          bindToPolicerMeter [GT_TRUE],
                                                               bindToPolicer [GT_TRUE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_TRUE],
                                                                   trustDscp [GT_TRUE],
                                                                    trustExp [GT_TRUE],
                                                                  qosProfile [max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                      tag0Up [max],
                                                                      tag1Up [max],
                                                                   remapDSCP [GT_TRUE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [max],
                                               mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                mirrorToIngressAnalyzerIndex [max],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_TRUE],
                                                         centralCounterIndex [max],
                                                                   vntl2Echo [GT_TRUE],
                                                                bridgeBypass [GT_TRUE],
                                                           ingressPipeBypass [GT_TRUE],
                                                                  actionStop [GT_TRUE],
                                                               hashMaskIndex [max],
                                                                 modifyMacSa [GT_TRUE],
                                                                 modifyMacDa [GT_TRUE],
                                                         ResetSrcPortGroupId [GT_TRUE],
                                                     multiPortGroupTtiEnable [GT_TRUE],
                                                 sourceEPortAssignmentEnable [GT_TRUE],
                                                                 sourceEPort [max]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
            prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                       (devNum, &action, actionType);
            action.type2.redirectCommand                    = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);

                st = prvCompareTrillStructs(devNum, "pattern", &pattern.trill,
                                            &patternGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                            &maskGet.trill);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "mask.trill != maskGet.trill: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
#endif

        /*
            Call with routerTtiTcamRow [0],
                               keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                               pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                               action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

            /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
            cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
            cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);
                if(GT_OK == st)
                {

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                 (GT_VOID*) &patternGet.udbArray,
                                                 sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another pattern.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                 (GT_VOID*) &maskGet.udbArray,
                                                 sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another mask.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max/2],
                               keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                               pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                               action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

            /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
            cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
            cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);
                if(GT_OK == st)
                {

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                 (GT_VOID*) &patternGet.udbArray,
                                                 sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another pattern.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                 (GT_VOID*) &maskGet.udbArray,
                                                 sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another mask.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            Call with routerTtiTcamRow [max],
                               keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                               pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                               actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                               action {
                                        type2 {
                                                             tunnelTerminate [GT_FALSE],
                                                       ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                       tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                     copyTtlFromTunnelHeader [GT_FALSE],
                                                                 mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                     mplsTtl [0],
                                                          enableDecrementTtl [GT_FALSE],
                                                                     command [CPSS_PACKET_CMD_FORWARD_E],
                                                             redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                             egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                 devPort {
                                                                                          devNum [0],
                                                                                          portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                         },
                                                                                 trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    vidx [0],
                                                                                  vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                  devNum [0],
                                                                              fabricVidx [0],
                                                                                   index [0]
                                                                             },
                                                                      arpPtr [0],
                                                                 tunnelStart [GT_TRUE],
                                                              tunnelStartPtr [0],
                                                                routerLttPtr [0],
                                                                       vrfId [0],
                                                           sourceIdSetEnable [GT_FALSE],
                                                                    sourceId [0],
                                                                 tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                  tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                 tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                  tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                          tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                            nestedVlanEnable [GT_FALSE],
                                                          bindToPolicerMeter [GT_FALSE],
                                                               bindToPolicer [GT_FALSE],
                                                                policerIndex [0],
                                                               qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                             keepPreviousQoS [GT_FALSE],
                                                                     trustUp [GT_FALSE],
                                                                   trustDscp [GT_FALSE],
                                                                    trustExp [GT_FALSE],
                                                                  qosProfile [0 / max/2 /max],
                                                                modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                               tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                  modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                      tag0Up [0],
                                                                      tag1Up [0],
                                                                   remapDSCP [GT_FALSE],
                                                     pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                   pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                     pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                             iPclConfigIndex [0],
                                               mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                mirrorToIngressAnalyzerIndex [0],
                                                          userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                        bindToCentralCounter [GT_FALSE ],
                                                         centralCounterIndex [0],
                                                                   vntl2Echo [GT_FALSE],
                                                                bridgeBypass [GT_FALSE],
                                                           ingressPipeBypass [GT_FALSE],
                                                                  actionStop [GT_FALSE],
                                                               hashMaskIndex [0],
                                                                 modifyMacSa [GT_FALSE],
                                                                 modifyMacDa [GT_FALSE],
                                                         ResetSrcPortGroupId [GT_FALSE],
                                                     multiPortGroupTtiEnable [GT_FALSE],
                                                 sourceEPortAssignmentEnable [GT_FALSE],
                                                                 sourceEPort [0]
                                              }
                                       }.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

            /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
            cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
            cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                st = cpssDxChTtiRuleGet(devNum, routerTtiTcamRow, keyType,
                                        &patternGet, &maskGet, actionType,
                                        &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiRuleGet: %d, %d, %d, %d", devNum, routerTtiTcamRow,
                                                          keyType, actionType);
                if(GT_OK == st)
                {

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                 (GT_VOID*) &patternGet.udbArray,
                                                 sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another pattern.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                 (GT_VOID*) &maskGet.udbArray,
                                                 sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                 "got another mask.udbArray",
                                                 devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }
        }

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            1.3. Call with out of range ruleIndex and other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = routerTtiTcamRowCount;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        /*
            1.4. Call with out of range pattern.ipv4.common.pclId and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.pclId                       = BIT_10;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.pclId = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.pclId);

        /*
            1.5. Call with pattern.ipv4.common.srcIsTrunk [GT_FALSE]
                           out of range pattern.ipv4.common.srcPortTrunk and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.srcIsTrunk                  = GT_FALSE;
        pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.pclId);


        /*
            1.6. Call with pattern.ipv4.common.srcIsTrunk [GT_TRUE]
                           out of range pattern.ipv4.common.srcPortTrunk and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.srcIsTrunk                  = GT_TRUE;
        pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;

        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.srcPortTrunk);

        /*
            1.7. Call with out of range pattern.ipv4.common.vid and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            pattern.ipv4.common.vid                     = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
        }
        else
        {
            pattern.ipv4.common.vid                     = BIT_12;
        }
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.vid = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.vid);

        /*
            1.8. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                           pattern.ipv4.common.dsaSrcIsTrunk [GT_FALSE]
                           out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                           other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.isTagged                    = GT_TRUE;
        pattern.ipv4.common.dsaSrcIsTrunk               = GT_FALSE;

        if (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
            pattern.ipv4.common.dsaSrcPortTrunk             = BIT_8 - 1;
        else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            pattern.ipv4.common.dsaSrcPortTrunk             = BIT_7 - 1;
        else
            pattern.ipv4.common.dsaSrcPortTrunk             = BIT_6 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.dsaSrcPortTrunk);

        /*
            1.9. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                           pattern.ipv4.common.dsaSrcIsTrunk [GT_TRUE]
                           out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                           other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.isTagged                    = GT_TRUE;
        pattern.ipv4.common.dsaSrcIsTrunk               = GT_TRUE;

        if (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
            pattern.ipv4.common.dsaSrcPortTrunk             = BIT_8 - 1;
        else
            pattern.ipv4.common.dsaSrcPortTrunk             = BIT_7 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.dsaSrcPortTrunk);

        /*
            1.10. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                            out of range pattern.ipv4.common.dsaSrcDevice and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.ipv4.common.isTagged                    = GT_TRUE;
        pattern.ipv4.common.dsaSrcDevice                = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcDevice  = %d", devNum,
            routerTtiTcamRow, keyType, actionType,
            pattern.ipv4.common.dsaSrcDevice);


        /*
            1.11. Call with wrong pattern.ipv4.tunneltype enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                             pattern.ipv4.tunneltype);
        /*
            1.12. Call with out of range pattern.mpls.common.pclId and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.pclId                       = BIT_10;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.pclId = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.pclId);


        /*
            1.13. Call with pattern.mpls.common.srcIsTrunk [GT_FALSE]
                            out of range pattern.mpls.common.srcPortTrunk and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.srcIsTrunk                  = GT_FALSE;
        pattern.mpls.common.srcPortTrunk                = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.srcPortTrunk);

        /*
            1.14. Call with pattern.mpls.common.srcIsTrunk [GT_TRUE]
                            out of range pattern.mpls.common.srcPortTrunk and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.srcIsTrunk                  = GT_TRUE;
        pattern.mpls.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.srcPortTrunk);

        /*
            1.15. Call with out of range pattern.mpls.common.vid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            pattern.mpls.common.vid                     = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
        }
        else
        {
            pattern.mpls.common.vid                     = BIT_12;
        }
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.vid = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.vid);

        /*
            1.16. Call with pattern.mpls.common.isTagged [GT_TRUE]
                            pattern.mpls.common.dsaSrcIsTrunk [GT_FALSE]
                            out of range pattern.mpls.common.dsaSrcPortTrunk
                                                            (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.isTagged                    = GT_TRUE;
        pattern.mpls.common.dsaSrcIsTrunk               = GT_FALSE;

        if (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
            pattern.mpls.common.dsaSrcPortTrunk             = BIT_8 - 1;
        else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            pattern.mpls.common.dsaSrcPortTrunk             = BIT_7 - 1;
        else
            pattern.mpls.common.dsaSrcPortTrunk             = BIT_6 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.dsaSrcPortTrunk  = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.dsaSrcPortTrunk);

        /*
            1.17. Call with pattern.mpls.common.isTagged [GT_TRUE]
                            pattern.mpls.common.dsaSrcIsTrunk [GT_TRUE]
                            out of range pattern.mpls.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.isTagged                    = GT_TRUE;
        pattern.mpls.common.dsaSrcIsTrunk               = GT_TRUE;

        if (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
            pattern.mpls.common.dsaSrcPortTrunk             = BIT_8 - 1;
        else
            pattern.mpls.common.dsaSrcPortTrunk             = BIT_7 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.dsaSrcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mpls.common.dsaSrcPortTrunk);

        /*
            1.18. Call with pattern.mpls.common.isTagged [GT_TRUE]
                            out of range pattern.mpls.common.dsaSrcDevice and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mpls.common.dsaSrcDevice                = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
        pattern.mpls.common.isTagged                    = GT_TRUE;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mpls.common.dsaSrcDevice = %d", devNum,
            routerTtiTcamRow, keyType, actionType,
            pattern.mpls.common.dsaSrcDevice);

        /*
            1.19. Call with out of range pattern.mim.common.pclId and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMplsPattern                        (&pattern);
        prvSetDefaultMplsMask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.pclId                        = BIT_10;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.pclId = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.pclId);

        /*
            1.20. Call with pattern.mim.common.srcIsTrunk [GT_FALSE]
                           out of range pattern.mim.common.srcPortTrunk and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            ( &mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.srcIsTrunk                   = GT_FALSE;
        pattern.mim.common.srcPortTrunk                 = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.srcPortTrunk);

        /*
            1.21. Call with pattern.mim.common.srcIsTrunk [GT_TRUE]
                           out of range pattern.mim.common.srcPortTrunk and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.srcIsTrunk                   = GT_TRUE;
        pattern.mim.common.srcPortTrunk                 = BIT_12;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.srcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.srcPortTrunk);

        /*
            1.22. Call with out of range pattern.mim.common.vid and
                           other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            pattern.mim.common.vid                      = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
        }
        else
        {
            pattern.mim.common.vid                      = BIT_12;
        }
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.vid = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.vid);

        /*
            1.23. Call with pattern.mim.common.isTagged [GT_TRUE]
                            pattern.mim.common.dsaSrcIsTrunk [GT_FALSE]
                            out of range pattern.mim.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.isTagged                     = GT_TRUE;
        pattern.mim.common.dsaSrcIsTrunk                = GT_FALSE;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            pattern.mim.common.dsaSrcPortTrunk              = BIT_8 - 1;
        else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
            pattern.mim.common.dsaSrcPortTrunk             = BIT_7 - 1;
        else
            pattern.mim.common.dsaSrcPortTrunk              = BIT_6 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.dsaSrcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.dsaSrcPortTrunk);

        /*
            1.24. Call with pattern.mim.common.isTagged [GT_TRUE]
                            pattern.mim.common.dsaSrcIsTrunk [GT_TRUE]
                            out of range pattern.mim.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.isTagged                     = GT_TRUE;
        pattern.mim.common.dsaSrcIsTrunk                = GT_TRUE;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            pattern.mim.common.dsaSrcPortTrunk              = BIT_11 - 1;
        else
            pattern.mim.common.dsaSrcPortTrunk              = BIT_7 - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.dsaSrcPortTrunk = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.common.dsaSrcPortTrunk);

        /*
            1.25. Call with pattern.mim.common.isTagged [GT_TRUE]
                            out of range pattern.mim.common.dsaSrcDevice
                                                    (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.common.dsaSrcDevice                 = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
        pattern.mim.common.isTagged                     = GT_TRUE;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.common.dsaSrcDevice = %d", devNum,
            routerTtiTcamRow, keyType, actionType,
            pattern.mim.common.dsaSrcDevice);

        /*
            1.26. Call with out of range pattern.mim.bUp and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.bUp                                 = CPSS_USER_PRIORITY_RANGE_CNS;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.bUp = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.bUp);

        /*
            1.27. Call with out of range pattern.mim.bDp and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.bDp                                 = DP_MAX_CNS + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.bDp = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.bDp);

        /*
            1.28. Call with out of range pattern.mim.iSid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.iSid                                = MIM_ISID_MAX_CNS + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.iSid = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.iSid);

        /*
            1.29. Call with out of range pattern.mim.iUp and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.iUp                                 = CPSS_USER_PRIORITY_RANGE_CNS;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.iUp = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.iUp);

        /*
            1.30. Call with out of range pattern.mim.iDp and
                            other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
        prvSetDefaultMimPattern                         (&pattern);
        prvSetDefaultMimMask                            (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        pattern.mim.iDp                                 = DP_MAX_CNS + 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);
        UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
            "%d, %d, %d, %d, pattern.mim.iDp = %d", devNum,
            routerTtiTcamRow, keyType, actionType, pattern.mim.iDp);

        /*
            1.31. Call with out of range pattern.mim.innerPacketTag0Vid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.passengerPacketOuterTagVid          = BIT_12;
            pattern.mim.passengerPacketOuterTagExists       = GT_TRUE;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagVid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.passengerPacketOuterTagVid);
        }

        /*
            1.32. Call with out of range pattern.mim.innerPacketTag0Up and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.passengerPacketOuterTagUp           = CPSS_USER_PRIORITY_RANGE_CNS;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagUp = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.passengerPacketOuterTagUp);
        }

        /*
            1.33. Call with out of range pattern.mim.innerPacketTag0Dei and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            ( &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.passengerPacketOuterTagDei          = BIT_1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagDei = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.passengerPacketOuterTagDei);
        }

        /*
            1.34. Call with out of range pattern.trill.common.pclId and
                            other valid params.
            Expected: NOT GT_OK.
        */
/* TBD TRILL */
#if 0
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                        (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.pclId                       = BIT_10;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d,  pattern.trill.common.pclId = %d", devNum,
                routerTtiTcamRow, keyType, actionType,  pattern.trill.common.pclId);
        }

        /*
            1.35. Call with pattern.trill.common.srcIsTrunk [GT_FALSE]
                            out of range pattern.trill.common.srcPortTrunk and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                        (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.srcIsTrunk                 = GT_FALSE;
            pattern.trill.common.srcPortTrunk               = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.common.srcPortTrunk);
        }

        /*
            1.36. Call with pattern.trill.common.srcIsTrunk [GT_TRUE]
                            out of range pattern.trill.common.srcPortTrunk and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                        (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.srcIsTrunk                 = GT_TRUE;
            pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.common.srcPortTrunk);
        }

        /*
            1.37. Call with out of range pattern.trill.common.vid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                pattern.trill.common.vid                    = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
            }
            else
            {
                pattern.trill.common.vid                    = BIT_12 - 1;
            }
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.vid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.common.vid);
        }

        /*
            1.38. Call with pattern.trill.common.isTagged [GT_TRUE]
                            pattern.trill.common.dsaSrcIsTrunk [GT_FALSE]
                            out of range pattern.trill.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.isTagged                   = GT_TRUE;
            pattern.trill.common.dsaSrcIsTrunk              = GT_FALSE;
            pattern.trill.common.dsaSrcPortTrunk            = BIT_8 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.common.dsaSrcPortTrunk);
        }

        /*
            1.39. Call with pattern.trill.common.isTagged [GT_TRUE]
                            pattern.trill.common.dsaSrcIsTrunk [GT_TRUE]
                            out of range pattern.trill.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                            other valid params.
            Expected: GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.isTagged                   = GT_TRUE;
            pattern.trill.common.dsaSrcIsTrunk              = GT_TRUE;
            pattern.trill.common.dsaSrcPortTrunk            = BIT_8 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.common.dsaSrcPortTrunk);
        }

        /*
            1.40. Call with pattern.trill.common.isTagged [GT_TRUE]
                            out of range pattern.trill.common.dsaSrcDevice and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.common.isTagged                   = GT_TRUE;
            pattern.trill.common.dsaSrcDevice               = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.common.dsaSrcDevice = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.trill.common.dsaSrcDevice);
        }

        /*
            1.41. Call with out of range pattern.trill.trillEgressRbid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.trillEgressRbid                   = BIT_16;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.trillEgressRbid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.trill.trillEgressRbid);
        }

        /*
            1.42. Call with out of range pattern.trill.trillIngressRbid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.trillIngressRbid                  = BIT_16;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.trillIngressRbid = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.trill.trillIngressRbid);
        }

        /*
            1.43. Call with out of range pattern.trill.innerPacketTag0Vid and
                            other valid params.
            Expected: NOT GT_OK.
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultTrillMask                          (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.trill.innerPacketTag0Vid = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.trill.innerPacketTag0Vid = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.trill.innerPacketTag0Vid);
        }
#endif



        /*
            1.43. Call with wrong action.type2.qosProfile values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                action.type2.qosProfile = 1024;
            }
            else
            {
                action.type2.qosProfile = 128;
            }

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);



        /*
            1.44. Call with wrong action.type2.ttPassengerPacketType enum values and
                            other valid params.
            Expected: GT_OK.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                                     "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcPortTrunk = %d", devNum,
                                     routerTtiTcamRow, keyType, actionType, action.type2.ttPassengerPacketType);

        /*
            1.45. Call with wrong action.type2.tsPassengerPacketType enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                             action.type2.tsPassengerPacketType);

        /*
            1.46. Call with wrong action.type2.command enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.command);

        /*
            1.47. Call with wrong action.type2.redirectCommand enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.redirectCommand);

        /*
            1.48. Call with wrong action.type2.tag0VlanCmd enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.tag0VlanCmd);

        /*
            1.49. Call with wrong action.type2.tag1VlanCmd enum values and
                           other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.tag1VlanCmd);

        /*
            1.50. Call with wrong action.type2.qosPrecedence enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.qosPrecedence);

        /*
            1.51. Call with wrong action.type2.userDefinedCpuCode enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            action.type2.qosPrecedence);

        /*
            1.52. Call with wrong keyType enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            keyType);

        /*
            1.53. Call with wrong keyType [CPSS_DXCH_TTI_KEY_TRILL_E] and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
/* TBD TRILL */
#if 0
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
            prvSetDefaultTrillPattern                       (&pattern);
            prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                       (devNum, &action, actionType);
            action.type2.egressInterface.type               = CPSS_INTERFACE_INDEX_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
#endif
        /*
            1.54. Call with wrong actionType enum values and
                            other valid params.
            Expected: GT_BAD_PARAM.
        */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                            (devNum, routerTtiTcamRow, keyType, &pattern,
                             &mask, actionType, &action),
                            actionType);

        /*
            1.55. Call with NULL patternPtr and other valid params.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, NULL,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, patternPtr = NULL", devNum);

        /*
            1.56. Call with NULL maskPtr and other valid params.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                NULL, actionType, &action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskPtr = NULL", devNum);

        /*
            1.57. Call with NULL actionPtr and other valid params.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, actionPtr = NULL", devNum);

        /*  1.58.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.tunnelTerminate                    = GT_TRUE;
        action.type2.ttHeaderLength                     = TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(devNum);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
          UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                      keyType, actionType);
        }

        /*  1.59.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                                (devNum, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.passengerParsingOfTransitMplsTunnelMode);
        }

        /*  1.60.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        action.type2.sourceIdSetEnable                    = GT_TRUE;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            action.type2.sourceId = 4096;
        }
        else
        {
            action.type2.sourceId = 32;
        }
        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

        /*  1.61.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.qosUseUpAsIndexEnable              = GT_TRUE;
        action.type2.qosMappingTableIndex               = 12;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
          UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }

        /*  1.62.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
        action.type2.iPclUdbConfigTableEnable           = GT_TRUE;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                                (devNum, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.iPclUdbConfigTableIndex);
        }

        /*  1.63.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.sourceEPortAssignmentEnable        = GT_TRUE;
        action.type2.sourceEPort                        = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? _16K : 8192;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
          UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }

        /*  1.64.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
        action.type2.flowId                             = 65536;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
          UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }

        /*  1.65.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.oamTimeStampEnable                 = GT_TRUE;
        action.type2.oamOffsetIndex                     = 128;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
          UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }

        /*  1.66.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);

        action.type2.oamProfile                         = 2;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }

        /*  1.67.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        action.type2.isPtpPacket                        = GT_TRUE;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleSet
                                (devNum, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.ptpTriggerType);
        }

        /*  1.68.  */
        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        action.type2.isPtpPacket                        = GT_TRUE;
        action.type2.ptpOffset                          = PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) ? 64 : 128;

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
        }
        else
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                          keyType, actionType);
        }
        /*
            1.69. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_FALSE](not relevant),
            and other valid params.
            Expected: GT_OK. (For xCat and above)
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
            action.type2.unknownSaCommand       = 4096;
            action.type2.unknownSaCommandEnable = GT_FALSE;

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d", devNum);
        }
        /*
            1.70. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_TRUE](is relevant),
            and other valid params.
            Expected: GT_BAD_PARAM. (For xCat and above)
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
        {
            action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
            action.type2.unknownSaCommandEnable = GT_TRUE;

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PARAM, st, "%d", devNum);

            /* restore values */
            action.type2.unknownSaCommandEnable = GT_FALSE;
            action.type2.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;
        }
        /*
            1.71. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_FALSE](not relevant),
            and other valid params.
            Expected: GT_OK. (For xCat and above)
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
        {
            action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
            action.type2.sourceMeshId           = 4;
            action.type2.sourceMeshIdSetEnable = GT_FALSE;

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d", devNum);
        }
        /*
            1.72. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_TRUE](is relevant),
            and other valid params.
            Expected: GT_BAD_PARAM. (For xCat and above)
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
        {
            action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
            action.type2.sourceMeshIdSetEnable  = GT_TRUE;

            st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PARAM, st, "%d", devNum);

            /* restore values */
            action.type2.sourceMeshIdSetEnable = GT_FALSE;
            action.type2.sourceMeshId = 1;
        }
    }

    /* 2. For not active devices check that function returns non GT_OK. */

    routerTtiTcamRow            = 0;
    keyType                     = CPSS_DXCH_TTI_KEY_IPV4_E;
    actionType                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E | UTF_CH3_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_SUPPORTED, st, devNum);
        }
        else
        {
            if(PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
            }
        }
    }

    /* 3. Call function with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                            &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_TTI_KEY_TYPE_ENT          keyType,
    IN  GT_U32                              ruleIndex,
    OUT CPSS_DXCH_TTI_RULE_UNT              *patternPtr,
    OUT CPSS_DXCH_TTI_RULE_UNT              *maskPtr,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    OUT CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleGet_type2)
{
/*
    ITERATE_DEVICES (APPLICABLE DEVICES: xCat; xCat3; Lion)
    1.1. Set rule for testing.
         Call cpssDxChTtiRuleSet with ruleIndex [0],
                   keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                   patternPtr->ipv4{common{pclId[1],
                                           srcIsTrunk[GT_FALSE],
                                           srcPortTrunk[23],
                                           mac[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA],
                                           vid[100],
                                           isTagged[GT_TRUE],
                                           dsaSrcIsTrunk[GT_FALSE],
                                           dsaSrcPortTrunk[0],
                                           dsaSrcDevice[devNum] },
                                    tunneltype [IPv4_OVER_IPv4],
                                    srcIp[192.168.0.1],
                                    destIp[192.168.0.2],
                                    isArp[GT_FALSE] },
                   maskPtr->ipv4 {0xFF,...},
                   actionPtr{tunnelTerminate        [GT_TRUE]
                            ttPassengerPacketType  [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E]
                            tsPassengerPacketType  [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E]
                            copyTtlFromTunnelHeader[GT_FALSE]
                            mplsCommand            [CPSS_DXCH_TTI_MPLS_NOP_CMD_E]
                            mplsTtl                [0]
                            enableDecrementTtl     [ GT_FALSE]
                            command                [CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
                            redirectCommand        [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E]
                            egressInterface.type   [CPSS_INTERFACE_TRUNK_E]
                            egressInterface.trunkId[2]
                            arpPtr                 [0]
                            tunnelStart            [GT_TRUE]
                            tunnelStartPtr         [0]
                            routerLttPtr           [0]
                            vrfId                  [0]
                            sourceIdSetEnable      [GT_TRUE]
                            sourceId               [0]
                            tag0VlanCmd            [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E]
                            tag0VlanId             [100]
                            tag1VlanCmd            [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E]
                            tag1VlanId             [100]
                            tag0VlanPrecedence     [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E]
                            nestedVlanEnable       [GT_FALSE]
                            bindToPolicerMeter     [GT_FALSE]
                            bindToPolicer          [GT_FALSE]
                            policerIndex           [0]
                            qosPrecedence          [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E]
                            keepPreviousQoS        [GT_FALSE]
                            trustUp                [0]
                            trustDscp              [0]
                            trustExp               [0]
                            qosProfile             [0]
                            modifyTag0Up           [GT_FALSE]
                            tag1UpCommand          [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E]
                            modifyDscp             [GT_FALSE]
                            tag0Up                 [0]
                            tag1Up                 [0]
                            remapDSCP              [GT_FALSE]
                            pcl0OverrideConfigIndex[CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                            pcl0_1OverrideConfigIndex[CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                            pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                            iPclConfigIndex        [0]
                            mirrorToIngressAnalyzerEnable[GT_FALSE]
                            userDefinedCpuCode           [CPSS_NET_FIRST_USER_DEFINED_E]
                            bindToCentralCounter         [GT_FALSE]
                            centralCounterIndex          [0]
                            vntl2Echo                    [GT_FALSE]
                            bridgeBypass                 [GT_FALSE]
                            ingressPipeBypass            [GT_FALSE]
                            actionStop                   [GT_FALSE]}
    Expected: GT_OK.
    1.2. Call with keyType [CPSS_DXCH_TTI_KEY_IPV4_E /
                            CPSS_DXCH_TTI_KEY_ETH_E],
                   ruleIndex [ 0 / 10],
                   non-NULL pointers.

    Expected: GT_OK and same values as written
    1.3. Call with wrong enum values keyType , other params same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.4. Call with wrong enum values actionType , other params same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.5. Call with out of range ruleIndex[maxRuleIndex], other params same as in 1.2.
    Expected: non GT_OK.
    1.6. Call with patternPtr [NULL], other params same as in 1.2.
    Expected: GT_BAD_PTR.
    1.7. Call with maskPtr [NULL], other params same as in 1.2.
    Expected: GT_BAD_PTR.
    1.8. Call with actionPtr [NULL], other params same as in 1.2.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       devNum;

    GT_U32                      ruleIndex = 0;
    CPSS_DXCH_TTI_KEY_TYPE_ENT  keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
    static CPSS_DXCH_TTI_RULE_UNT      pattern;
    static CPSS_DXCH_TTI_RULE_UNT      mask;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT actionType;
    static CPSS_DXCH_TTI_ACTION_UNT    action;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /*
            1.1. Set rule for testing.
                 Call cpssDxChTtiRuleSet with ruleIndex [0],
                           keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                           patternPtr->ipv4{common{pclId[1],
                                                   srcIsTrunk[GT_FALSE],
                                                   srcPortTrunk[23],
                                                   mac[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA],
                                                   vid[100],
                                                   isTagged[GT_TRUE],
                                                   dsaSrcIsTrunk[GT_FALSE],
                                                   dsaSrcPortTrunk[0],
                                                   dsaSrcDevice[devNum] },
                                            tunneltype [IPv4_OVER_IPv4],
                                            srcIp[192.168.0.1],
                                            destIp[192.168.0.2],
                                            isArp[GT_FALSE] },
                           maskPtr->ipv4 {0xFF,...},
                           actionPtr{tunnelTerminate        [GT_TRUE]
                                    ttPassengerPacketType  [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E]
                                    tsPassengerPacketType  [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E]
                                    copyTtlFromTunnelHeader[GT_FALSE]
                                    mplsCommand            [CPSS_DXCH_TTI_MPLS_NOP_CMD_E]
                                    mplsTtl                [0]
                                    enableDecrementTtl     [ GT_FALSE]
                                    command                [CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
                                    redirectCommand        [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E]
                                    egressInterface.type   [CPSS_INTERFACE_TRUNK_E]
                                    egressInterface.trunkId[2]
                                    arpPtr                 [0]
                                    tunnelStart            [GT_TRUE]
                                    tunnelStartPtr         [0]
                                    routerLttPtr           [0]
                                    vrfId                  [0]
                                    sourceIdSetEnable      [GT_TRUE]
                                    sourceId               [0]
                                    tag0VlanCmd            [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E]
                                    tag0VlanId             [100]
                                    tag1VlanCmd            [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E]
                                    tag1VlanId             [100]
                                    tag0VlanPrecedence     [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E]
                                    nestedVlanEnable       [GT_FALSE]
                                    bindToPolicerMeter     [GT_FALSE]
                                    bindToPolicer          [GT_FALSE]
                                    policerIndex           [0]
                                    qosPrecedence          [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E]
                                    keepPreviousQoS        [GT_FALSE]
                                    trustUp                [0]
                                    trustDscp              [0]
                                    trustExp               [0]
                                    qosProfile             [0]
                                    modifyTag0Up           [GT_FALSE]
                                    tag1UpCommand          [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E]
                                    modifyDscp             [GT_FALSE]
                                    tag0Up                 [0]
                                    tag1Up                 [0]
                                    remapDSCP              [GT_FALSE]
                                    pcl0OverrideConfigIndex[CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                                    pcl0_1OverrideConfigIndex[CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                                    pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E]
                                    iPclConfigIndex        [0]
                                    mirrorToIngressAnalyzerEnable[GT_FALSE]
                                    userDefinedCpuCode           [CPSS_NET_FIRST_USER_DEFINED_E]
                                    bindToCentralCounter         [GT_FALSE]
                                    centralCounterIndex          [0]
                                    vntl2Echo                    [GT_FALSE]
                                    bridgeBypass                 [GT_FALSE]
                                    ingressPipeBypass            [GT_FALSE]
                                    actionStop                   [GT_FALSE]}
            Expected: GT_OK.
        */
        ruleIndex = 0;
        keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

        prvSetDefaultIpv4Pattern(&pattern);
        prvSetDefaultAction(&action,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&mask);
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleSet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, ruleIndex, keyType);
        /*
            1.2. Call with keyType [CPSS_DXCH_TTI_KEY_IPV4_E /
                                    CPSS_DXCH_TTI_KEY_ETH_E,
                                    CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                           ruleIndex [ 0 / 10],
                           non-NULL pointers.
            Expected: GT_BAD_PARAM for xCat A1 and above else GT_OK and same values as written
        */
        keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
        ruleIndex = 0;
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, ruleIndex, keyType);

        /*
            call with keyType[CPSS_DXCH_TTI_KEY_UDB_UDE_E].
        */
        if(
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
        {
            keyType   = CPSS_DXCH_TTI_RULE_UDB_30_E;

            st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, ruleIndex, keyType);

            /* restore previous value*/
            keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
        }

        /*
            1.3. Call with wrong enum values keyType, other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        actionType = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;

        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleGet
                            (devNum, ruleIndex, keyType, &pattern, &mask, actionType, &action),
                            keyType);

        /*
            1.4. Call with wrong enum values actionType, other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleGet
                            (devNum, ruleIndex, keyType, &pattern, &mask, actionType, &action),
                            actionType);

        /*
            1.5. Call with out of range ruleIndex [maxRuleIndex], other params same as in 1.2.
            Expected: non GT_OK.
        */
        ruleIndex = prvGetMaxRuleIndex(devNum);
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, ruleIndex);

        ruleIndex = 0;
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        /*
            1.6. Call with patternPtr [NULL], other params same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, NULL, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, patternPtr = NULL", devNum);

        /*
            1.7. Call with maskPtr [NULL], other params same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, NULL, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskPtr = NULL", devNum);

        /*
            1.8. Call with actionPtr [NULL], other params same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, actionPtr = NULL", devNum);
    }

    ruleIndex = 0;
    keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_SUPPORTED, st, devNum);
        }
        else
        {
            if(PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum))
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            else
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }
    }

    /* 3.Call function with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleActionUpdate
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              ruleIndex,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    IN  CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleActionUpdate_type2)
{
/*
    ITERATE_DEVICES (DxCh3, xCat, Lion, xCat2, Lion2)
    1.1. actionPtr{tunnelTerminate[GT_TRUE],
                   passengerPacketType[CPSS_DXCH_TTI_PASSENGER_IPV4_E],
                   copyTtlFromTunnelHeader[GT_FALSE],
                   command [CPSS_PACKET_CMD_FORWARD_E],
                   redirectCommand[CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                   egressInterface{type[CPSS_INTERFACE_TRUNK_E],
                                   trunkId[2]},

                   tunnelStart [GT_TRUE],
                   tunnelStartPtr[0],
                   targetIsTrunk[GT_FALSE],

                   sourceIdSetEnable[GT_TRUE],
                   sourceId[0],

                   vlanCmd[CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                   vlanId[100],
                   vlanPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                   nestedVlanEnable[GT_FALSE],

                   bindToPolicer[GT_FALSE],

                   qosPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                   qosTrustMode[CPSS_DXCH_TTI_QOS_UNTRUST_E],
                   qosProfile[0],
                   modifyUpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                   modifyDscpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                   up[0],

                   mirrorToIngressAnalyzerEnable[GT_FALSE],
                   vntl2Echo[GT_FALSE],
                   bridgeBypass[GT_FALSE],
                   actionStop[GT_FALSE]
              }
    Expected: GT_OK.
    1.2. Call cpssDxChTtiRuleGet with non-NULL pointers,
                                      other params same as in 1.1.
    Expected: GT_OK and same action as written
    1.3. Call with out of range ruleIndex [3k],
                   other params same as in 1.1.
    Expected: non GT_OK.
    1.4. Call with wrong enum values actionType, other params same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.5. Call with actionPtr [NULL], other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       devNum;

    GT_U32                      ruleIndex = 0;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT actionType = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
    CPSS_DXCH_TTI_KEY_TYPE_ENT  keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
    static CPSS_DXCH_TTI_RULE_UNT      pattern;
    static CPSS_DXCH_TTI_RULE_UNT      mask;
    static CPSS_DXCH_TTI_ACTION_UNT    action;
    static CPSS_DXCH_TTI_ACTION_UNT    actionGet;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));
    cpssOsBzero((GT_VOID*) &actionGet, sizeof(actionGet));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /*
            Create default rule with action
            ruleIndex [0],
            keyType [CPSS_DXCH_TTI_KEY_IPV4_E],

            patternPtr { ipv4{common{pclId[1], srcIsTrunk[GT_FALSE], srcPortTrunk[0],
            mac[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA], vid[0], isTagged[GT_FALSE], dsaSrcIsTrunk[GT_FALSE],
            dsaSrcPortTrunk[0], dsaSrcDevice[0] }, tunneltype [IPv4_OVER_IPv4], srcIp[192.168.0.1],
            destIp[192.168.0.2], isArp[GT_FALSE] }, mpls{common{pclId[1], srcIsTrunk[GT_FALSE],
            srcPortTrunk[0], mac[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA], vid[0], isTagged[GT_FALSE],
            dsaSrcIsTrunk[GT_FALSE], dsaSrcPortTrunk[0], dsaSrcDevice[0] },
            label0[0], exp0[0], label1[0], exp1[0], label2[0], exp2[0], numOfLabels[1],
            protocolAboveMPLS[IPv4]}, eth{ common{ pclId[1], srcIsTrunk[GT_FALSE], srcPortTrunk[0],
            mac[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA], vid[0], isTagged[GT_FALSE], dsaSrcIsTrunk[GT_FALSE],
            dsaSrcPortTrunk[0], dsaSrcDevice[0]}, up0[0], cfi0[0], isVlan1Exists[GT_FALSE], vid1[0], up1[0],
            cfi1[0], etherType[0], macToMe[GT_FALSE]}  },

            maskPtr {All fields are zeroed},

            actionPtr{ tunnelTerminate[GT_FALSE], passengerPacketType[CPSS_DXCH_TTI_PASSENGER_IPV4_E],
            copyTtlFromTunnelHeader[GT_FALSE], command [CPSS_PACKET_CMD_FORWARD_E],
            redirectCommand[CPSS_DXCH_TTI_NO_REDIRECT_E], egressInterface{type[CPSS_INTERFACE_TRUNK_E],
            trunkId[0], vidx[0], vlanId[0], devPort {0, 0}}, tunnelStart [GT_FALSE], tunnelStartPtr[0],
            routerLookupPtr[0], vrfId[0], targetIsTrunk[GT_FALSE], virtualSrcPort[0], virtualSrcdev[0],
            sourceIdSetEnable[GT_FALSE], sourceId[0], vlanCmd[CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
            vlanId[0], vlanPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
            nestedVlanEnable[GT_FALSE], bindToPolicer[GT_FALSE], policerIndex[0],
            qosPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
            qosTrustMode[CPSS_DXCH_TTI_QOS_KEEP_PREVIOUS_E], qosProfile[0],
            modifyUpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E], modifyDscpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
            up[0], remapDSCP[GT_FALSE], mirrorToIngressAnalyzerEnable[GT_FALSE],
            userDefinedCpuCode[CPSS_NET_CONTROL_E],
            vntl2Echo[GT_FALSE], bridgeBypass[GT_FALSE], actionStop[GT_FALSE] }

            Expected: GT_BAD_PARAM for xCat A1 and above else GT_OK.
        */
        ruleIndex = 0;
        keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

        prvSetDefaultIpv4Pattern(&pattern);
        prvSetDefaultAction(&action,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&mask);
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleSet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, ruleIndex, keyType);
        /*
            1.1. Call function with rukeIndex[0], actionPtr{ tunnelTerminate[GT_FALSE], passengerPacketType[CPSS_DXCH_TTI_PASSENGER_IPV4_E], copyTtlFromTunnelHeader[GT_FALSE], command [CPSS_PACKET_CMD_FORWARD_E], redirectCommand[CPSS_DXCH_TTI_NO_REDIRECT_E], egressInterface{type[CPSS_INTERFACE_TRUNK_E], trunkId[0], vidx[0], vlanId[0], devPort {0, 0}}, tunnelStart [GT_FALSE], tunnelStartPtr[0], routerLookupPtr[0], vrfId[0], targetIsTrunk[GT_FALSE], virtualSrcPort[0], virtualSrcdev[0], sourceIdSetEnable[GT_FALSE], sourceId[0], vlanCmd[CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E], vlanId[0], vlanPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E], nestedVlanEnable[GT_FALSE], bindToPolicer[GT_FALSE], policerIndex[0], qosPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E], qosTrustMode[CPSS_DXCH_TTI_QOS_KEEP_PREVIOUS_E], qosProfile[0], modifyUpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E], modifyDscpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E], up[0], remapDSCP[GT_FALSE], mirrorToIngressAnalyzerEnable[GT_FALSE], userDefinedCpuCode[CPSS_NET_CONTROL_E], vntl2Echo[GT_FALSE], bridgeBypass[GT_FALSE], actionStop[GT_FALSE] }
            Expected: GT_OK.
        */
        ruleIndex = 0;

        prvSetDefaultAction(&action,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleActionUpdate(devNum, ruleIndex, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, ruleIndex);

        /*
            1.2. Call cpssDxChTtiRuleGet with non-NULL pointers, other params same as in 1.1.
            Expected: GT_OK and same action as written
        */
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, keyType, &pattern, &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &actionGet);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, keyType, ruleIndex);
        /* validation values */
        st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                     &actionGet);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
            "action != actionGet: %d, %d, %d, %d",
            devNum, ruleIndex, keyType, actionType);

       /*
            1.3. Call with out of range ruleIndex [maxRuleIndex],
                           other params same as in 1.1.
            Expected: non GT_OK.
        */
        ruleIndex = prvGetMaxRuleIndex(devNum);
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        st = cpssDxChTtiRuleActionUpdate(devNum, ruleIndex, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, ruleIndex);

        ruleIndex = 0;
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        /*
            1.4. Call with wrong enum values actionType, other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChTtiRuleActionUpdate
                            (devNum, ruleIndex, actionType, &action),
                            actionType);

        /*
            1.5. Call with actionPtr [NULL], other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleActionUpdate(devNum, ruleIndex, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, "%d, actionPtr = NULL", devNum);

    }

    ruleIndex = 0;
    keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        prvSetDefaultAction(&action,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);

        st = cpssDxChTtiRuleActionUpdate(devNum, ruleIndex, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_SUPPORTED, st, devNum);
        else
        {
            if(PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum))
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            else
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }
    }

    /* 3.Call function with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiRuleActionUpdate(devNum, ruleIndex, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleValidStatusSet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              routerTtiTcamRow,
    IN  GT_BOOL                             valid
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleValidStatusSet)
{
/*
    ITERATE_DEVICES (DxCh3, xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max]
                              valid [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChTtiRuleValidStatusGet.
    Expected: GT_OK and the same valid.
    1.3. Call with out of range routerTtiTcamRow and other valid params.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;

    GT_U8       devNum;
    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    GT_BOOL                                 valid;
    GT_BOOL                                 validGet;
    CPSS_DXCH_TTI_KEY_TYPE_ENT  keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
    CPSS_DXCH_TTI_RULE_UNT      pattern;
    CPSS_DXCH_TTI_RULE_UNT      mask;
    CPSS_DXCH_TTI_ACTION_UNT    action;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT           actionType;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /*
            1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max]
                                      valid [GT_FALSE / GT_TRUE].
            Expected: GT_OK.
        */

        routerTtiTcamRow = 0;
        keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;
        actionType = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;


        prvSetDefaultIpv4Pattern(&pattern);
        prvSetDefaultAction(&action,actionType);
        prvSetDefaultIpv4Mask(&mask);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern, &mask, actionType, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

        valid = GT_FALSE;

        st = cpssDxChTtiRuleValidStatusSet(devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, valid);

        /*
            1.2. Call cpssDxChTtiRuleValidStatusGet.
            Expected: GT_OK and the same valid.
        */
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &validGet);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChTtiRuleValidStatusGet: %d, %d, %d", devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_STRING_MAC(valid, validGet,
            "get another valid than was set: %d, %d, %d", devNum, routerTtiTcamRow, valid);

        /* Call with routerTtiTcamRow [3] and valid [GT_FALSE]. */
        routerTtiTcamRow    = 3;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern, &mask, actionType, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

        valid               = GT_TRUE;

        st = cpssDxChTtiRuleValidStatusSet(devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, valid);

        /*
            1.2. Call cpssDxChTtiRuleValidStatusGet.
            Expected: GT_OK and the same valid.
        */
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &validGet);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChTtiRuleValidStatusGet: %d, %d, %d", devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_STRING_MAC(valid, validGet,
            "get another valid than was set: %d, %d, %d", devNum, routerTtiTcamRow, valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /* Call with routerTtiTcamRow [max/2] and valid [GT_FALSE]. */
        routerTtiTcamRow    = (routerTtiTcamRowCount - 1) / 2;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern, &mask, actionType, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

        valid = GT_FALSE;

        st = cpssDxChTtiRuleValidStatusSet(devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, valid);

        /*
            1.2. Call cpssDxChTtiRuleValidStatusGet.
            Expected: GT_OK and the same valid.
        */
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &validGet);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChTtiRuleValidStatusGet: %d, %d, %d", devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_STRING_MAC(valid, validGet,
            "get another valid than was set: %d, %d, %d", devNum, routerTtiTcamRow, valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /* Call with routerTtiTcamRow [max] and valid [GT_TRUE].    */
        routerTtiTcamRow    = routerTtiTcamRowCount - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern, &mask, actionType, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

        valid               = GT_TRUE;

        st = cpssDxChTtiRuleValidStatusSet(devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, valid);

        /*
            1.2. Call cpssDxChTtiRuleValidStatusGet.
            Expected: GT_OK and the same valid.
        */
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &validGet);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChTtiRuleValidStatusGet: %d, %d, %d", devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL3_STRING_MAC(valid, validGet,
            "get another valid than was set: %d, %d, %d", devNum, routerTtiTcamRow, valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /*
            1.3. Call with out of range routerTtiTcamRow and other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow    = routerTtiTcamRowCount;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);
        valid               = GT_FALSE;

        st = cpssDxChTtiRuleValidStatusSet(devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, valid);
    }

    /* 2. For not active devices check that function returns non GT_OK. */
    routerTtiTcamRow = 0;
    valid            = GT_TRUE;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiRuleValidStatusSet( devNum, routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiRuleValidStatusSet( devNum, routerTtiTcamRow, valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleValidStatusGet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              routerTtiTcamRow,
    OUT GT_BOOL                             *validPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleValidStatusGet)
{
/*
    ITERATE_DEVICES (DxCh3, xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max] and other valid params.
    Expected: GT_OK.
    1.2 Call with out of range routerTtiTcamRow and other valid params.
    Expected: NOT GT_OK.
    1.3. Call with NULL validPtr.
    Expected: GT_BAD_PTR.
*/

    GT_STATUS                               st = GT_OK;

    GT_U8                                   devNum;
    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    GT_BOOL                                 valid;
    CPSS_DXCH_TTI_KEY_TYPE_ENT              keyType;
    CPSS_DXCH_TTI_RULE_UNT                  pattern;
    CPSS_DXCH_TTI_RULE_UNT                  mask;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT           actionType;
    CPSS_DXCH_TTI_ACTION_UNT                action;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern,        sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask,           sizeof(mask));
    cpssOsBzero((GT_VOID*) &action,         sizeof(action));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /*
            1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max] and
                           other valid params.
            Expected: GT_OK.
        */

        keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                    (&pattern);
        prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
        actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;

        prvSetDefaultAction                         (&action, actionType);
        routerTtiTcamRow = 0;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, &valid);

        /* Call with routerTtiTcamRow [1].  */
        routerTtiTcamRow    = 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, &valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /* Call with routerTtiTcamRow [max/2].  */
        routerTtiTcamRow    = (routerTtiTcamRowCount - 1) / 2;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, &valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);

        /* Call with routerTtiTcamRow [max].    */
        routerTtiTcamRow    = routerTtiTcamRowCount - 1;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleSet(devNum, routerTtiTcamRow, keyType, &pattern,
                                &mask, actionType, &action);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                    actionType);

        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, &valid);

        /* Call cpssDxChCfgTableNumEntriesGet. */
        st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                           &routerTtiTcamRowCount);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
            "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
            devNum, routerTtiTcamRowCount);
        /*
            1.2 Call with out of range routerTtiTcamRow and other valid params.
            Expected: NOT GT_OK.
        */
        routerTtiTcamRow    = routerTtiTcamRowCount;
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, &valid);

        /*
            1.3. Call with NULL validPtr.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, NULL);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st,
            "%d, validPtr = NULL", devNum, routerTtiTcamRow);
    }

    /* 2. For not active devices check that function returns non GT_OK.*/
    routerTtiTcamRow    = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiRuleValidStatusGet(devNum, routerTtiTcamRow, &valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiPortGroupRuleSet
(
    IN  GT_U8                               devNum,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  GT_U32                              routerTtiTcamRow,
    IN  CPSS_DXCH_TTI_KEY_TYPE_ENT          keyType,
    IN  CPSS_DXCH_TTI_RULE_UNT              *patternPtr,
    IN  CPSS_DXCH_TTI_RULE_UNT              *maskPtr,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    IN  CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiPortGroupRuleSet_type2)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / max/2 / max],
                            keyType [CPSS_DXCH_TTI_KEY_IPV4_E,
                                     CPSS_DXCH_TTI_KEY_MPLS_E,
                                     CPSS_DXCH_TTI_KEY_ETH_E,
                                     CPSS_DXCH_TTI_KEY_MIM_E,
                                     CPSS_DXCH_TTI_KEY_TRILL_E,
                                     CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                            pattern { ipv4 {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                           tunneltype [0 / 3 / max],
                                                                srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                               destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                isArp [GT_FALSE / GT_TRUE]
                                           },
                                      mpls {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                               label0 [0 / max/2 / max],
                                                                 exp0 [0 / max/2 / max],
                                                               label1 [0 / max/2 / max],
                                                                 exp1 [0 / max/2 / max],
                                                               label2 [0 / max/2 / max],
                                                                 exp2 [0 / max/2 / max],
                                                          numOfLabels [0 / max/2 / max],
                                                    protocolAboveMPLS [0 / max/2 / max],
                                                   reservedLabelExist [GT_FALSE / GT_TRUE],
                                                   reservedLabelValue [0 / max/2 / max],
                                                   channelTypeProfile [0 / max/2 / max],
                                                        cwFirstNibble [0 / max/2 / max]
                                           },
                                       eth {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                                  up0 [0 / max/2 / max],
                                                                 cfi0 [0 / max/2 / max],
                                                        isVlan1Exists [GT_FALSE / GT_TRUE],
                                                                 vid1 [0 / max/2 / max],
                                                                  up1 [0 / max/2 / max],
                                                                 cfi1 [0 / max/2 / max],
                                                            etherType [0 / max/2 / max],
                                                              macToMe [GT_FALSE / GT_TRUE],
                                                                srcId [0 / max/2 / max],
                                                        dsaQosProfile [0 / max/2 / max],
                                                        tag0TpidIndex [0 / max/2 / max],
                                                        tag1TpidIndex [0 / max/2 / max]
                                           },
                                       mim {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                                  bUp [0 / max/2 / max],
                                                                  bDp [0 / max/2 / max],
                                                                 iSid [0 / max/2 / max],
                                                                  iUp [0 / max/2 / max],
                                                                  iDp [0 / max/2 / max],
                                                                iRes1 [0 / max/2 / max],
                                                                iRes2 [0 / max/2 / max],
                                                              macToMe [GT_FALSE / GT_TRUE],
                                                innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                   innerPacketTag0Vid [0 / max/2 / max],
                                                    innerPacketTag0Up [0 / max/2 / max],
                                                   innerPacketTag0Dei [0 / max]
                                           },
                                     trill {                   common {
                                                                                   pclId [0 / max/ 2 / max],
                                                                              srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0 / max/2 / max],
                                                                                isTagged [GT_FLASE / GT_TRUE],
                                                                           dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                            dsaSrcDevice [0 / max/2 / max],
                                                                       sourcePortGroupId [0 / max/2 / max]
                                                                      },
                                                            trillMBit [GT_FALSE / GT_TRUE],
                                                      trillEgressRbid [0 / max/2 / max],
                                                     trillIngressRbid [0 / max/2 / max],
                                                     innerPacketMacDa [0 / max/2 / max],
                                                innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                   innerPacketTag0Vid [0 / max/2 / max],
                                            innerPacketFieldsAreValid [GT_FALSE / GT_TRUE],
                                            trillMcDescriptorInstance [GT_FALSE / GT_TRUE]
                                           },
                                      udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                    },
                               mask { ipv4 {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                           tunneltype [0x00000007],
                                                                srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                               destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                isArp [0x01]
                                           },
                                      mpls {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                           },
                                       eth {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                                  up0 [0x00000007],
                                                                 cfi0 [0x00000001],
                                                        isVlan1Exists [0x01],
                                                                 vid1 [0x00000FFF],
                                                                  up1 [0x00000007],
                                                                 cfi1 [0x00000001],
                                                            etherType [0x0000FFFF],
                                                              macToMe [0x01],
                                                                srcId [0x0000001F],
                                                        dsaQosProfile [0x0000007F],
                                                        tag0TpidIndex [0x00000003],
                                                        tag1TpidIndex [0x00000003]
                                           },
                                       mim {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                                  bUp [0x00000007],
                                                                  bUp [0x00000001],
                                                                 iSid [0x00FFFFFF],
                                                                  iUp [0x00000FFF],
                                                                  iDp [0x00000001],
                                                                iRes1 [0x00000003],
                                                                iRes2 [0x00000003],
                                                              macToMe [0x01],
                                                innerPacketTag0Exists [0x01],
                                                   innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketTag0Up [0x00000007],
                                                   innerPacketTag0Dei [0x00000001]
                                           },
                                     trill {                   common {
                                                                                   pclId [0x000003FF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                            trillMBit [0x01],
                                                      trillEgressRbid [0x0000FFFF],
                                                     trillIngressRbid [0x0000FFFF],
                                                     innerPacketMacDa [0x0000FFFF],
                                                innerPacketTag0Exists [0x01],
                                                   innerPacketTag0Vid [0x00000FFF],
                                            innerPacketFieldsAreValid [0x01],
                                            trillMcDescriptorInstance [0x01]
                                           },
                                      udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                    },
                         actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                             action {
                                     type2 {
                                                          tunnelTerminate [GT_FALSE / GT_TRUE],
                                                    ttpassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E /
                                                                           CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                    tspassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E /
                                                                           CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                  copyTtlFromTunnelHeader [GT_FALSE / GT_TRUE],
                                                              mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E /
                                                                           CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E /
                                                                           CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                  mplsTtl [0 / 1 / max],
                                                       enableDecrementTtl [GT_FALSE / GT_TRUE],
                                                                  command [CPSS_PACKET_CMD_FORWARD_E /
                                                                           CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                                                           CPSS_PACKET_CMD_TRAP_TO_CPU_E],
                                                          redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E /
                                                                           CPSS_DXCH_TTI_NO_REDIRECT_E /
                                                                           CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E /
                                                                           CPSS_DXCH_TTI_VRF_ID_ASSIGN_E /
                                                                           CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
                                                          egressInterface {      type [CPSS_INTERFACE_PORT_E /
                                                                                       CPSS_INTERFACE_TRUNK_E /
                                                                                       CPSS_INTERFACE_VIDX_E],
                                                                              devPort {
                                                                                       devNum [0 / devNum / max],
                                                                                       portNum [TTI_VALID_PORT_TRUNK_CNS / max/2 / max]
                                                                                      },
                                                                              trunkId [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                 vidx [0 / max/2 / max],
                                                                               vlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                               devNum [0 / devNum / max],
                                                                           fabricVidx [0 / max/2 / max],
                                                                                index [0 / max/2 / max]
                                                                          },
                                                                   arpPtr [0],
                                                              tunnelStart [GT_TRUE / GT_FALSE],
                                                           tunnelStartPtr [0],
                                                             routerLttPtr [0],
                                                                    vrfId [0],
                                                        sourceIdSetEnable [GT_FALSE / GT_TRUE],
                                                                 sourceId [0 / max/2 / max],
                                                             tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                               tag0VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                              tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E /
                                                                           CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                               tag1VlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                       tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                           CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                         nestedVlanEnable [GT_FALSE / GT_TRUE],
                                                       bindToPolicerMeter [GT_FALSE / GT_TRUE],
                                                            bindToPolicer [GT_FALSE / GT_TRUE],
                                                             policerIndex [0],
                                                            qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                           CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                          keepPreviousQoS [GT_TRUE / GT_FALSE],
                                                                  trustUp [GT_FALSE / GT_TRUE],
                                                                trustDscp [GT_FALSE / GT_TRUE],
                                                                 trustExp [GT_FALSE / GT_TRUE],
                                                               qosProfile [0 / max/2 /max],
                                                             modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E /
                                                                           CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E /
                                                                           CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                            tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E /
                                                                           CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E /
                                                                           CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                               modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E /
                                                                           CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E /
                                                                           CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                   tag0Up [0 / max/2 / max],
                                                                   tag1Up [0 / max/2 / max],
                                                                remapDSCP [GT_FALSE / GT_TRUE],
                                                  pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                  pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E /
                                                                           CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                          iPclConfigIndex [0 / max/2 /max],
                                            mirrorToIngressAnalyzerEnable [GT_FALSE / GT_TRUE],
                                             mirrorToIngressAnalyzerIndex [0 / max],
                                                       userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1 /
                                                                           CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                     bindToCentralCounter [GT_FALSE / GT_TRUE],
                                                      centralCounterIndex [0 / max/2 / max],
                                                                vntl2Echo [GT_FALSE / GT_TRUE],
                                                             bridgeBypass [GT_FALSE / GT_TRUE],
                                                        ingressPipeBypass [GT_FALSE / GT_TRUE],
                                                               actionStop [GT_FALSE / GT_TRUE],
                                                            hashMaskIndex [0 / max/2 / max],
                                                              modifyMacSa [GT_FALSE / GT_TRUE],
                                                              modifyMacDa [GT_FALSE / GT_TRUE],
                                                      ResetSrcPortGroupId [GT_FALSE / GT_TRUE],
                                                   multiPortGroupTtiEnable [GT_FALSE / GT_TRUE],
                                              sourceEPortAssignmentEnable [GT_FALSE / GT_TRUE],
                                                              sourceEPort [0 / max/2 / max],
                                                   unknownSaCommandEnable [GT_FALSE / GT_TRUE],
                                                         unknownSaCommand [CPSS_PACKET_CMD_FORWARD_E /
                                                                           CPSS_PACKET_CMD_DROP_SOFT_E /
                                                                           CPSS_PACKET_CMD_LOOPBACK_E],
                                                    sourceMeshIdSetEnable [GT_FALSE],
                                                             sourceMeshId [0 / 1 / 3]
                                           }
                                    }.
    Expected: GT_OK.
    1.2. Call cpssDxChTtiPortGroupRuleGet.
    Expected: GT_OK and the same pattern, mask and action.
    1.3. Call with out of range ruleIndex and other valid params.
    Expected: NOT GT_OK.
    1.4. Call with out of range pattern.ipv4.common.pclId and
                   other valid params.
    Expected: NOT GT_OK.
    1.5. Call with pattern.ipv4.common.srcIsTrunk [GT_FALSE]
                   out of range pattern.ipv4.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.6. Call with pattern.ipv4.common.srcIsTrunk [GT_TRUE]
                   out of range pattern.ipv4.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.7. Call with out of range pattern.ipv4.common.vid and
                   other valid params.
    Expected: NOT GT_OK.
    1.8. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                   pattern.ipv4.common.dsaSrcIsTrunk [GT_FALSE]
                   out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                (do not constraint) and
                   other valid params.
    Expected: GT_OK.
    1.9. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                   pattern.ipv4.common.dsaSrcIsTrunk [GT_TRUE]
                   out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                (do not constraint) and
                   other valid params.
    Expected: GT_OK.
    1.10. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                    out of range pattern.ipv4.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.11. Call with wrong pattern.ipv4.tunneltype enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.12. Call with out of range pattern.mpls.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.13. Call with pattern.mpls.common.srcIsTrunk [GT_FALSE]
                    out of range pattern.mpls.common.srcPortTrunk and
                    other valid params.
    Expected: GT_OK.
    1.14. Call with pattern.mpls.common.srcIsTrunk [GT_TRUE]
                    out of range pattern.mpls.common.srcPortTrunk and
                    other valid params.
    Expected: GT_OK.
    1.15. Call with out of range pattern.mpls.common.vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.16. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    pattern.mpls.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.mpls.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.17. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    pattern.mpls.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.mpls.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.18. Call with pattern.mpls.common.isTagged [GT_TRUE]
                    out of range pattern.mpls.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.19. Call with out of range pattern.mim.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.20. Call with pattern.mim.common.srcIsTrunk [GT_FALSE]
                   out of range pattern.mim.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.21. Call with pattern.mim.common.srcIsTrunk [GT_TRUE]
                   out of range pattern.mim.common.srcPortTrunk and
                   other valid params.
    Expected: NOT GT_OK.
    1.22. Call with out of range pattern.mim.common.vid and
                   other valid params.
    Expected: NOT GT_OK.
    1.23. Call with pattern.mim.common.isTagged [GT_TRUE]
                    pattern.mim.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.mim.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.24. Call with pattern.mim.common.isTagged [GT_TRUE]
                    pattern.mim.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.mim.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.25. Call with pattern.mim.common.isTagged [GT_TRUE]
                    out of range pattern.mim.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.26. Call with out of range pattern.mim.bUp and
                    other valid params.
    Expected: NOT GT_OK.
    1.27. Call with out of range pattern.mim.bDp and
                    other valid params.
    Expected: NOT GT_OK.
    1.28. Call with out of range pattern.mim.iSid and
                    other valid params.
    Expected: NOT GT_OK.
    1.29. Call with out of range pattern.mim.iUp and
                    other valid params.
    Expected: NOT GT_OK.
    1.30. Call with out of range pattern.mim.iDp and
                    other valid params.
    Expected: NOT GT_OK.
    1.31. Call with out of range pattern.mim.innerPacketTag0Vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.32. Call with out of range pattern.mim.innerPacketTag0Up and
                    other valid params.
    Expected: NOT GT_OK.
    1.33. Call with out of range pattern.mim.innerPacketTag0Dei and
                    other valid params.
    Expected: NOT GT_OK.
    1.34. Call with out of range pattern.trill.common.pclId and
                    other valid params.
    Expected: NOT GT_OK.
    1.35. Call with pattern.trill.common.srcIsTrunk [GT_FALSE]
                    out of range pattern.trill.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.36. Call with pattern.trill.common.srcIsTrunk [GT_TRUE]
                    out of range pattern.trill.common.srcPortTrunk and
                    other valid params.
    Expected: NOT GT_OK.
    1.37. Call with out of range pattern.trill.common.vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.38. Call with pattern.trill.common.isTagged [GT_TRUE]
                    pattern.trill.common.dsaSrcIsTrunk [GT_FALSE]
                    out of range pattern.trill.common.dsaSrcPortTrunk ]
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.39. Call with pattern.trill.common.isTagged [GT_TRUE]
                    pattern.trill.common.dsaSrcIsTrunk [GT_TRUE]
                    out of range pattern.trill.common.dsaSrcPortTrunk
                                                (do not constraint) and
                    other valid params.
    Expected: GT_OK.
    1.40. Call with pattern.trill.common.isTagged [GT_TRUE]
                    out of range pattern.trill.common.dsaSrcDevice and
                    other valid params.
    Expected: NOT GT_OK.
    1.41. Call with out of range pattern.trill.trillEgressRbid and
                    other valid params.
    Expected: NOT GT_OK.
    1.42. Call with out of range pattern.trill.trillIngressRbid and
                    other valid params.
    Expected: NOT GT_OK.
    1.43. Call with out of range pattern.trill.innerPacketTag0Vid and
                    other valid params.
    Expected: NOT GT_OK.
    1.44. Call with wrong action.type2.ttPassengerPacketType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.45. Call with wrong action.type2.tsPassengerPacketType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.46. Call with wrong action.type2.command enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.47. Call with wrong action.type2.redirectCommand enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.48. Call with wrong action.type2.tag2VlanCmd enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.49 Call with wrong action.type2.tag1VlanCmd enum values and
                   other valid params.
    Expected: GT_BAD_PARAM.
    1.50. Call with wrong action.type2.qosPrecedence enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.51. Call with wrong action.type2.userDefinedCpuCode enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.52. Call with wrong keyType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.53. Call with wrong keyType [CPSS_DXCH_TTI_KEY_TRILL_E] and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.54. Call with wrong actionType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.55. Call with NULL patternPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.56. Call with NULL maskPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.57. Call with NULL actionPtr and other valid params.
    Expected: GT_BAD_PTR.
    1.58. Call with out of range action.type2.ttHeaderLength and
                    other valid params.
    Expected: NOT GT_OK.
    1.59. Call with wrong action.type2.passengerParsingOfTransitMplsTunnelMode enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.60. Call with out of range action.type2.ttHeaderLength and
                    other valid params.
    Expected: NOT GT_OK.
    1.61. Call with out of range action.type2.qosMappingTableIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.62. Call with wrong action.type2.iPclUdbConfigTableIndex enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.63. Call with out of range action.type2.qosMappingTableIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.64. Call with out of range action.type2.flowId and
                    other valid params.
    Expected: NOT GT_OK.
    1.65. Call with out of range action.type2.oamOffsetIndex and
                    other valid params.
    Expected: NOT GT_OK.
    1.66. Call with out of range action.type2.oamProfile and
                    other valid params.
    Expected: NOT GT_OK.
    1.67. Call with wrong action.type2.ptpTriggerType enum values and
                    other valid params.
    Expected: GT_BAD_PARAM.
    1.68. Call with out of range action.type2.ptpOffset and
                    other valid params.
    Expected: NOT GT_OK.
    1.69. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_FALSE](not relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_OK.
    1.70. Call with out of range actionPtr->unknownSaCommand[4096],
            actionPtr->unknownSaCommandEnable[GT_TRUE](is relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_BAD_PARAM.
    1.71. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_FALSE](not relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_OK.
    1.72. Call with out of range actionPtr->sourceMeshId[4],
            actionPtr->sourceMeshIdSetEnable[GT_TRUE](is relevant),
            actionPtr->redirectCommand [CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
            other valid params.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   devNum;
    GT_PORT_GROUPS_BMP                      portGroupsBmp;
    GT_U32                                  portGroupId;
    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    CPSS_DXCH_TTI_KEY_TYPE_ENT              keyType;
    CPSS_DXCH_TTI_RULE_UNT                  pattern;
    CPSS_DXCH_TTI_RULE_UNT                  patternGet;
    CPSS_DXCH_TTI_RULE_UNT                  mask;
    CPSS_DXCH_TTI_RULE_UNT                  maskGet;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT           actionType;
    CPSS_DXCH_TTI_ACTION_UNT                action;
    CPSS_DXCH_TTI_ACTION_UNT                actionGet;
    GT_BOOL                                 isEqual = GT_FALSE;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern,        sizeof(pattern));
    cpssOsBzero((GT_VOID*) &patternGet,     sizeof(patternGet));
    cpssOsBzero((GT_VOID*) &mask,           sizeof(mask));
    cpssOsBzero((GT_VOID*) &maskGet,        sizeof(maskGet));
    cpssOsBzero((GT_VOID*) &action,         sizeof(action));
    cpssOsBzero((GT_VOID*) &actionGet,      sizeof(actionGet));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /* Initialize port group. */
        portGroupId = 1;

        /* 1.1. Go over all active port groups. */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next active port group. */
            portGroupsBmp = (1 << portGroupId);

            /* only port groups (0,4) supported */
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                portGroupsBmp = 0xFF;

            /*
                1.1. Call with routerTtiTcamRow [0 / max/2 / max],
                                        keyType [CPSS_DXCH_TTI_KEY_IPV4_E,
                                                 CPSS_DXCH_TTI_KEY_MPLS_E,
                                                 CPSS_DXCH_TTI_KEY_ETH_E,
                                                 CPSS_DXCH_TTI_KEY_MIM_E,
                                                 CPSS_DXCH_TTI_KEY_TRILL_E,
                                                 CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                                        pattern { ipv4 {                   common {
                                                                                               pclId [0 / max/2 / max],
                                                                                          srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                                 vid [0 / max/2 / max],
                                                                                            isTagged [GT_FLASE / GT_TRUE],
                                                                                       dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                        dsaSrcDevice [0 / max/2 / max],
                                                                                   sourcePortGroupId [0 / max/2 / max]
                                                                                  },
                                                                       tunneltype [0 / 3 / max],
                                                                            srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                           destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                            isArp [GT_FALSE / GT_TRUE]
                                                       },
                                                  mpls {                   common {
                                                                                               pclId [0 / max/2 / max],
                                                                                          srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                                 vid [0 / max/2 / max],
                                                                                            isTagged [GT_FLASE / GT_TRUE],
                                                                                       dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                        dsaSrcDevice [0 / max/2 / max],
                                                                                   sourcePortGroupId [0 / max/2 / max]
                                                                                  },
                                                                           label0 [0 / max/2 / max],
                                                                             exp0 [0 / max/2 / max],
                                                                           label1 [0 / max/2 / max],
                                                                             exp1 [0 / max/2 / max],
                                                                           label2 [0 / max/2 / max],
                                                                             exp2 [0 / max/2 / max],
                                                                      numOfLabels [0 / max/2 / max],
                                                                protocolAboveMPLS [0 / max/2 / max],
                                                               reservedLabelExist [GT_FALSE / GT_TRUE],
                                                               reservedLabelValue [0 / max/2 / max],
                                                               channelTypeProfile [0 / max/2 / max],
                                                                    cwFirstNibble [0 / max/2 / max]
                                                       },
                                                   eth {                   common {
                                                                                               pclId [0 / max/2 / max],
                                                                                          srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                                 vid [0 / max/2 / max],
                                                                                            isTagged [GT_FLASE / GT_TRUE],
                                                                                       dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                        dsaSrcDevice [0 / max/2 / max],
                                                                                   sourcePortGroupId [0 / max/2 / max]
                                                                                  },
                                                                              up0 [0 / max/2 / max],
                                                                             cfi0 [0 / max/2 / max],
                                                                    isVlan1Exists [GT_FALSE / GT_TRUE],
                                                                             vid1 [0 / max/2 / max],
                                                                              up1 [0 / max/2 / max],
                                                                             cfi1 [0 / max/2 / max],
                                                                        etherType [0 / max/2 / max],
                                                                          macToMe [GT_FALSE / GT_TRUE],
                                                                            srcId [0 / max/2 / max],
                                                                    dsaQosProfile [0 / max/2 / max],
                                                                    tag0TpidIndex [0 / max/2 / max],
                                                                    tag1TpidIndex [0 / max/2 / max]
                                                       },
                                                   mim {                   common {
                                                                                               pclId [0 / max/2 / max],
                                                                                          srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                                 vid [0 / max/2 / max],
                                                                                            isTagged [GT_FLASE / GT_TRUE],
                                                                                       dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                        dsaSrcDevice [0 / max/2 / max],
                                                                                   sourcePortGroupId [0 / max/2 / max]
                                                                                  },
                                                                              bUp [0 / max/2 / max],
                                                                              bDp [0 / max/2 / max],
                                                                             iSid [0 / max/2 / max],
                                                                              iUp [0 / max/2 / max],
                                                                              iDp [0 / max/2 / max],
                                                                            iRes1 [0 / max/2 / max],
                                                                            iRes2 [0 / max/2 / max],
                                                                          macToMe [GT_FALSE / GT_TRUE],
                                                            innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                               innerPacketTag0Vid [0 / max/2 / max],
                                                                innerPacketTag0Up [0 / max/2 / max],
                                                               innerPacketTag0Dei [0 / max]
                                                       },
                                                 trill {                   common {
                                                                                               pclId [0 / max/2 / max],
                                                                                          srcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                        srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                                 mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                                 vid [0 / max/2 / max],
                                                                                            isTagged [GT_FLASE / GT_TRUE],
                                                                                       dsaSrcIsTrunk [GT_FALSE / GT_TRUE],
                                                                                     dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS / max/2 / max],
                                                                                        dsaSrcDevice [0 / max/2 / max],
                                                                                   sourcePortGroupId [0 / max/2 / max]
                                                                                  },
                                                                        trillMBit [GT_FALSE / GT_TRUE],
                                                                  trillEgressRbid [0 / max/2 / max],
                                                                 trillIngressRbid [0 / max/2 / max],
                                                                 innerPacketMacDa [0 / max/2 / max],
                                                            innerPacketTag0Exists [GT_FALSE / GT_TRUE],
                                                               innerPacketTag0Vid [0 / max/2 / max],
                                                        innerPacketFieldsAreValid [GT_FALSE / GT_TRUE],
                                                        trillMcDescriptorInstance [GT_FALSE / GT_TRUE]
                                                       },
                                                  udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                                },
                                           mask { ipv4 {                   common {
                                                                                               pclId [0xFFFFFFFF],
                                                                                          srcIsTrunk [0x01],
                                                                                        srcPortTrunk [0x00000FFF],
                                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                                 vid [0x0FFF],
                                                                                            isTagged [0x01],
                                                                                       dsaSrcIsTrunk [0x01],
                                                                                     dsaSrcPortTrunk [0x7F],
                                                                                        dsaSrcDevice [0x7F],
                                                                                   sourcePortGroupId [0x00000007]
                                                                                  },
                                                                       tunneltype [0x00000007],
                                                                            srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                           destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                            isArp [0x01]
                                                       },
                                                  mpls {                   common {
                                                                                                pclId [0xFFFFFFFF],
                                                                                          srcIsTrunk [0x01],
                                                                                        srcPortTrunk [0x00000FFF],
                                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                                 vid [0x0FFF],
                                                                                            isTagged [0x01],
                                                                                       dsaSrcIsTrunk [0x01],
                                                                                     dsaSrcPortTrunk [0x7F],
                                                                                        dsaSrcDevice [0x7F],
                                                                                   sourcePortGroupId [0x00000007]
                                                                                  },
                                                                           label0 [0x000FFFFF],
                                                                             exp0 [0x00000007],
                                                                           label1 [0x000FFFFF],
                                                                             exp1 [0x00000007],
                                                                           label2 [0x000FFFFF],
                                                                             exp2 [0x00000007],
                                                                      numOfLabels [0x00000003],
                                                                protocolAboveMPLS [0x00000003],
                                                               reservedLabelExist [0xFF],
                                                               reservedLabelValue [0x0000000F],
                                                               channelTypeProfile [0x00000007],
                                                                    cwFirstNibble [0x0000000F]
                                                       },
                                                   eth {                   common {
                                                                                               pclId [0xFFFFFFFF],
                                                                                          srcIsTrunk [0x01],
                                                                                        srcPortTrunk [0x00000FFF],
                                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                                 vid [0x0FFF],
                                                                                            isTagged [0x01],
                                                                                       dsaSrcIsTrunk [0x01],
                                                                                     dsaSrcPortTrunk [0x7F],
                                                                                        dsaSrcDevice [0x7F],
                                                                                   sourcePortGroupId [0x00000007]
                                                                                  },
                                                                              up0 [0x00000007],
                                                                             cfi0 [0x00000001],
                                                                    isVlan1Exists [0x01],
                                                                             vid1 [0x00000FFF],
                                                                              up1 [0x00000007],
                                                                             cfi1 [0x00000001],
                                                                        etherType [0x0000FFFF],
                                                                          macToMe [0x01],
                                                                            srcId [0x0000001F],
                                                                    dsaQosProfile [0x0000007F],
                                                                    tag0TpidIndex [0x00000003],
                                                                    tag1TpidIndex [0x00000003]
                                                       },
                                                   mim {                   common {
                                                                                               pclId [0xFFFFFFFF],
                                                                                          srcIsTrunk [0x01],
                                                                                        srcPortTrunk [0x00000FFF],
                                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                                 vid [0x0FFF],
                                                                                            isTagged [0x01],
                                                                                       dsaSrcIsTrunk [0x01],
                                                                                     dsaSrcPortTrunk [0x7F],
                                                                                        dsaSrcDevice [0x7F],
                                                                                   sourcePortGroupId [0x00000007]
                                                                                  },
                                                                              bUp [0x00000007],
                                                                              bUp [0x00000001],
                                                                             iSid [0x00FFFFFF],
                                                                              iUp [0x00000FFF],
                                                                              iDp [0x00000001],
                                                                            iRes1 [0x00000003],
                                                                            iRes2 [0x00000003],
                                                                          macToMe [0x01],
                                                            innerPacketTag0Exists [0x01],
                                                               innerPacketTag0Vid [0x00000FFF],
                                                                innerPacketTag0Up [0x00000007],
                                                               innerPacketTag0Dei [0x00000001]
                                                       },
                                                 trill {                   common {
                                                                                               pclId [0xFFFFFFFF],
                                                                                          srcIsTrunk [0x01],
                                                                                        srcPortTrunk [0x00000FFF],
                                                                                                 mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                                 vid [0x0FFF],
                                                                                            isTagged [0x01],
                                                                                       dsaSrcIsTrunk [0x01],
                                                                                     dsaSrcPortTrunk [0x7F],
                                                                                        dsaSrcDevice [0x7F],
                                                                                   sourcePortGroupId [0x00000007]
                                                                                  },
                                                                        trillMBit [0x01],
                                                                  trillEgressRbid [0x0000FFFF],
                                                                 trillIngressRbid [0x0000FFFF],
                                                                 innerPacketMacDa [0x0000FFFF],
                                                            innerPacketTag0Exists [0x01],
                                                               innerPacketTag0Vid [0x00000FFF],
                                                        innerPacketFieldsAreValid [0x01],
                                                        trillMcDescriptorInstance [0x01]
                                                       },
                                                  udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]
                                                },
                                     actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                         action {
                                                 type2 {
                                                                       tunnelTerminate [GT_FALSE / GT_TRUE],
                                                                   passengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4_E /
                                                                                        CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E /
                                                                                        CPSS_DXCH_TTI_PASSENGER_ETHERNET_NO_CRC_E],
                                                               copyTtlFromTunnelHeader [GT_FALSE / GT_TRUE],
                                                                               command [CPSS_PACKET_CMD_FORWARD_E /
                                                                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                                                                        CPSS_PACKET_CMD_TRAP_TO_CPU_E],
                                                                       redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E /
                                                                                        CPSS_DXCH_TTI_NO_REDIRECT_E /
                                                                                        CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E /
                                                                                        CPSS_DXCH_TTI_VRF_ID_ASSIGN_E /
                                                                                        CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E],
                                                                       egressInterface {      type [CPSS_INTERFACE_PORT_E /
                                                                                                    CPSS_INTERFACE_TRUNK_E /
                                                                                                    CPSS_INTERFACE_VIDX_E],
                                                                                           devPort {
                                                                                                    devNum [0 / devNum / max],
                                                                                                    portNum [TTI_VALID_PORT_TRUNK_CNS / max/2 / max]
                                                                                                   },
                                                                                           trunkId [100 / max/2 / max],
                                                                                              vidx [0 / max/2 / max],
                                                                                            vlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                                            devNum [0 / devNum / max],
                                                                                        fabricVidx [0 / max/2 / max],
                                                                                             index [0 / max/2 / max]
                                                                                       },
                                                                           tunnelStart [GT_TRUE / GT_FALSE],
                                                                        tunnelStartPtr [0],
                                                                       routerLookupPtr [0],
                                                                                 vrfId [0],
                                                                     sourceIdSetEnable [GT_FALSE / GT_TRUE],
                                                                              sourceId [0 / max/2 / max],
                                                                                vlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E /
                                                                                        CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                                vlanId [TTI_VALID_VLAN_ID_CNS / max/2 / max],
                                                                        vlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                        CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                      nestedVlanEnable [GT_FALSE / GT_TRUE],
                                                                         bindToPolicer [GT_FALSE / GT_TRUE],
                                                                          policerIndex [0],
                                                                          qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                        CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                          qosTrustMode [CPSS_DXCH_TTI_QOS_KEEP_PREVIOUS_E /
                                                                                        CPSS_DXCH_TTI_QOS_TRUST_MPLS_EXP_E],
                                                                             qosProfile [0 / max/2 / max],
                                                                        modifyUpEnable [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E /
                                                                                       CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                      modifyDscpEnable [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E /
                                                                                        CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E /
                                                                                        CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E];
                                                                                    up [0 / max/2 / max],
                                                                             remapDSCP [GT_FALSE / GT_TRUE],
                                                         mirrorToIngressAnalyzerEnable [GT_FALSE / GT_TRUE],
                                                                    userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1 /
                                                                                        CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                                             vntl2Echo [GT_FALSE / GT_TRUE],
                                                                          bridgeBypass [GT_FALSE / GT_TRUE],
                                                                            actionStop [GT_FALSE / GT_TRUE],
                                                                       activateCounter [GT_FALSE / GT_TRUE],
                                                                          counterIndex [0 / max/2 / max]
                                                       }
                                                }.
                Expected: GT_OK.
            */
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                    (&pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4StructsPortGroup(devNum, portGroupId,"pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action,  &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max/2],
                                                                      srcIsTrunk [GT_FALSE],
                                                                    srcPortTrunk [max/2],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max/2],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_FALSE],
                                                                 dsaSrcPortTrunk [max/2],
                                                                    dsaSrcDevice [max/2],
                                                               sourcePortGroupId [max/2]
                                                              },
                                                   tunneltype [3],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_FALSE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0xFFFFFFFF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                   tunneltype [0x00000007],
                                                        srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                       destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                        isArp [0x01]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                         mplsTtl [1],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [devNum],
                                                                                              portNum [max/2]
                                                                                             },
                                                                                     trunkId [max/2],
                                                                                        vidx [max/2],
                                                                                      vlanId [max/2],
                                                                                      devNum [devNum],
                                                                                  fabricVidx [max/2],
                                                                                       index [max/2]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_FALSE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max/2],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                      tag0VlanId [max/2],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                      tag1VlanId [max/2],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_TRUE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [max/2],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                          tag0Up [max/2],
                                                                          tag1Up [max/2],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                 iPclConfigIndex [max/2],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [max/2],
                                                              userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max/2],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max/2],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [max/2]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetRandomValuesIpv4Pattern               (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetRandomValuesAction                    (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4StructsPortGroup(devNum, portGroupId,"pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action,  &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_FALSE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_FALSE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {

                    st = prvCompareIpv4StructsPortGroup(devNum, portGroupId,"pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_TRUE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_TRUE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                            routerTtiTcamRow, keyType, &pattern,
                                            &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_FALSE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_FALSE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
            /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
            action.type2.egressInterface.vidx           -= 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4StructsPortGroup(devNum, portGroupId,"pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_TRUE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_TRUE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_FALSE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_FALSE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndPortCasesIpv4Pattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4StructsPortGroup(devNum, portGroupId,"pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                    keyType [CPSS_DXCH_TTI_KEY_IPV4_E],
                                   pattern { ipv4 {    common {
                                                                           pclId [max],
                                                                      srcIsTrunk [GT_TRUE],
                                                                    srcPortTrunk [max],
                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                             vid [max],
                                                                        isTagged [GT_TRUE],
                                                                   dsasrcIsTrunk [GT_TRUE],
                                                                 dsaSrcPortTrunk [max],
                                                                    dsaSrcDevice [max],
                                                               sourcePortGroupId [max]
                                                              },
                                                   tunneltype [max],
                                                        srcIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                       destIp [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                        isArp [GT_TRUE]
                                                  }
                                           },
                                      mask { ipv4 {    common {
                                                                           pclId [0x000003FF],
                                                                      srcIsTrunk [0x01],
                                                                    srcPortTrunk [0x00000FFF],
                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                             vid [0x0FFF],
                                                                        isTagged [0x01],
                                                                   dsaSrcIsTrunk [0x01],
                                                                 dsaSrcPortTrunk [0x7F],
                                                                    dsaSrcDevice [0x7F],
                                                               sourcePortGroupId [0x00000007]
                                                              },
                                                                 tunneltype [0x00000007],
                                                                     srcIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                     destIp [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                      isArp [0x01]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetMaximumValuesAndTrunkCasesIpv4Pattern (devNum, &pattern);
            prvSetDefaultDeviceDependentIpv4Mask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.ipv4.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.ipv4.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareIpv4Structs(devNum, "pattern", &pattern.ipv4,
                                               &patternGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.ipv4 != patternGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareIpv4Structs(devNum, "mask", &mask.ipv4,
                                               &maskGet.ipv4);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.ipv4 != maskGet.ipv4: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /*
                Call with routerTtiTcamRow [0],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [0],
                                                                              srcIsTrunk [GT_FALSE],
                                                                            srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [0],
                                                                                isTagged [GT_FLASE],
                                                                           dsaSrcIsTrunk [GT_FALSE],
                                                                         dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                            dsaSrcDevice [0],
                                                                       sourcePortGroupId [0]
                                                                      },
                                                               label0 [0],
                                                                 exp0 [0],
                                                               label1 [0],
                                                                 exp1 [0],
                                                               label2 [0],
                                                                 exp2 [0],
                                                          numOfLabels [0],
                                                    protocolAboveMPLS [0],
                                                   reservedLabelExist [GT_FALSE],
                                                   reservedLabelValue [0],
                                                   channelTypeProfile [0],
                                                        cwFirstNibble [0]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                    (&pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructsPortGroup(devNum, portGroupId,"pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max/2],
                                                                              srcIsTrunk [GT_FALSE],
                                                                            srcPortTrunk [max/2],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max/2],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_FALSE],
                                                                         dsaSrcPortTrunk [max/2],
                                                                            dsaSrcDevice [max/2],
                                                                       sourcePortGroupId [max/2]
                                                                      },
                                                               label0 [max/2],
                                                                 exp0 [max/2],
                                                               label1 [max/2],
                                                                 exp1 [max/2],
                                                               label2 [max/2],
                                                                 exp2 [max/2],
                                                          numOfLabels [max/2],
                                                    protocolAboveMPLS [max/2],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max/2],
                                                   channelTypeProfile [max/2],
                                                        cwFirstNibble [max/2]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                         mplsTtl [1],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [devNum],
                                                                                              portNum [max/2]
                                                                                             },
                                                                                     trunkId [max/2],
                                                                                        vidx [max/2],
                                                                                      vlanId [max/2],
                                                                                      devNum [devNum],
                                                                                  fabricVidx [max/2],
                                                                                       index [max/2]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_FALSE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max/2],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                      tag0VlanId [max/2],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                      tag1VlanId [max/2],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_TRUE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [max/2],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                          tag0Up [max/2],
                                                                          tag1Up [max/2],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                 iPclConfigIndex [max/2],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [max/2],
                                                              userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max/2],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max/2],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [max/2]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetRandomValuesMplsPattern               (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetRandomValuesAction                    (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_FALSE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_FALSE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructsPortGroup(devNum, portGroupId,"pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_TRUE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_TRUE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType,
                                             &pattern, &mask, actionType,
                                             &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_FALSE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_FALSE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
            /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
            action.type2.egressInterface.vidx           -= 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructsPortGroup(devNum,portGroupId, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_TRUE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_TRUE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_FALSE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_FALSE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndPortCasesMplsPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructsPortGroup(devNum, portGroupId,"pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MPLS_E],
                                   pattern { mpls {            common {
                                                                                   pclId [max],
                                                                              srcIsTrunk [GT_TRUE],
                                                                            srcPortTrunk [max],
                                                                                     mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                     vid [max],
                                                                                isTagged [GT_TRUE],
                                                                           dsasrcIsTrunk [GT_TRUE],
                                                                         dsaSrcPortTrunk [max],
                                                                            dsaSrcDevice [max],
                                                                       sourcePortGroupId [max]
                                                                      },
                                                               label0 [max],
                                                                 exp0 [max],
                                                               label1 [max],
                                                                 exp1 [max],
                                                               label2 [max],
                                                                 exp2 [max],
                                                          numOfLabels [max],
                                                    protocolAboveMPLS [max],
                                                   reservedLabelExist [GT_TRUE],
                                                   reservedLabelValue [max],
                                                   channelTypeProfile [max],
                                                        cwFirstNibble [max]
                                                  }
                                           },
                                      mask { mpls {            common {
                                                                                   pclId [0xFFFFFFFF],
                                                                              srcIsTrunk [0x01],
                                                                            srcPortTrunk [0x00000FFF],
                                                                                     mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                     vid [0x0FFF],
                                                                                isTagged [0x01],
                                                                           dsaSrcIsTrunk [0x01],
                                                                         dsaSrcPortTrunk [0x7F],
                                                                            dsaSrcDevice [0x7F],
                                                                       sourcePortGroupId [0x00000007]
                                                                      },
                                                               label0 [0x000FFFFF],
                                                                 exp0 [0x00000007],
                                                               label1 [0x000FFFFF],
                                                                 exp1 [0x00000007],
                                                               label2 [0x000FFFFF],
                                                                 exp2 [0x00000007],
                                                          numOfLabels [0x00000003],
                                                    protocolAboveMPLS [0x00000003],
                                                   reservedLabelExist [0xFF],
                                                   reservedLabelValue [0x0000000F],
                                                   channelTypeProfile [0x00000007],
                                                        cwFirstNibble [0x0000000F]
                                                  }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, keyType,
                                                &patternGet, &maskGet,
                                                actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetMaximumValuesAndTrunkCasesMplsPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMplsMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            action.type2.mplsCommand                    = CPSS_DXCH_TTI_MPLS_POP2_CMD_E;

            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mpls.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mpls.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, keyType,
                                                &patternGet, &maskGet,
                                                actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMplsStructs(devNum, "pattern", &pattern.mpls,
                                               &patternGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mpls != patternGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMplsStructs(devNum, "mask", &mask.mpls,
                                               &maskGet.mpls);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mpls != maskGet.mpls: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }


            action.type2.tunnelTerminate    = GT_FALSE;
            action.type2.mplsCommand        = CPSS_DXCH_TTI_MPLS_POP3_CMD_E;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);


            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChTtiPortGroupRuleSet");

                if(GT_OK == st)
                {

                     st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, keyType,
                                                &patternGet, &maskGet,
                                                actionType, &actionGet);
                     UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                     st = prvCompareActionStructs(devNum, "action", actionType,
                                                     &action, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                            "action != actionGet: %d, %d, %d, %d",
                            devNum, routerTtiTcamRow, keyType, actionType);
                }
                else
                {
                    UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChTtiPortGroupRuleSet fails with CPSS_DXCH_TTI_MPLS_POP3_CMD_E");
                }
            }
            else
            {
                UTF_VERIFY_EQUAL0_STRING_MAC(GT_BAD_PARAM, st,"cpssDxChTtiPortGroupRuleSet fails with CPSS_DXCH_TTI_MPLS_POP3_CMD_E");
            }


            action.type2.mplsCommand                    = CPSS_DXCH_TTI_MPLS_POP_AND_SWAP_CMD_E;
            action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if(GT_OK == st)
            {

                 st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                            routerTtiTcamRow, keyType,
                                            &patternGet, &maskGet,
                                            actionType, &actionGet);
                 UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                 st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChTtiPortGroupRuleSet fails with CPSS_DXCH_TTI_MPLS_POP_AND_SWAP_CMD_E");
            }



            action.type2.mplsCommand                    = CPSS_DXCH_TTI_MPLS_SWAP_CMD_E;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if(GT_OK == st)
            {

                 st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                            routerTtiTcamRow, keyType,
                                            &patternGet, &maskGet,
                                            actionType, &actionGet);
                 UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                 st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChTtiPortGroupRuleSet fails with CPSS_DXCH_TTI_MPLS_SWAP_CMD_E");
            }

            /*
                Call with routerTtiTcamRow [0],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [0],
                                                                        srcIsTrunk [GT_FALSE],
                                                                      srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [0],
                                                                          isTagged [GT_FLASE],
                                                                     dsaSrcIsTrunk [GT_FALSE],
                                                                   dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                      dsaSrcDevice [0],
                                                                 sourcePortGroupId [0]
                                                                },
                                                            up0 [0],
                                                           cfi0 [0],
                                                  isVlan1Exists [GT_FALSE],
                                                           vid1 [0],
                                                            up1 [0],
                                                           cfi1 [0],
                                                      etherType [0],
                                                        macToMe [GT_FALSE],
                                                          srcId [0],
                                                  dsaQosProfile [0],
                                                  tag0TpidIndex [0],
                                                  tag1TpidIndex [0]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetDefaultEthPattern                     (&pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                            routerTtiTcamRow, keyType, &pattern,
                                            &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructsPortGroup(devNum,portGroupId, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max/2],
                                                                        srcIsTrunk [GT_FALSE],
                                                                      srcPortTrunk [max/2],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max/2],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_FALSE],
                                                                   dsaSrcPortTrunk [max/2],
                                                                      dsaSrcDevice [max/2],
                                                                 sourcePortGroupId [max/2]
                                                                },
                                                            up0 [max/2],
                                                           cfi0 [max/2],
                                                  isVlan1Exists [GT_FALSE],
                                                           vid1 [max/2],
                                                            up1 [max/2],
                                                           cfi1 [max/2],
                                                      etherType [max/2],
                                                        macToMe [GT_TRUE],
                                                          srcId [max/2],
                                                  dsaQosProfile [max/2],
                                                  tag0TpidIndex [max/2],
                                                  tag1TpidIndex [max/2]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                         mplsTtl [1],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [devNum],
                                                                                              portNum [max/2]
                                                                                             },
                                                                                     trunkId [max/2],
                                                                                        vidx [max/2],
                                                                                      vlanId [max/2],
                                                                                      devNum [devNum],
                                                                                  fabricVidx [max/2],
                                                                                       index [max/2]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_FALSE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max/2],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                      tag0VlanId [max/2],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                      tag1VlanId [max/2],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_TRUE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [max/2],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                          tag0Up [max/2],
                                                                          tag1Up [max/2],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                 iPclConfigIndex [max/2],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [max/2],
                                                              userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max/2],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max/2],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [max/2]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetRandomValuesEthPattern                (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetRandomValuesAction                    (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructsPortGroup(devNum,portGroupId, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_FALSE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_FALSE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
#ifdef /**/ ff
#endif
            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructsPortGroup(devNum, portGroupId,"pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_TRUE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_TRUE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType,actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_FALSE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_FALSE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
            /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
            action.type2.egressInterface.vidx           -= 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructsPortGroup(devNum, portGroupId, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_TRUE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_TRUE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_FALSE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_FALSE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndPortCasesEthPattern   (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructsPortGroup(devNum, portGroupId, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_ETH_E],
                                   pattern { eth {       common {
                                                                             pclId [max],
                                                                        srcIsTrunk [GT_TRUE],
                                                                      srcPortTrunk [max],
                                                                               mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                               vid [max],
                                                                          isTagged [GT_TRUE],
                                                                     dsasrcIsTrunk [GT_TRUE],
                                                                   dsaSrcPortTrunk [max],
                                                                      dsaSrcDevice [max],
                                                                 sourcePortGroupId [max]
                                                                },
                                                            up0 [max],
                                                           cfi0 [max],
                                                  isVlan1Exists [GT_TRUE],
                                                           vid1 [max],
                                                            up1 [max],
                                                           cfi1 [max],
                                                      etherType [max],
                                                        macToMe [GT_TRUE],
                                                          srcId [max],
                                                  dsaQosProfile [max],
                                                  tag0TpidIndex [max],
                                                  tag1TpidIndex [max]
                                                 }
                                           },
                                      mask { eth {       common {
                                                                             pclId [0xFFFFFFFF],
                                                                        srcIsTrunk [0x01],
                                                                      srcPortTrunk [0x00000FFF],
                                                                               mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                               vid [0x0FFF],
                                                                          isTagged [0x01],
                                                                     dsaSrcIsTrunk [0x01],
                                                                   dsaSrcPortTrunk [0x7F],
                                                                      dsaSrcDevice [0x7F],
                                                                 sourcePortGroupId [0x00000007]
                                                                },
                                                            up0 [0x00000007],
                                                           cfi0 [0x00000001],
                                                  isVlan1Exists [0x01],
                                                           vid1 [0x00000FFF],
                                                            up1 [0x00000007],
                                                           cfi1 [0x00000001],
                                                      etherType [0x0000FFFF],
                                                        macToMe [0x01],
                                                          srcId [0x0000001F],
                                                  dsaQosProfile [0x0000007F],
                                                  tag0TpidIndex [0x00000003],
                                                  tag1TpidIndex [0x00000003]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_ETH_E;
            prvSetMaximumValuesAndTrunkCasesEthPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentEthMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                            actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                            actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.eth.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.eth.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareEthStructs(devNum, "pattern", &pattern.eth,
                                              &patternGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.eth != patternGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareEthStructs(devNum, "mask", &mask.eth,
                                              &maskGet.eth);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.eth != maskGet.eth: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /*
                Call with routerTtiTcamRow [0],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [0],
                                                                                srcIsTrunk [GT_FALSE],
                                                                              srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [0],
                                                                                  isTagged [GT_FLASE],
                                                                             dsaSrcIsTrunk [GT_FALSE],
                                                                           dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                              dsaSrcDevice [0],
                                                                         sourcePortGroupId [0]
                                                                        },
                                                                    bUp [0],
                                                                    bDp [0],
                                                                   iSid [0],
                                                                    iUp [0],
                                                                    iDp [0],
                                                                  iRes1 [0],
                                                                  iRes2 [0],
                                                                macToMe [GT_FALSE],
                                                  innerPacketTag0Exists [GT_FALSE],
                                                     innerPacketTag0Vid [0],
                                                      innerPacketTag0Up [0],
                                                     innerPacketTag0Dei [0]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = 0;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                    (&pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                         (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId,"pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max/2],
                                                                                srcIsTrunk [GT_FALSE],
                                                                              srcPortTrunk [max/2],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max/2],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_FALSE],
                                                                           dsaSrcPortTrunk [max/2],
                                                                              dsaSrcDevice [max/2],
                                                                         sourcePortGroupId [max/2]
                                                                        },
                                                                    bUp [max/2],
                                                                    bDp [max/2],
                                                                   iSid [max/2],
                                                                    iUp [max/2],
                                                                    iDp [max/2],
                                                                  iRes1 [max/2],
                                                                  iRes2 [max/2],
                                                                macToMe [GT_FALSE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max/2],
                                                      innerPacketTag0Up [max/2],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                         mplsTtl [1],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [devNum],
                                                                                              portNum [max/2]
                                                                                             },
                                                                                     trunkId [max/2],
                                                                                        vidx [max/2],
                                                                                      vlanId [max/2],
                                                                                      devNum [devNum],
                                                                                  fabricVidx [max/2],
                                                                                       index [max/2]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_FALSE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max/2],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                      tag0VlanId [max/2],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                      tag1VlanId [max/2],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_TRUE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [max/2],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                          tag0Up [max/2],
                                                                          tag1Up [max/2],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                 iPclConfigIndex [max/2],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [max/2],
                                                              userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max/2],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max/2],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [max/2]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetRandomValuesMimPattern               (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetRandomValuesAction                    (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId,"pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_FALSE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_FALSE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_TRUE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_TRUE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndTrunkCasesMimPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_TRUNK_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_FALSE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_FALSE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
            /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
            action.type2.egressInterface.vidx           -= 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_TRUE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_TRUE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndTrunkCasesMimPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask         (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_NO_REDIRECT_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_FALSE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_FALSE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndPortCasesMimPattern  (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }

            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum, portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /* check out of range routerLttPtr */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                action.type2.redirectCommand    = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
                action.type2.routerLttPtr       = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(devNum)->ip.maxNumOfPbrEntries;

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType, actionType);

                action.type2.routerLttPtr      = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(devNum)->ip.maxNumOfPbrEntries-1;
                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType, actionType);

                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                action.type2.routerLttPtr      = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(devNum)->ip.maxNumOfPbrEntries/2;
                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType, actionType);

                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);

                st = prvCompareActionStructs(devNum, "action", actionType,
                                             &action, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "action != actionGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);
            }

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_MIM_E],
                                   pattern { mim {               common {
                                                                                     pclId [max],
                                                                                srcIsTrunk [GT_TRUE],
                                                                              srcPortTrunk [max],
                                                                                       mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                       vid [max],
                                                                                  isTagged [GT_TRUE],
                                                                             dsasrcIsTrunk [GT_TRUE],
                                                                           dsaSrcPortTrunk [max],
                                                                              dsaSrcDevice [max],
                                                                         sourcePortGroupId [max]
                                                                        },
                                                                    bUp [max],
                                                                    bDp [max],
                                                                   iSid [max],
                                                                    iUp [max],
                                                                    iDp [max],
                                                                  iRes1 [max],
                                                                  iRes2 [max],
                                                                macToMe [GT_TRUE],
                                                  innerPacketTag0Exists [GT_TRUE],
                                                     innerPacketTag0Vid [max],
                                                      innerPacketTag0Up [max],
                                                     innerPacketTag0Dei [max]
                                                 }
                                           },
                                      mask { mim {               common {
                                                                                     pclId [0xFFFFFFFF],
                                                                                srcIsTrunk [0x01],
                                                                              srcPortTrunk [0x00000FFF],
                                                                                       mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                       vid [0x0FFF],
                                                                                  isTagged [0x01],
                                                                             dsaSrcIsTrunk [0x01],
                                                                           dsaSrcPortTrunk [0x7F],
                                                                              dsaSrcDevice [0x7F],
                                                                         sourcePortGroupId [0x00000007]
                                                                        },
                                                                    bUp [0x00000007],
                                                                    bUp [0x00000001],
                                                                   iSid [0x00FFFFFF],
                                                                    iUp [0x00000FFF],
                                                                    iDp [0x00000001],
                                                                  iRes1 [0x00000003],
                                                                  iRes2 [0x00000003],
                                                                macToMe [0x01],
                                                  innerPacketTag0Exists [0x01],
                                                     innerPacketTag0Vid [0x00000FFF],
                                                      innerPacketTag0Up [0x00000007],
                                                     innerPacketTag0Dei [0x00000001]
                                                 }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
            keyType                                     = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetMaximumValuesAndTrunkCasesMimPattern (devNum, &pattern);
            prvSetDefaultDeviceDependentMimMask        (devNum, &mask);
            actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetMaximumValuesAction                   (devNum, &action, actionType);
            action.type2.redirectCommand                = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);

            if (prvUtfIsPbrModeUsed())
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                        keyType, actionType);
            }


            if(GT_OK == st)
            {
                /*
                    1.2. Call cpssDxChTtiPortGroupRuleGet.
                    Expected: GT_OK and the same pattern, mask and action.
                */
                if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                {
                    /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                    U32_SET_FIELD_MASKED_MAC(pattern.mim.common.dsaSrcDevice,0,1,0);
                    U32_SET_FIELD_MASKED_MAC(mask.mim.common.dsaSrcDevice,0,1,0);
                }
                st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &patternGet, &maskGet,
                                                 actionType, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                    devNum, routerTtiTcamRow, keyType, actionType);

                if(GT_OK == st)
                {
                    st = prvCompareMimStructsPortGroup(devNum,portGroupId, "pattern", &pattern.mim,
                                              &patternGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.mim != patternGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareMimStructs(devNum, "mask", &mask.mim,
                                              &maskGet.mim);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.mim != maskGet.mim: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /*
                Call with routerTtiTcamRow [0],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_FALSE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_FALSE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_FALSE],
                                                              trillEgressRbid [0],
                                                             trillIngressRbid [0],
                                                             innerPacketMacDa [0],
                                                        innerPacketTag0Exists [GT_FALSE],
                                                           innerPacketTag0Vid [0],
                                                    innerPacketFieldsAreValid [GT_FALSE],
                                                    trillMcDescriptorInstance [GT_FALSE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }

                                           }.
            */
/* TBD TRILL */
#if 0
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = 0;
                keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                    (&pattern);
                prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                         (&action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask",
                                                &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_FALSE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_FALSE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max/2],
                                                             trillIngressRbid [max/2],
                                                             innerPacketMacDa [max/2],
                                                        innerPacketTag0Exists [GT_FALSE],
                                                           innerPacketTag0Vid [max/2],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_FALSE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_ETHERNET_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E],
                                                                         mplsTtl [1],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [devNum],
                                                                                              portNum [max/2]
                                                                                             },
                                                                                     trunkId [max/2],
                                                                                        vidx [max/2],
                                                                                      vlanId [max/2],
                                                                                      devNum [devNum],
                                                                                  fabricVidx [max/2],
                                                                                       index [max/2]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_FALSE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max/2],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E],
                                                                      tag0VlanId [max/2],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E],
                                                                      tag1VlanId [max/2],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_TRUE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [max/2],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E],
                                                                          tag0Up [max/2],
                                                                          tag1Up [max/2],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E],
                                                                 iPclConfigIndex [max/2],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [max/2],
                                                              userDefinedCpuCode [CPSS_NET_LAST_USER_DEFINED_E - 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max/2],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max/2],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [max/2]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
                keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetRandomValuesTrillPattern               (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
                actionType                                   = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetRandomValuesAction                    (devNum, &action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, keyType,
                                                &pattern, &mask, actionType,
                                                &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType,actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_FALSE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_FALSE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
                keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndPortCasesTrillPattern  (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                   (devNum, &action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_TRUNK_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                       (devNum, &action, actionType);
                action.type2.egressInterface.type               = CPSS_INTERFACE_TRUNK_E;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum,portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_FALSE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_FALSE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_VIDX_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
                keyType                                     = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndPortCasesTrillPattern  (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask        (devNum, &mask);
                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                   (devNum, &action, actionType);
                action.type2.egressInterface.type           = CPSS_INTERFACE_VIDX_E;
                /* vidx with value 0xFFF should not be used , because will be recognized as 'VID'*/
                action.type2.egressInterface.vidx           -= 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_NO_REDIRECT_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                       (devNum, &action, actionType);
                action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_FALSE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_FALSE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndPortCasesTrillPattern     (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                       (devNum, &action, actionType);
                action.type2.redirectCommand                    = CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);

                if (prvUtfIsPbrModeUsed())
                {
                    UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
                }
                else
                {
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
                }

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_TRILL_E],
                                   pattern { trill {                   common {
                                                                                           pclId [0],
                                                                                      srcIsTrunk [GT_TRUE],
                                                                                    srcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                             mac [[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]],
                                                                                             vid [0],
                                                                                        isTagged [GT_FLASE],
                                                                                   dsaSrcIsTrunk [GT_TRUE],
                                                                                 dsaSrcPortTrunk [TTI_VALID_PORT_TRUNK_CNS],
                                                                                    dsaSrcDevice [0],
                                                                               sourcePortGroupId [0]
                                                                              },
                                                                    trillMBit [GT_TRUE],
                                                              trillEgressRbid [max],
                                                             trillIngressRbid [max],
                                                             innerPacketMacDa [max],
                                                        innerPacketTag0Exists [GT_TRUE],
                                                           innerPacketTag0Vid [max],
                                                    innerPacketFieldsAreValid [GT_TRUE],
                                                    trillMcDescriptorInstance [GT_TRUE]
                                                   }
                                           },
                                      mask { trill {                   common {
                                                                                           pclId [0xFFFFFFFF],
                                                                                      srcIsTrunk [0x01],
                                                                                    srcPortTrunk [0x00000FFF],
                                                                                             mac [[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]],
                                                                                             vid [0x0FFF],
                                                                                        isTagged [0x01],
                                                                                   dsaSrcIsTrunk [0x01],
                                                                                 dsaSrcPortTrunk [0x7F],
                                                                                    dsaSrcDevice [0x7F],
                                                                               sourcePortGroupId [0x00000007]
                                                                              },
                                                                    trillMBit [0x01],
                                                              trillEgressRbid [0x0000FFFF],
                                                             trillIngressRbid [0x0000FFFF],
                                                             innerPacketMacDa [0x0000FFFF],
                                                        innerPacketTag0Exists [0x01],
                                                           innerPacketTag0Vid [0x00000FFF],
                                                    innerPacketFieldsAreValid [0x01],
                                                    trillMcDescriptorInstance [0x01]
                                                   }
                                           },
                                actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                    action {
                                            type2 {
                                                                 tunnelTerminate [GT_TRUE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_MPLS_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_TRUE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_POP1_CMD_E],
                                                                         mplsTtl [max],
                                                              enableDecrementTtl [GT_TRUE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_VRF_ID_ASSIGN_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [max],
                                                                                              portNum [max]
                                                                                             },
                                                                                     trunkId [max],
                                                                                        vidx [max],
                                                                                      vlanId [max],
                                                                                      devNum [max],
                                                                                  fabricVidx [max],
                                                                                       index [max]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_TRUE],
                                                                        sourceId [max],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag0VlanId [max],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [max],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E /
                                                                                  CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_TRUE],
                                                              bindToPolicerMeter [GT_TRUE],
                                                                   bindToPolicer [GT_TRUE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_TRUE],
                                                                       trustDscp [GT_TRUE],
                                                                        trustExp [GT_TRUE],
                                                                      qosProfile [max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E],
                                                                          tag0Up [max],
                                                                          tag1Up [max],
                                                                       remapDSCP [GT_TRUE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [max],
                                                   mirrorToIngressAnalyzerEnable [GT_TRUE],
                                                    mirrorToIngressAnalyzerIndex [max],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_TRUE],
                                                             centralCounterIndex [max],
                                                                       vntl2Echo [GT_TRUE],
                                                                    bridgeBypass [GT_TRUE],
                                                               ingressPipeBypass [GT_TRUE],
                                                                      actionStop [GT_TRUE],
                                                                   hashMaskIndex [max],
                                                                     modifyMacSa [GT_TRUE],
                                                                     modifyMacDa [GT_TRUE],
                                                             ResetSrcPortGroupId [GT_TRUE],
                                                         multiPortGroupTtiEnable [GT_TRUE],
                                                     sourceEPortAssignmentEnable [GT_TRUE],
                                                                     sourceEPort [max]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = routerTtiTcamRowCount - 1;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetMaximumValuesAndTrunkCasesTrillPattern    (devNum, &pattern);
                prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                       (devNum, &action, actionType);
                action.type2.redirectCommand                    = CPSS_DXCH_TTI_VRF_ID_ASSIGN_E;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiPortGroupRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                    {
                        /* bit '0' of dsaSrcDevice is always returned as 'don't care' */
                        U32_SET_FIELD_MASKED_MAC(pattern.trill.common.dsaSrcDevice,0,1,0);
                        U32_SET_FIELD_MASKED_MAC(mask.trill.common.dsaSrcDevice,0,1,0);
                    }
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructsPortGroup(devNum, portGroupId, "pattern",
                                                &pattern.trill,
                                                &patternGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "pattern.trill != patternGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareTrillStructs(devNum, "mask", &mask.trill,
                                                &maskGet.trill);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "mask.trill != maskGet.trill: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);

                    st = prvCompareActionStructs(devNum, "action", actionType,
                                                 &action, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "action != actionGet: %d, %d, %d, %d",
                        devNum, routerTtiTcamRow, keyType, actionType);
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);
#endif


            /*
                Call with routerTtiTcamRow [0],
                                   keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                                   pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                   action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = 0;
                keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

                /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
                cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
                cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                         (&action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                            actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                                                 devNum, routerTtiTcamRow,
                                                 keyType, actionType);

                    if(GT_OK == st)
                    {
                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                     (GT_VOID*) &patternGet.udbArray,
                                                     sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another pattern.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                     (GT_VOID*) &maskGet.udbArray,
                                                     sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another mask.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        st = prvCompareActionStructs(devNum, "action", actionType,
                                                     &action, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                     "action != actionGet: %d, %d, %d, %d",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);
                    }
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                                         "cpssDxChCfgTableNumEntriesGet: %d, "\
                                         "table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                                         devNum, routerTtiTcamRowCount);



            /*
                Call with routerTtiTcamRow [max/2],
                                   keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                                   pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                   action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = (routerTtiTcamRowCount - 1) / 2;
                keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

                /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
                cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
                cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                         (&action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                            actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                                                 devNum, routerTtiTcamRow,
                                                 keyType, actionType);

                    if(GT_OK == st)
                    {
                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                     (GT_VOID*) &patternGet.udbArray,
                                                     sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another pattern.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                     (GT_VOID*) &maskGet.udbArray,
                                                     sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another mask.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        st = prvCompareActionStructs(devNum, "action", actionType,
                                                     &action, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                     "action != actionGet: %d, %d, %d, %d",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);
                    }
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                Call with routerTtiTcamRow [max],
                                   keyType [CPSS_DXCH_TTI_KEY_UDB_UDE_E],
                                   pattern { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   mask    { udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] { [0,0,0, .. , 0]},
                                   actionType [CPSS_DXCH_TTI_ACTION_TYPE2_ENT],
                                   action {
                                            type2 {
                                                                 tunnelTerminate [GT_FALSE],
                                                           ttPassengerPacketType [CPSS_DXCH_TTI_PASSENGER_IPV4V6_E],
                                                           tsPassengerPacketType [CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E],
                                                         copyTtlFromTunnelHeader [GT_FALSE],
                                                                     mplsCommand [CPSS_DXCH_TTI_MPLS_NOP_CMD_E],
                                                                         mplsTtl [0],
                                                              enableDecrementTtl [GT_FALSE],
                                                                         command [CPSS_PACKET_CMD_FORWARD_E],
                                                                 redirectCommand [CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                                                                 egressInterface {      type [CPSS_INTERFACE_PORT_E],
                                                                                     devPort {
                                                                                              devNum [0],
                                                                                              portNum [TTI_VALID_PORT_TRUNK_CNS]
                                                                                             },
                                                                                     trunkId [TTI_VALID_PORT_TRUNK_CNS],
                                                                                        vidx [0],
                                                                                      vlanId [TTI_VALID_VLAN_ID_CNS],
                                                                                      devNum [0],
                                                                                  fabricVidx [0],
                                                                                       index [0]
                                                                                 },
                                                                          arpPtr [0],
                                                                     tunnelStart [GT_TRUE],
                                                                  tunnelStartPtr [0],
                                                                    routerLttPtr [0],
                                                                           vrfId [0],
                                                               sourceIdSetEnable [GT_FALSE],
                                                                        sourceId [0],
                                                                     tag0VlanCmd [CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E],
                                                                      tag0VlanId [TTI_VALID_VLAN_ID_CNS],
                                                                     tag1VlanCmd [CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                                                                      tag1VlanId [TTI_VALID_VLAN_ID_CNS],
                                                              tag0VlanPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E],
                                                                nestedVlanEnable [GT_FALSE],
                                                              bindToPolicerMeter [GT_FALSE],
                                                                   bindToPolicer [GT_FALSE],
                                                                    policerIndex [0],
                                                                   qosPrecedence [CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                                                                 keepPreviousQoS [GT_FALSE],
                                                                         trustUp [GT_FALSE],
                                                                       trustDscp [GT_FALSE],
                                                                        trustExp [GT_FALSE],
                                                                      qosProfile [0 / max/2 /max],
                                                                    modifyTag0Up [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                                                                   tag1UpCommand [CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E],
                                                                      modifyDscp [CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                                                                          tag0Up [0],
                                                                          tag1Up [0],
                                                                       remapDSCP [GT_FALSE],
                                                         pcl0OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                       pcl0_1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                         pcl1OverrideConfigIndex [CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E],
                                                                 iPclConfigIndex [0],
                                                   mirrorToIngressAnalyzerEnable [GT_FALSE],
                                                    mirrorToIngressAnalyzerIndex [0],
                                                              userDefinedCpuCode [CPSS_NET_FIRST_USER_DEFINED_E + 1],
                                                            bindToCentralCounter [GT_FALSE ],
                                                             centralCounterIndex [0],
                                                                       vntl2Echo [GT_FALSE],
                                                                    bridgeBypass [GT_FALSE],
                                                               ingressPipeBypass [GT_FALSE],
                                                                      actionStop [GT_FALSE],
                                                                   hashMaskIndex [0],
                                                                     modifyMacSa [GT_FALSE],
                                                                     modifyMacDa [GT_FALSE],
                                                             ResetSrcPortGroupId [GT_FALSE],
                                                         multiPortGroupTtiEnable [GT_FALSE],
                                                     sourceEPortAssignmentEnable [GT_FALSE],
                                                                     sourceEPort [0]
                                                  }
                                           }.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                            = routerTtiTcamRowCount - 1;
                keyType                                     = CPSS_DXCH_TTI_RULE_UDB_30_E;

                /* udbArray[CPSS_DXCH_TTI_MAX_UDB_CNS] */
                cpssOsMemSet(&pattern.udbArray, 0x00, sizeof(pattern.udbArray));
                cpssOsMemSet(&mask.udbArray, 0x00, sizeof(mask.udbArray));

                actionType                                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                         (&action, actionType);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                            actionType);

                if(GT_OK == st)
                {
                    /*
                        1.2. Call cpssDxChTtiRuleGet.
                        Expected: GT_OK and the same pattern, mask and action.
                    */
                    st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp,
                                                     routerTtiTcamRow, keyType,
                                                     &patternGet, &maskGet,
                                                     actionType, &actionGet);
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "cpssDxChTtiPortGroupRuleGet: %d, %d, %d, %d",
                                                 devNum, routerTtiTcamRow,
                                                 keyType, actionType);

                    if(GT_OK == st)
                    {
                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &pattern.udbArray,
                                                     (GT_VOID*) &patternGet.udbArray,
                                                     sizeof(pattern.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another pattern.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        isEqual = (0 == cpssOsMemCmp((GT_VOID*) &mask.udbArray,
                                                     (GT_VOID*) &maskGet.udbArray,
                                                     sizeof(mask.udbArray))) ? GT_TRUE : GT_FALSE;
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_TRUE, isEqual,
                                                     "got another mask.udbArray",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);

                        st = prvCompareActionStructs(devNum, "action", actionType,
                                                     &action, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                     "action != actionGet: %d, %d, %d, %d",
                                                     devNum, routerTtiTcamRow,
                                                     keyType, actionType);
                    }
                }
            }

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);


/*
                1.3. Call with out of range ruleIndex and other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = routerTtiTcamRowCount;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);

            /*
                1.4. Call with out of range pattern.ipv4.common.pclId and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.pclId                       = BIT_10;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.pclId = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.pclId);

            /*
                1.5. Call with pattern.ipv4.common.srcIsTrunk [GT_FALSE]
                               out of range pattern.ipv4.common.srcPortTrunk and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.srcIsTrunk                  = GT_FALSE;
            pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.srcPortTrunk);


            /*
                1.6. Call with pattern.ipv4.common.srcIsTrunk [GT_TRUE]
                               out of range pattern.ipv4.common.srcPortTrunk) and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.srcIsTrunk                  = GT_TRUE;
            pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.srcPortTrunk);

            /*
                1.7. Call with out of range pattern.ipv4.common.vid and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                pattern.ipv4.common.vid                     = (GT_U16) UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
            }
            else
            {
                pattern.ipv4.common.vid                     = BIT_12;
            }
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.vid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.vid);

            /*
                1.8. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                               pattern.ipv4.common.dsaSrcIsTrunk [GT_FALSE]
                               out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                                (not revelant) and
                               other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.isTagged                    = GT_TRUE;
            pattern.ipv4.common.dsaSrcIsTrunk               = GT_FALSE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.ipv4.common.dsaSrcPortTrunk             = BIT_8 - 1;
            else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                pattern.ipv4.common.dsaSrcPortTrunk             = BIT_7 - 1;
            else
                pattern.ipv4.common.dsaSrcPortTrunk             = BIT_6 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.dsaSrcPortTrunk);

            /*
                1.9. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                               pattern.ipv4.common.dsaSrcIsTrunk [GT_TRUE]
                               out of range pattern.ipv4.common.dsaSrcPortTrunk
                                                            (not relevant) and
                               other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.isTagged                    = GT_TRUE;
            pattern.ipv4.common.dsaSrcIsTrunk               = GT_TRUE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.ipv4.common.dsaSrcPortTrunk             = BIT_8 - 1;
            else
                pattern.ipv4.common.dsaSrcPortTrunk             = BIT_7 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.ipv4.common.dsaSrcPortTrunk);

            /*
                1.10. Call with pattern.ipv4.common.isTagged [GT_TRUE]
                                out of range pattern.ipv4.common.dsaSrcDevice and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.ipv4.common.isTagged                    = GT_TRUE;
            pattern.ipv4.common.dsaSrcDevice                = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.ipv4.common.dsaSrcDevice  = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.ipv4.common.dsaSrcDevice);


            /*
                1.11. Call with wrong pattern.ipv4.tunneltype enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                 pattern.ipv4.tunneltype);
            /*
                1.12. Call with out of range pattern.mpls.common.pclId and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.pclId                       = BIT_10;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.pclId = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mpls.common.pclId);


            /*
                1.13. Call with pattern.mpls.common.srcIsTrunk [GT_FALSE]
                                out of range pattern.mpls.common.srcPortTrunk and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.srcIsTrunk                  = GT_FALSE;
            pattern.mpls.common.srcPortTrunk                = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;

            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mpls.common.srcPortTrunk);

            /*
                1.14. Call with pattern.mpls.common.srcIsTrunk [GT_TRUE]
                                out of range pattern.mpls.common.srcPortTrunk and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.srcIsTrunk                  = GT_TRUE;
            pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;

            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mpls.common.srcPortTrunk);

            /*
                1.15. Call with out of range pattern.mpls.common.vid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                pattern.mpls.common.vid                     = (GT_U16) UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
            }
            else
            {
                pattern.mpls.common.vid                     = BIT_12;
            }

            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.vid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mpls.common.vid);

            /*
                1.16. Call with pattern.mpls.common.isTagged [GT_TRUE]
                                pattern.mpls.common.dsaSrcIsTrunk [GT_FALSE]
                                out of range pattern.mpls.common.dsaSrcPortTrunk
                                                            (do not constraint) and
                                other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.isTagged                    = GT_TRUE;
            pattern.mpls.common.dsaSrcIsTrunk               = GT_FALSE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.mpls.common.dsaSrcPortTrunk             = BIT_8 - 1;
            else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                pattern.mpls.common.dsaSrcPortTrunk             = BIT_7 - 1;
            else
                pattern.mpls.common.dsaSrcPortTrunk             = BIT_6 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.dsaSrcPortTrunk  = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mpls.common.dsaSrcPortTrunk);

            /*
                1.17. Call with pattern.mpls.common.isTagged [GT_TRUE]
                                pattern.mpls.common.dsaSrcIsTrunk [GT_TRUE]
                                out of range pattern.mpls.common.dsaSrcPortTrunk
                                                            (do not constraint) and
                                other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.isTagged                    = GT_TRUE;
            pattern.mpls.common.dsaSrcIsTrunk               = GT_TRUE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.mpls.common.dsaSrcPortTrunk             = BIT_8 - 1;
            else
                pattern.mpls.common.dsaSrcPortTrunk             = BIT_7 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mpls.common.dsaSrcPortTrunk);

            /*
                1.18. Call with pattern.mpls.common.isTagged [GT_TRUE]
                                out of range pattern.mpls.common.dsaSrcDevice and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MPLS_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mpls.common.isTagged                    = GT_TRUE;
            pattern.mpls.common.dsaSrcDevice                = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mpls.common.dsaSrcDevice = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mpls.common.dsaSrcDevice);

            /*
                1.19. Call with out of range pattern.mim.common.pclId and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMplsPattern                        (&pattern);
            prvSetDefaultMplsMask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.pclId                        = BIT_10;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.pclId = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.common.pclId);

            /*
                1.20. Call with pattern.mim.common.srcIsTrunk [GT_FALSE]
                               out of range pattern.mim.common.srcPortTrunk and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            ( &mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.srcIsTrunk                   = GT_FALSE;
            pattern.mim.common.srcPortTrunk                 = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.common.srcPortTrunk);

            /*
                1.21. Call with pattern.mim.common.srcIsTrunk [GT_TRUE]
                               out of range pattern.mim.common.srcPortTrunk and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.srcIsTrunk                   = GT_TRUE;
            pattern.mim.common.srcPortTrunk                 = BIT_12;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.srcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.common.srcPortTrunk);

            /*
                1.22. Call with out of range pattern.mim.common.vid and
                               other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                pattern.mim.common.vid                      = (GT_U16) UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
            }
            else
            {
                pattern.mim.common.vid                      = BIT_12;
            }
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.vid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.common.vid);

            /*
                1.23. Call with pattern.mim.common.isTagged [GT_TRUE]
                                pattern.mim.common.dsaSrcIsTrunk [GT_FALSE]
                                out of range pattern.mim.common.dsaSrcPortTrunk
                                                            (do not constraint) and
                                other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.isTagged                     = GT_TRUE;
            pattern.mim.common.dsaSrcIsTrunk                = GT_FALSE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.mim.common.dsaSrcPortTrunk              = BIT_8 - 1;
            else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
                pattern.mim.common.dsaSrcPortTrunk             = BIT_7 - 1;
            else
                pattern.mim.common.dsaSrcPortTrunk              = BIT_6 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mim.common.dsaSrcPortTrunk);

            /*
                1.24. Call with pattern.mim.common.isTagged [GT_TRUE]
                                pattern.mim.common.dsaSrcIsTrunk [GT_TRUE]
                                out of range pattern.mim.common.dsaSrcPortTrunk
                                                        (do not constraint) and
                                other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.isTagged                     = GT_TRUE;
            pattern.mim.common.dsaSrcIsTrunk                = GT_TRUE;
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                pattern.mim.common.dsaSrcPortTrunk              = BIT_11 - 1;
            else
                pattern.mim.common.dsaSrcPortTrunk              = BIT_7 - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.dsaSrcPortTrunk = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mim.common.dsaSrcPortTrunk);

            /*
                1.25. Call with pattern.mim.common.isTagged [GT_TRUE]
                                out of range pattern.mim.common.dsaSrcDevice and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.common.isTagged                     = GT_TRUE;
            pattern.mim.common.dsaSrcDevice                 = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                             routerTtiTcamRow, keyType, &pattern,
                                             &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.common.dsaSrcDevice = %d", devNum,
                routerTtiTcamRow, keyType, actionType,
                pattern.mim.common.dsaSrcDevice);

            /*
                1.26. Call with out of range pattern.mim.bUp and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.bUp                                 = CPSS_USER_PRIORITY_RANGE_CNS;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.bUp = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.bUp);

            /*
                1.27. Call with out of range pattern.mim.bDp and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.bDp                                 = DP_MAX_CNS + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.bDp = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.bDp);

            /*
                1.28. Call with out of range pattern.mim.iSid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.iSid                                = MIM_ISID_MAX_CNS + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.iSid = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.iSid);

            /*
                1.29. Call with out of range pattern.mim.iUp and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.iUp                                 = CPSS_USER_PRIORITY_RANGE_CNS;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.iUp = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.iUp);

            /*
                1.30. Call with out of range pattern.mim.iDp and
                                other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
            prvSetDefaultMimPattern                         (&pattern);
            prvSetDefaultMimMask                            (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            pattern.mim.iDp                                 = DP_MAX_CNS + 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow, keyType,
                                        actionType);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                "%d, %d, %d, %d, pattern.mim.iDp = %d", devNum,
                routerTtiTcamRow, keyType, actionType, pattern.mim.iDp);

            /*
                1.31. Call with out of range pattern.mim.innerPacketTag0Vid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
                prvSetDefaultMimPattern                         (&pattern);
                prvSetDefaultMimMask                            (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.mim.passengerPacketOuterTagVid          = BIT_12;
                pattern.mim.passengerPacketOuterTagExists       = GT_TRUE;

                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagVid = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.mim.passengerPacketOuterTagVid);
            }

            /*
                1.32. Call with out of range pattern.mim.passengerPacketOuterTagUp and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
                prvSetDefaultMimPattern                         (&pattern);
                prvSetDefaultMimMask                            (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.mim.passengerPacketOuterTagUp           = CPSS_USER_PRIORITY_RANGE_CNS;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagUp = %d", devNum,
                    routerTtiTcamRow, keyType, actionType, pattern.mim.passengerPacketOuterTagUp);
            }

            /*
                1.33. Call with out of range pattern.mim.passengerPacketOuterTagDei and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_MIM_E;
                prvSetDefaultMimPattern                         (&pattern);
                prvSetDefaultMimMask                            ( &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.mim.passengerPacketOuterTagDei          = BIT_1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.mim.passengerPacketOuterTagDei = %d", devNum,
                    routerTtiTcamRow, keyType, actionType, pattern.mim.passengerPacketOuterTagDei);
            }

            /*
                1.34. Call with out of range pattern.trill.common.pclId and
                                other valid params.
                Expected: NOT GT_OK.
            */
/* TBD TRILL */
#if 0
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                        (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.pclId                       = BIT_10;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d,  pattern.trill.common.pclId = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,  pattern.trill.common.pclId);
            }

            /*
                1.35. Call with pattern.trill.common.srcIsTrunk [GT_FALSE]
                                out of range pattern.trill.common.srcPortTrunk and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                        (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.srcIsTrunk                 = GT_FALSE;
                pattern.trill.common.srcPortTrunk               = UTF_CPSS_PP_MAX_PORT_NUM_CNS(devNum) + 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.srcPortTrunk = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.srcPortTrunk);
            }

            /*
                1.36. Call with pattern.trill.common.srcIsTrunk [GT_TRUE]
                                out of range pattern.trill.common.srcPortTrunk and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.srcIsTrunk                 = GT_TRUE;
                pattern.ipv4.common.srcPortTrunk                = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) + 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.srcPortTrunk = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.srcPortTrunk);
            }

            /*
                1.37. Call with out of range pattern.trill.common.vid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.vid                        = (GT_U16) UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum);
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.vid = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.vid);
            }

            /*
                1.38. Call with pattern.trill.common.isTagged [GT_TRUE]
                                pattern.trill.common.dsaSrcIsTrunk [GT_FALSE]
                                out of range pattern.trill.common.dsaSrcPortTrunk
                                                            (do not constrant) and
                                other valid params.
                Expected: GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.isTagged                   = GT_TRUE;
                pattern.trill.common.dsaSrcIsTrunk              = GT_FALSE;
                pattern.trill.common.dsaSrcPortTrunk            = BIT_8 - 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType, &pattern,
                                                 &mask, actionType, &action);
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.dsaSrcPortTrunk = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.dsaSrcPortTrunk);
            }

            /*
                1.39. Call with pattern.trill.common.isTagged [GT_TRUE]
                                pattern.trill.common.dsaSrcIsTrunk [GT_TRUE]
                                out of range pattern.trill.common.dsaSrcPortTrunk
                                                            (do not constrant) and
                                other valid params.
                Expected: GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.isTagged                   = GT_TRUE;
                pattern.trill.common.dsaSrcIsTrunk              = GT_TRUE;
                pattern.trill.common.dsaSrcPortTrunk            = BIT_8 - 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType, &pattern,
                                                 &mask, actionType, &action);
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.dsaSrcPortTrunk = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.dsaSrcPortTrunk);
            }

            /*
                1.40. Call with pattern.trill.common.isTagged [GT_TRUE]
                                out of range pattern.trill.common.dsaSrcDevice and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.common.isTagged                   = GT_TRUE;
                pattern.trill.common.dsaSrcDevice               = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) + 1;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType, &pattern,
                                                 &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.common.dsaSrcDevice = %d", devNum,
                    routerTtiTcamRow, keyType, actionType,
                    pattern.trill.common.dsaSrcDevice);
            }

            /*
                1.41. Call with out of range pattern.trill.trillEgressRbid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.trillEgressRbid                   = BIT_16;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.trillEgressRbid = %d", devNum,
                    routerTtiTcamRow, keyType, actionType, pattern.trill.trillEgressRbid);
            }

            /*
                1.42. Call with out of range pattern.trill.trillIngressRbid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.trillIngressRbid                  = BIT_16;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.trillIngressRbid = %d", devNum,
                    routerTtiTcamRow, keyType, actionType, pattern.trill.trillIngressRbid);
            }

            /*
                1.43. Call with out of range pattern.trill.innerPacketTag0Vid and
                                other valid params.
                Expected: NOT GT_OK.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultTrillMask                          (&mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetDefaultAction                             (&action, actionType);
                pattern.trill.innerPacketTag0Vid                = BIT_12;
                pattern.trill.innerPacketTag0Exists             = GT_TRUE;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp,
                                                 routerTtiTcamRow, keyType,
                                                 &pattern, &mask, actionType,
                                                 &action);
                UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, %d, pattern.trill.innerPacketTag0Vid = %d", devNum,
                    routerTtiTcamRow, keyType, actionType, pattern.trill.innerPacketTag0Vid);
            }
#endif
            /*
                1.44. Call with wrong action.type2.ttPassengerPacketType enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            action.type2.tunnelTerminate = GT_TRUE;
            action.type2.ttPassengerPacketType = 8; /* not valid enum */
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.ttPassengerPacketType);

            /*
                1.45. Call with wrong action.type2.tsPassengerPacketType enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            action.type2.tsPassengerPacketType = 8; /* not valide enum */
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.tsPassengerPacketType);

            /*
                1.46. Call with wrong action.type2.command enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.command);

            /*
                1.47. Call with wrong action.type2.redirectCommand enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.redirectCommand);

            /*
                1.48. Call with wrong action.type2.tag0VlanCmd enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.tag0VlanCmd);

            /*
                1.49. Call with wrong action.type2.tag1VlanCmd enum values and
                               other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.tag1VlanCmd);

            /*
                1.50. Call with wrong action.type2.qosPrecedence enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.qosPrecedence);

            /*
                1.51. Call with wrong action.type2.userDefinedCpuCode enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                action.type2.qosPrecedence);

            /*
                1.52. Call with wrong keyType enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                keyType);
/* TBD TRILL */
#if 0
            /*
                1.53. Call with wrong keyType [CPSS_DXCH_TTI_KEY_TRILL_E] and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            if(
               (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
            {
                routerTtiTcamRow                                = 0;
                keyType                                         = CPSS_DXCH_TTI_KEY_TRILL_E;
                prvSetDefaultTrillPattern                       (&pattern);
                prvSetDefaultDeviceDependentTrillMask           (devNum, &mask);
                actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
                prvSetMaximumValuesAction                       (devNum, &action, actionType);
                action.type2.egressInterface.type               = CPSS_INTERFACE_INDEX_E;
                routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                        &mask, actionType, &action);
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
#endif
            /*
                1.54. Call with wrong actionType enum values and
                                other valid params.
                Expected: GT_BAD_PARAM.
            */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                 &mask, actionType, &action),
                                actionType);

            /*
                1.55. Call with NULL patternPtr and other valid params.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, NULL,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, patternPtr = NULL", devNum);

            /*
                1.56. Call with NULL maskPtr and other valid params.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    NULL, actionType, &action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskPtr = NULL", devNum);

            /*
                1.57. Call with NULL actionPtr and other valid params.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, actionPtr = NULL", devNum);

            /*  1.58.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);

            action.type2.tunnelTerminate                    = GT_TRUE;
            action.type2.ttHeaderLength                     = TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(devNum);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            action.type2.ttHeaderLength                     = TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(devNum) - 5;/* not even value ... fail */
            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }



            /*  1.59.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                    (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                     &mask, actionType, &action),
                                    action.type2.passengerParsingOfTransitMplsTunnelMode);
            }

            /*  1.60.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);
            action.type2.sourceIdSetEnable                    = GT_TRUE;

            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                action.type2.sourceId = 4096;
            }
            else
            {
                action.type2.sourceId = 32;
            }
            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);

            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                            keyType, actionType);

            /*  1.61.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);

            action.type2.qosUseUpAsIndexEnable              = GT_TRUE;
            action.type2.qosMappingTableIndex               = 12;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            /*  1.62.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
            action.type2.iPclUdbConfigTableEnable           = GT_TRUE;

            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                    (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                     &mask, actionType, &action),
                                    action.type2.iPclUdbConfigTableIndex);
            }

            /*  1.63.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);
            action.type2.sourceEPortAssignmentEnable        = GT_TRUE;
            action.type2.sourceEPort                        = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? _16K :8192;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);

            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            /*  1.64.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);
            action.type2.redirectCommand                    = CPSS_DXCH_TTI_NO_REDIRECT_E;
            action.type2.flowId                             = 65536;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            /*  1.65.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            action.type2.oamTimeStampEnable                 = GT_TRUE;
            action.type2.oamOffsetIndex                     = 128;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
              UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            /*  1.66.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            action.type2.oamProfile                         = 2;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }

            /*  1.67.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            action.type2.isPtpPacket                        = GT_TRUE;

            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleSet
                                    (devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                     &mask, actionType, &action),
                                    action.type2.ptpTriggerType);
            }

            /*  1.68.  */
            routerTtiTcamRow                                = 0;
            keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
            prvSetDefaultIpv4Pattern                        (&pattern);
            prvSetDefaultIpv4Mask                           (&mask);
            actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
            prvSetDefaultAction                             (&action, actionType);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            action.type2.isPtpPacket                        = GT_TRUE;
            action.type2.ptpOffset                          = PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) ? 64 : 128;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
            {
                UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                                keyType, actionType);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, routerTtiTcamRow,
                                              keyType, actionType);
            }
            /*
                1.69. Call with out of range actionPtr->unknownSaCommand[4096],
                actionPtr->unknownSaCommandEnable[GT_FALSE](not relevant),
                and other valid params.
                Expected: GT_OK. (For xCat and above)
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
                action.type2.unknownSaCommand       = 4096;
                action.type2.unknownSaCommandEnable = GT_FALSE;

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d", devNum);
            }
            /*
                1.70. Call with out of range actionPtr->unknownSaCommand[4096],
                actionPtr->unknownSaCommandEnable[GT_TRUE](is relevant),
                and other valid params.
                Expected: GT_BAD_PARAM. (For xCat and above)
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
            {
                action.type2.redirectCommand        = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
                action.type2.unknownSaCommandEnable = GT_TRUE;

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PARAM, st, "%d", devNum);

                /* restore values */
                action.type2.unknownSaCommandEnable = GT_FALSE;
                action.type2.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;
            }
            /*
                1.71. Call with out of range actionPtr->sourceMeshId[4],
                actionPtr->sourceMeshIdSetEnable[GT_FALSE](not relevant),
                and other valid params.
                Expected: GT_OK. (For xCat and above)
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
            {
                action.type2.redirectCommand       = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
                action.type2.sourceMeshId          = 4;
                action.type2.sourceMeshIdSetEnable = GT_FALSE;

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d", devNum);
            }
            /*
                1.72. Call with out of range actionPtr->sourceMeshId[4],
                actionPtr->sourceMeshIdSetEnable[GT_TRUE](is relevant),
                and other valid params.
                Expected: GT_BAD_PARAM. (For xCat and above)
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) == GT_TRUE)
            {
                action.type2.redirectCommand       = CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E;
                action.type2.sourceMeshIdSetEnable = GT_TRUE;

                st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PARAM, st, "%d", devNum);

                /* restore values */
                action.type2.sourceMeshIdSetEnable = GT_FALSE;
                action.type2.sourceMeshId = 1;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)

        /* Restore port group. */
        portGroupId = 1;

        routerTtiTcamRow                                = 0;
        keyType                                         = CPSS_DXCH_TTI_KEY_IPV4_E;
        prvSetDefaultIpv4Pattern                        (&pattern);
        prvSetDefaultIpv4Mask                           (&mask);
        actionType                                      = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
        prvSetDefaultAction                             (&action, actionType);
        routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_CPSS_GEN_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next non-active port group. */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, portGroupsBmp);
        }
        PRV_CPSS_GEN_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                    &mask, actionType, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp);
    }

    /* 2. For not active devices check that function returns non GT_OK. */
    portGroupsBmp               = 1;
    routerTtiTcamRow            = 0;
    keyType                     = CPSS_DXCH_TTI_KEY_IPV4_E;
    actionType                  = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E | UTF_CH3_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                                &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
        if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_SUPPORTED, st, devNum);
        }
        else
        {
            if(PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
            }
        }
    }

    /* 3. Call function with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType, &pattern,
                            &mask, CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiPortGroupRuleActionUpdate
(
    IN  GT_U8                               devNum,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  GT_U32                              routerTtiTcamRow,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    IN  CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiPortGroupRuleActionUpdate)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (APPLICABLE DEVICES: DxCh3; xCat; xCat3; Lion)
    1.1.1. Call with actionPtr{tunnelTerminate[GT_TRUE],
                   passengerPacketType[CPSS_DXCH_TTI_PASSENGER_IPV4_E],
                   copyTtlFromTunnelHeader[GT_FALSE],
                   command [CPSS_PACKET_CMD_FORWARD_E],
                   redirectCommand[CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                   egressInterface{type[CPSS_INTERFACE_TRUNK_E],
                                   trunkId[2]},

                   tunnelStart [GT_TRUE],
                   tunnelStartPtr[0],
                   targetIsTrunk[GT_FALSE],

                   sourceIdSetEnable[GT_TRUE],
                   sourceId[0],

                   vlanCmd[CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                   vlanId[100],
                   vlanPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                   nestedVlanEnable[GT_FALSE],

                   bindToPolicer[GT_FALSE],

                   qosPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                   qosTrustMode[CPSS_DXCH_TTI_QOS_UNTRUST_E],
                   qosProfile[0],
                   modifyUpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                   modifyDscpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                   up[0],

                   mirrorToIngressAnalyzerEnable[GT_FALSE],
                   vntl2Echo[GT_FALSE],
                   bridgeBypass[GT_FALSE],
                   actionStop[GT_FALSE]
              }
    Expected: GT_OK.
    1.1.2. Call cpssDxChTtiPortGroupRuleGet with non-NULL pointers,
                                                 other params same as in 1.1.1.
    Expected: GT_OK and same action as written
    1.1.3. Call with out of range routerTtiTcamRow [3k],
                     other params same as in 1.1.1.
    Expected: non GT_OK.
    1.1.4. Call with wrong enum values actionType,
                     other params same as in 1.1.1.
    Expected: GT_BAD_PARAM.
    1.1.5. Call with actionPtr [NULL],
                     other params same as in 1.1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   devNum;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    GT_U32                  portGroupId   = 0;

    GT_U32                          tcamRow    = 0;
    CPSS_DXCH_TTI_KEY_TYPE_ENT      keyType    = CPSS_DXCH_TTI_KEY_IPV4_E;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT   actionType = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
    CPSS_DXCH_TTI_RULE_UNT          pattern;
    CPSS_DXCH_TTI_RULE_UNT          mask;
    CPSS_DXCH_TTI_ACTION_UNT        action;
    CPSS_DXCH_TTI_ACTION_UNT        actionGet;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));
    cpssOsBzero((GT_VOID*) &actionGet, sizeof(actionGet));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;

        /* 1.1. Go over all active port groups. */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* set next active port */
            portGroupsBmp = (1 << portGroupId);

            /* only port groups (0,4) supported */
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                portGroupsBmp = 0xFF;

            /*
                Create default rule
            */
            tcamRow = 0;
            keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

            prvSetDefaultIpv4Pattern(&pattern);
            prvSetDefaultAction(&action, actionType);
            prvSetDefaultIpv4Mask(&mask);
            tcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,tcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, tcamRow, keyType,
                                             &pattern, &mask, actionType, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiPortGroupRuleSet: %d, %d, %d",
                                         devNum, tcamRow, keyType);
            /*
                1.1.1. Call with actionPtr{tunnelTerminate[GT_TRUE],
                               passengerPacketType[CPSS_DXCH_TTI_PASSENGER_IPV4_E],
                               copyTtlFromTunnelHeader[GT_FALSE],
                               command [CPSS_PACKET_CMD_FORWARD_E],
                               redirectCommand[CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E],
                               egressInterface{type[CPSS_INTERFACE_TRUNK_E],
                                               trunkId[2]},

                               tunnelStart [GT_TRUE],
                               tunnelStartPtr[0],
                               targetIsTrunk[GT_FALSE],

                               sourceIdSetEnable[GT_TRUE],
                               sourceId[0],

                               vlanCmd[CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E],
                               vlanId[100],
                               vlanPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                               nestedVlanEnable[GT_FALSE],

                               bindToPolicer[GT_FALSE],

                               qosPrecedence[CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E],
                               qosTrustMode[CPSS_DXCH_TTI_QOS_UNTRUST_E],
                               qosProfile[0],
                               modifyUpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E],
                               modifyDscpEnable[CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E],
                               up[0],

                               mirrorToIngressAnalyzerEnable[GT_FALSE],
                               vntl2Echo[GT_FALSE],
                               bridgeBypass[GT_FALSE],
                               actionStop[GT_FALSE]
                          }
                Expected: GT_OK.
            */
            tcamRow = 0;

            prvSetDefaultAction(&action, actionType);
            tcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,tcamRow);

            st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                      actionType, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, tcamRow);

            /*
                1.1.2. Call cpssDxChTtiPortGroupRuleGet with non-NULL pointers,
                                                             other params same as in 1.1.
                Expected: GT_OK and same action as written
            */
            st = cpssDxChTtiPortGroupRuleGet(devNum, portGroupsBmp, tcamRow, keyType,
                                             &pattern, &mask, actionType, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiPortGroupRuleGet: %d, %d, %d",
                                         devNum, keyType, tcamRow);
            /* validation values */
            st = prvCompareActionStructs(devNum, "action", actionType, &action,
                                         &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "action != actionGet: %d, %d, %d, %d",
                devNum, tcamRow, keyType, actionType);

           /*
                1.3. Call with out of range routerTtiTcamRow [maxRuleIndex],
                               other params same as in 1.1.
                Expected: non GT_OK.
            */
            tcamRow = prvGetMaxRuleIndex(devNum);
            tcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,tcamRow);

            st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                      actionType, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, tcamRow);

            tcamRow = 0;
            tcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,tcamRow);

           /*
                1.4. Call with wrong enum values actionType, other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChTtiPortGroupRuleActionUpdate
                                (devNum, portGroupsBmp, tcamRow, actionType, &action),
                                actionType);

            /*
                1.5. Call with actionPtr [NULL], other params same as in 1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                      actionType, NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, "%d, actionPtr = NULL", devNum);
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_CPSS_GEN_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* set next non-active port */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                      actionType, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, portGroupsBmp);
        }
        PRV_CPSS_GEN_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                  actionType, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp);
    }

    portGroupsBmp = 1;

    tcamRow = 0;
    prvSetDefaultAction(&action, actionType);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                                  actionType, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiPortGroupRuleActionUpdate(devNum, portGroupsBmp, tcamRow,
                                              actionType, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiPortGroupRuleValidStatusSet
(
    IN  GT_U8                               devNum,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  GT_U32                              routerTtiTcamRow,
    IN  GT_BOOL                             valid
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiPortGroupRuleValidStatusSet)
{
/*
    ITERATE_DEVICES (DxCh3, xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / max/2 / max]
                              valid [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChTtiPortGroupRuleValidStatusGet.
    Expected: GT_OK and the same valid.
    1.3. Call with out of range routerTtiTcamRow and other valid params.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st = GT_OK;

    GT_U8                   devNum;
    GT_PORT_GROUPS_BMP                      portGroupsBmp;
    GT_U32                                  portGroupId;
    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    GT_BOOL                                 valid;
    GT_BOOL                                 validGet;
    CPSS_DXCH_TTI_KEY_TYPE_ENT      keyType    = CPSS_DXCH_TTI_KEY_IPV4_E;
    CPSS_DXCH_TTI_ACTION_TYPE_ENT   actionType = CPSS_DXCH_TTI_ACTION_TYPE2_ENT;
    CPSS_DXCH_TTI_RULE_UNT          pattern;
    CPSS_DXCH_TTI_RULE_UNT          mask;
    CPSS_DXCH_TTI_ACTION_UNT        action;
    CPSS_DXCH_TTI_ACTION_UNT        actionGet;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));
    cpssOsBzero((GT_VOID*) &actionGet, sizeof(actionGet));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /* Initialize port group. */
        portGroupId = 1;

        /* 1.1. Go over all active port groups. */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next active port group. */
            portGroupsBmp = (1 << portGroupId);

            /* only port groups (0,4) supported */
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                portGroupsBmp = 0xFF;

            /*
                1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max]
                                          valid [GT_FALSE / GT_TRUE].
                    Expected: GT_OK.
                */
            routerTtiTcamRow    = 0;

            keyType   = CPSS_DXCH_TTI_KEY_IPV4_E;

            prvSetDefaultIpv4Pattern(&pattern);
            prvSetDefaultAction(&action, actionType);
            prvSetDefaultIpv4Mask(&mask);
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType,
                                             &pattern, &mask, actionType, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiPortGroupRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

            valid   = GT_FALSE;

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, valid);

            /*
                1.2. Call cpssDxChTtiPortGroupRuleValidStatusGet.
                Expected: GT_OK and the same valid.
            */
            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &validGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiPortGroupRuleValidStatusGet: %d, %d, %d, %d", devNum,
                portGroupsBmp, routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_STRING_MAC(valid, validGet,
                "get another valid than was set: %d, %d, %d, %d", devNum, portGroupsBmp,
                routerTtiTcamRow, valid);

            /* Call with routerTtiTcamRow [1] and valid [GT_FALSE]. */
            routerTtiTcamRow    = 1;
            valid               = GT_TRUE;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType,
                                             &pattern, &mask, actionType, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiPortGroupRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, valid);

            /*
                1.2. Call cpssDxChTtiPortGroupRuleValidStatusGet.
                Expected: GT_OK and the same valid.
            */
            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &validGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiPortGroupRuleValidStatusGet: %d, %d, %d, %d", devNum,
                portGroupsBmp, routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_STRING_MAC(valid, validGet,
                "get another valid than was set: %d, %d, %d, %d", devNum, portGroupsBmp,
                routerTtiTcamRow, valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, portGroupsBmp);

            /* Call with routerTtiTcamRow [max/2] and valid [GT_FALSE]. */
            routerTtiTcamRow    = (routerTtiTcamRowCount - 1) / 2;
            valid   = GT_FALSE;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, valid);

             /*
                1.2. Call cpssDxChTtiPortGroupRuleValidStatusGet.
                Expected: GT_OK and the same valid.
            */
            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &validGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiPortGroupRuleValidStatusGet: %d, %d, %d, %d", devNum,
                portGroupsBmp, routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_STRING_MAC(valid, validGet,
                "get another valid than was set: %d, %d, %d, %d", devNum, portGroupsBmp,
                routerTtiTcamRow, valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /* Call with routerTtiTcamRow [max] and valid [GT_TRUE].    */
            routerTtiTcamRow    = routerTtiTcamRowCount - 1;
            valid               = GT_TRUE;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleSet(devNum, portGroupsBmp, routerTtiTcamRow, keyType,
                                             &pattern, &mask, actionType, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiPortGroupRuleSet: %d, %d, %d",
                                         devNum, routerTtiTcamRow, keyType);

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, valid);

           /*
                1.2. Call cpssDxChTtiPortGroupRuleValidStatusGet.
                Expected: GT_OK and the same valid.
            */
            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &validGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "cpssDxChTtiPortGroupRuleValidStatusGet: %d, %d, %d, %d", devNum,
                portGroupsBmp, routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_STRING_MAC(valid, validGet,
                "get another valid than was set: %d, %d, %d, %d", devNum, portGroupsBmp,
                routerTtiTcamRow, valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                1.3. Call with out of range routerTtiTcamRow and other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow    = routerTtiTcamRowCount;
            valid               = GT_FALSE;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                            routerTtiTcamRow, valid);
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)

        /* Restore port group. */
        portGroupId         = 1;

        routerTtiTcamRow    = 0;
        valid               = GT_TRUE;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_CPSS_GEN_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next non-active port group. */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, devNum, portGroupsBmp,
                                            routerTtiTcamRow, valid);
        }
        PRV_CPSS_GEN_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                    routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                    routerTtiTcamRow, &valid);
    }

    /* 2. For not active devices check that function returns non GT_OK. */
    portGroupsBmp = 1;
    routerTtiTcamRow    = 0;
    valid               = GT_TRUE;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                    routerTtiTcamRow, valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiPortGroupRuleValidStatusSet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiPortGroupRuleValidStatusGet
(
    IN  GT_U8                               devNum,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  GT_U32                              routerTtiTcamRow,
    OUT GT_BOOL                             *validPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiPortGroupRuleValidStatusGet)
{
/*
    ITERATE_DEVICES (DxCh3, xCat, Lion, xCat2, Lion2)
    1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max] and other valid params.
    Expected: GT_OK.
    1.2 Call with out of range routerTtiTcamRow and other valid params.
    Expected: NOT GT_OK.
    1.3. Call with NULL validPtr.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st = GT_OK;

    GT_U8                   devNum;
    GT_PORT_GROUPS_BMP                      portGroupsBmp;
    GT_U32                                  portGroupId;
    GT_U32                                  routerTtiTcamRow;
    GT_U32                                  routerTtiTcamRowCount;
    GT_BOOL                                 valid;

    appDemoDxChNewTtiTcamSupportSet(GT_FALSE);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ttiGlobal_devNum = devNum;
        /* Restore port group. */
        portGroupId = 1;

        /* 1.1. Go over all active port groups. */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next non-active port group. */
            portGroupsBmp = (1 << portGroupId);

            /* only port groups (0,4) supported */
            if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                portGroupsBmp = 0xFF;

            /*
                1.1. Call with routerTtiTcamRow [0 / 1 / max/2 / max] and
                               other valid params.
                Expected: GT_OK.
            */
            routerTtiTcamRow    = 0;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, &valid);

            /* Call with routerTtiTcamRow [1].  */
            routerTtiTcamRow    = 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, &valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /* Call with routerTtiTcamRow [max/2].  */
            routerTtiTcamRow    = (routerTtiTcamRowCount - 1) / 2;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, &valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /* Call with routerTtiTcamRow [max].    */
            routerTtiTcamRow    = routerTtiTcamRowCount - 1;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                        routerTtiTcamRow, &valid);

            /* Call cpssDxChCfgTableNumEntriesGet. */
            st = cpssDxChCfgTableNumEntriesGet(devNum, CPSS_DXCH_CFG_TABLE_TTI_TCAM_E,
                                               &routerTtiTcamRowCount);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChCfgTableNumEntriesGet: %d, table = CPSS_DXCH_CFG_TABLE_TTI_TCAM_E, %d",
                devNum, routerTtiTcamRowCount);

            /*
                1.2 Call with out of range routerTtiTcamRow and other valid params.
                Expected: NOT GT_OK.
            */
            routerTtiTcamRow    = routerTtiTcamRowCount;
            routerTtiTcamRow = appDemoDxChTcamTtiConvertedIndexGet(devNum,routerTtiTcamRow);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                            routerTtiTcamRow, &valid);

            /*
                1.3. Call with NULL validPtr.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, NULL);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st,
                "%d, %d, %d, validPtr = NULL", devNum, portGroupsBmp, routerTtiTcamRow);
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)

        /* Restore port group. */
        portGroupId         = 1;

        routerTtiTcamRow    = 0;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_CPSS_GEN_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            /* Set next non-active port group. */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                        routerTtiTcamRow, &valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, devNum, portGroupsBmp,
                                            routerTtiTcamRow, &valid);
        }
        PRV_CPSS_GEN_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(devNum, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                    routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, devNum, portGroupsBmp,
                                    routerTtiTcamRow, &valid);
    }

    /* 2. For not active devices check that function returns non GT_OK.*/
    portGroupsBmp = 1;
    routerTtiTcamRow    = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                              UTF_CH2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                    routerTtiTcamRow, &valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call with out of bound value for device id */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChTtiPortGroupRuleValidStatusGet(devNum, portGroupsBmp,
                                                routerTtiTcamRow, &valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChTtiRuleGet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              index,
    IN  CPSS_DXCH_TTI_RULE_TYPE_ENT         ruleType,
    OUT CPSS_DXCH_TTI_RULE_UNT              *patternPtr,
    OUT CPSS_DXCH_TTI_RULE_UNT              *maskPtr,
    IN  CPSS_DXCH_TTI_ACTION_TYPE_ENT       actionType,
    OUT CPSS_DXCH_TTI_ACTION_UNT            *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChTtiRuleGet_incompatibleTTIRule)
{
/*
    The test configures a TCAM entry of different sizes and tries to get a TTI entry
    with incompatible size at the same index.
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           devNum;
    GT_U32                          ruleIndex = 0;
    GT_BOOL                         valid = GT_TRUE;
    CPSS_DXCH_TCAM_RULE_SIZE_ENT    tcamRuleSize;
    static GT_U32                   tcamPattern[TCAM_MAX_RULE_SIZE_CNS] = {0};
    static GT_U32                   tcamMask[TCAM_MAX_RULE_SIZE_CNS] = {0};
    CPSS_DXCH_TTI_RULE_TYPE_ENT     ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
    static CPSS_DXCH_TTI_RULE_UNT   ttiPattern;
    static CPSS_DXCH_TTI_RULE_UNT   ttiMask;
    static CPSS_DXCH_TTI_ACTION_UNT ttiAction;

    appDemoDxChNewTtiTcamSupportSet(GT_TRUE);

    cpssOsBzero((GT_VOID*) &ttiPattern, sizeof(ttiPattern));
    cpssOsBzero((GT_VOID*) &ttiMask, sizeof(ttiMask));
    cpssOsBzero((GT_VOID*) &ttiAction, sizeof(ttiAction));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E |
                                              UTF_XCAT_E | UTF_XCAT3_E | UTF_LION_E | UTF_XCAT2_E |
                                              UTF_LION2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        ruleIndex = 0;
        ruleIndex = appDemoDxChTcamTtiConvertedIndexGet(devNum,ruleIndex);

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_10_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_MIM_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_10_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_20_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_30_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_20_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_MIM_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_10_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_20_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_30_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_30_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_MIM_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_10_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_20_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        ttiRuleType = CPSS_DXCH_TTI_RULE_UDB_30_E;
        st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                     devNum, ruleIndex, ttiRuleType);

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_40_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_UDB_30_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_50_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_UDB_30_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_60_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_UDB_30_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }

        /* Write a valid rule to the TCAM */
        tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_80_B_E;
        st = cpssDxChTcamPortGroupRuleWrite(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, ruleIndex, valid,
                                            tcamRuleSize, tcamPattern, tcamMask);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChTcamPortGroupRuleWrite: %d, %d, %d, %d",
                                         devNum, ruleIndex, valid, tcamRuleSize);

        ttiGlobal_devNum = devNum;
        prvSetDefaultIpv4Pattern(&ttiPattern);
        prvSetDefaultAction(&ttiAction,CPSS_DXCH_TTI_ACTION_TYPE2_ENT);
        prvSetDefaultIpv4Mask(&ttiMask);

        for (ttiRuleType = CPSS_DXCH_TTI_RULE_IPV4_E;
             ttiRuleType <= CPSS_DXCH_TTI_RULE_UDB_30_E;
             ttiRuleType++)
        {
            st = cpssDxChTtiRuleGet(devNum, ruleIndex, ttiRuleType, &ttiPattern, &ttiMask,
                                    CPSS_DXCH_TTI_ACTION_TYPE2_ENT, &ttiAction);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_STATE, st, "cpssDxChTtiRuleGet: %d, %d, %d",
                                         devNum, ruleIndex, ttiRuleType);
        }
    }
}

/*----------------------------------------------------------------------------*/
/*
 * Configuration of cpssDxChTti suit
 */
UTF_SUIT_BEGIN_TESTS_MAC(cpssDxChTtiRule)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleSet_type2)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleGet_type2)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleActionUpdate_type2)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleValidStatusSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleValidStatusGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiPortGroupRuleSet_type2)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiPortGroupRuleActionUpdate)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiPortGroupRuleValidStatusSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiPortGroupRuleValidStatusGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChTtiRuleGet_incompatibleTTIRule)
UTF_SUIT_END_TESTS_MAC(cpssDxChTtiRule)


/**
* @internal prvGetMaxRuleIndex function
* @endinternal
*
* @brief   This routine returns maximum value of rule index.
*
* @param[in] devNum                   - device id
*/
static GT_U32 prvGetMaxRuleIndex(IN  GT_U8  devNum)
{
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr;

    fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;
    return fineTuningPtr->tableSize.tunnelTerm;
}

/**
* @internal prvSetDefaultCommonPattern function
* @endinternal
*
* @brief   This routine set default Common pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultCommonPattern
(
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
)
{
    patternPtr->pclId               = 0;
    patternPtr->srcIsTrunk          = GT_FALSE;
    patternPtr->srcPortTrunk        = 0;
    patternPtr->mac.arEther[0]      = 0xAA;
    patternPtr->mac.arEther[1]      = 0xAA;
    patternPtr->mac.arEther[2]      = 0xAA;
    patternPtr->mac.arEther[3]      = 0xAA;
    patternPtr->mac.arEther[4]      = 0xAA;
    patternPtr->mac.arEther[5]      = 0xAA;
    patternPtr->vid                 = 0;
    patternPtr->isTagged            = GT_FALSE;
    patternPtr->dsaSrcIsTrunk       = GT_FALSE;
    patternPtr->dsaSrcPortTrunk     = 0;
    patternPtr->dsaSrcDevice        = 0;
    patternPtr->sourcePortGroupId   = 0;
}

/**
* @internal prvSetRandomValuesCommonPattern function
* @endinternal
*
* @brief   This routine set Common pattern with randim field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
)
{
    patternPtr->pclId               = BIT_5 - 1;
    patternPtr->srcIsTrunk          = GT_FALSE;
    patternPtr->srcPortTrunk        = BIT_5;
    patternPtr->mac.arEther[0]      = 0xAA;
    patternPtr->mac.arEther[1]      = 0xAA;
    patternPtr->mac.arEther[2]      = 0xAA;
    patternPtr->mac.arEther[3]      = 0xAA;
    patternPtr->mac.arEther[4]      = 0xAA;
    patternPtr->mac.arEther[5]      = 0xAA;
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->vid             = (GT_U16) ((UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum) - 1) / 2);
    }
    else
    {
        patternPtr->vid             = BIT_6 - 1;
    }
    patternPtr->isTagged            = GT_TRUE;
    patternPtr->dsaSrcIsTrunk       = GT_TRUE;
    patternPtr->dsaSrcPortTrunk     = BIT_3 - 1;
    patternPtr->dsaSrcDevice        = (GT_U8) (PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum) / 2);
    patternPtr->sourcePortGroupId   = 2;
}

/**
* @internal prvSetMaximumValuesAndPortCasesCommonPattern function
* @endinternal
*
* @brief   This routine set Common pattern with maximum field values and port cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
)
{
    patternPtr->pclId               = BIT_10 - 1;
    patternPtr->srcIsTrunk          = GT_FALSE;

    if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            patternPtr->srcPortTrunk        = BIT_8 - 1;
        }
        else
        {
            if (PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PORT_GROUP_ID_MAC(devNum) > 3)
            {
                patternPtr->srcPortTrunk        = 0x7B;
            }
            else
            {
                patternPtr->srcPortTrunk        = 0x3B;
            }
        }
    }
    else
    {
        patternPtr->srcPortTrunk        = BIT_6 - 1;
    }

    patternPtr->mac.arEther[0]      = 0xAA;
    patternPtr->mac.arEther[1]      = 0xAA;
    patternPtr->mac.arEther[2]      = 0xAA;
    patternPtr->mac.arEther[3]      = 0xAA;
    patternPtr->mac.arEther[4]      = 0xAA;
    patternPtr->mac.arEther[5]      = 0xAA;
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->vid             = (GT_U16) (UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum) - 1);
    }
    else
    {
        patternPtr->vid             = BIT_12 - 1;
    }
    patternPtr->isTagged            = GT_TRUE;
    patternPtr->dsaSrcIsTrunk       = GT_FALSE;
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->dsaSrcPortTrunk     = BIT_7 - 1;
    }
    else if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
    {
        patternPtr->dsaSrcPortTrunk     = BIT_7 - 1;
    }
    else
    {
        patternPtr->dsaSrcPortTrunk     = BIT_6 - 1;
    }

    patternPtr->dsaSrcDevice        = (GT_U8) PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum);
    patternPtr->sourcePortGroupId   = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PORT_GROUP_ID_MAC(devNum);
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesCommonPattern function
* @endinternal
*
* @brief   This routine set Common pattern with maximum field values and trunk cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesCommonPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *patternPtr
)
{
    patternPtr->pclId               = BIT_10 - 1;
    patternPtr->srcIsTrunk          = GT_TRUE;

    /* after tti fix support for port
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->srcPortTrunk        = BIT_11 - 1;
    }
    else
    {
        patternPtr->srcPortTrunk        = BIT_7 - 1;
    }*/

    patternPtr->srcPortTrunk        = BIT_7 - 1;

    patternPtr->mac.arEther[0]      = 0xAA;
    patternPtr->mac.arEther[1]      = 0xAA;
    patternPtr->mac.arEther[2]      = 0xAA;
    patternPtr->mac.arEther[3]      = 0xAA;
    patternPtr->mac.arEther[4]      = 0xAA;
    patternPtr->mac.arEther[5]      = 0xAA;
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->vid             = (GT_U16) (UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum) - 1);
    }
    else
    {
        patternPtr->vid             = BIT_12 - 1;
    }
    patternPtr->isTagged            = GT_TRUE;
    patternPtr->dsaSrcIsTrunk       = GT_TRUE;

    /*if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->dsaSrcPortTrunk     = BIT_11 - 1;
    }
    else
    {
        patternPtr->dsaSrcPortTrunk     = BIT_7 - 1;
    }*/

    patternPtr->dsaSrcPortTrunk     = BIT_7 - 1;

    patternPtr->dsaSrcDevice        = (GT_U8) PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum);
    patternPtr->sourcePortGroupId   = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PORT_GROUP_ID_MAC(devNum);
}

/**
* @internal prvSetDefaultIpv4Pattern function
* @endinternal
*
* @brief   This routine set default Ipv4 pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultIpv4Pattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetDefaultCommonPattern(&patternPtr->ipv4.common);

    patternPtr->ipv4.tunneltype     = 0;

    patternPtr->ipv4.srcIp.arIP[0]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[1]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[2]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[3]  = 0xAA;

    patternPtr->ipv4.destIp.arIP[0] = 0xAA;
    patternPtr->ipv4.destIp.arIP[1] = 0xAA;
    patternPtr->ipv4.destIp.arIP[2] = 0xAA;
    patternPtr->ipv4.destIp.arIP[3] = 0xAA;

    patternPtr->ipv4.isArp          = GT_FALSE;
}

/**
* @internal prvSetRandomValuesIpv4Pattern function
* @endinternal
*
* @brief   This routine set Ipv4 pattern with random field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetRandomValuesCommonPattern(devNum, &patternPtr->ipv4.common);

    patternPtr->ipv4.tunneltype     = 3;

    patternPtr->ipv4.srcIp.arIP[0]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[1]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[2]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[3]  = 0xAA;

    patternPtr->ipv4.destIp.arIP[0] = 0xAA;
    patternPtr->ipv4.destIp.arIP[1] = 0xAA;
    patternPtr->ipv4.destIp.arIP[2] = 0xAA;
    patternPtr->ipv4.destIp.arIP[3] = 0xAA;

    patternPtr->ipv4.isArp          = GT_FALSE;
}

/**
* @internal prvSetMaximumValuesAndPortCasesIpv4Pattern function
* @endinternal
*
* @brief   This routine set Ipv4 pattern with maximum field values and port cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndPortCasesCommonPattern(devNum, &patternPtr->ipv4.common);

    patternPtr->ipv4.tunneltype     = IPV4_TUNNEL_TYPE_MAX_CNS;

    patternPtr->ipv4.srcIp.arIP[0]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[1]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[2]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[3]  = 0xAA;

    patternPtr->ipv4.destIp.arIP[0] = 0xAA;
    patternPtr->ipv4.destIp.arIP[1] = 0xAA;
    patternPtr->ipv4.destIp.arIP[2] = 0xAA;
    patternPtr->ipv4.destIp.arIP[3] = 0xAA;

    patternPtr->ipv4.isArp          = GT_TRUE;
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesIpv4Pattern function
* @endinternal
*
* @brief   This routine set Ipv4 pattern with maximum field values and trunk cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesIpv4Pattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndTrunkCasesCommonPattern(devNum, &patternPtr->ipv4.common);

    patternPtr->ipv4.tunneltype     = IPV4_TUNNEL_TYPE_MAX_CNS;

    patternPtr->ipv4.srcIp.arIP[0]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[1]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[2]  = 0xAA;
    patternPtr->ipv4.srcIp.arIP[3]  = 0xAA;

    patternPtr->ipv4.destIp.arIP[0] = 0xAA;
    patternPtr->ipv4.destIp.arIP[1] = 0xAA;
    patternPtr->ipv4.destIp.arIP[2] = 0xAA;
    patternPtr->ipv4.destIp.arIP[3] = 0xAA;

    patternPtr->ipv4.isArp          = GT_TRUE;
}

/**
* @internal prvSetDefaultMplsPattern function
* @endinternal
*
* @brief   This routine set default Mpls pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultMplsPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetDefaultCommonPattern(&patternPtr->mpls.common);

    patternPtr->mpls.label0             = 0;
    patternPtr->mpls.exp0               = 0;
    patternPtr->mpls.label1             = 0;
    patternPtr->mpls.exp1               = 0;
    patternPtr->mpls.label2             = 0;
    patternPtr->mpls.exp2               = 0;
    patternPtr->mpls.numOfLabels        = 0;
    patternPtr->mpls.protocolAboveMPLS  = 0;
    patternPtr->mpls.reservedLabelExist = GT_FALSE;
    patternPtr->mpls.reservedLabelValue = 0;
    patternPtr->mpls.channelTypeProfile = 0;
    patternPtr->mpls.cwFirstNibble      = 0;
}

/**
* @internal prvSetRandomValuesMplsPattern function
* @endinternal
*
* @brief   This routine set Mpls pattern with random field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetRandomValuesCommonPattern(devNum, &patternPtr->mpls.common);

    patternPtr->mpls.label0             = MPLS_LABEL_MAX_CNS / 2;
    patternPtr->mpls.exp0               = (CPSS_EXP_RANGE_CNS - 1) / 2;
    patternPtr->mpls.label1             = MPLS_LABEL_MAX_CNS / 2;
    patternPtr->mpls.exp1               = (CPSS_EXP_RANGE_CNS - 1) / 2;
    patternPtr->mpls.label2             = MPLS_LABEL_MAX_CNS / 2;
    patternPtr->mpls.exp2               = (CPSS_EXP_RANGE_CNS - 1) / 2;
    patternPtr->mpls.numOfLabels        = MPLS_LABELS_MAX_CNS / 2;
    patternPtr->mpls.protocolAboveMPLS  = MPLS_PROTOCOL_ABOVE_MAX_CNS / 2;
    patternPtr->mpls.reservedLabelExist = GT_TRUE;
    patternPtr->mpls.reservedLabelValue = BIT_3 - 1;
    patternPtr->mpls.channelTypeProfile = BIT_2 - 1;
    patternPtr->mpls.cwFirstNibble      = BIT_3 - 1;
}

/**
* @internal prvSetMaximumValuesAndPortCasesMplsPattern function
* @endinternal
*
* @brief   This routine set Mpls pattern with maximum fields values and port cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndPortCasesCommonPattern(devNum, &patternPtr->mpls.common);

    patternPtr->mpls.label0             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp0               = CPSS_EXP_RANGE_CNS - 1;
    patternPtr->mpls.label1             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp1               = CPSS_EXP_RANGE_CNS - 1;
    patternPtr->mpls.label2             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp2               = CPSS_EXP_RANGE_CNS - 1;
    if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        patternPtr->mpls.numOfLabels        = MPLS_LABELS_MAX_CNS-1;
    }
    else
    {
        patternPtr->mpls.numOfLabels        = MPLS_LABELS_MAX_CNS;
    }
    patternPtr->mpls.protocolAboveMPLS  = MPLS_PROTOCOL_ABOVE_MAX_CNS;
    patternPtr->mpls.reservedLabelExist = GT_TRUE;
    patternPtr->mpls.reservedLabelValue = BIT_4 - 1;
    patternPtr->mpls.channelTypeProfile = BIT_3 - 1;
    patternPtr->mpls.cwFirstNibble      = BIT_4 - 1;
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesMplsPattern function
* @endinternal
*
* @brief   This routine set Mpls pattern with maximum fields values and trunk cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesMplsPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndTrunkCasesCommonPattern(devNum, &patternPtr->mpls.common);

    patternPtr->mpls.label0             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp0               = CPSS_EXP_RANGE_CNS - 1;
    patternPtr->mpls.label1             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp1               = CPSS_EXP_RANGE_CNS - 1;
    patternPtr->mpls.label2             = MPLS_LABEL_MAX_CNS;
    patternPtr->mpls.exp2               = CPSS_EXP_RANGE_CNS - 1;
    if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        patternPtr->mpls.numOfLabels        = MPLS_LABELS_MAX_CNS-1;
    }
    else
    {
        patternPtr->mpls.numOfLabels        = MPLS_LABELS_MAX_CNS;
    }
    patternPtr->mpls.protocolAboveMPLS  = MPLS_PROTOCOL_ABOVE_MAX_CNS;
    patternPtr->mpls.reservedLabelExist = GT_TRUE;
    patternPtr->mpls.reservedLabelValue = BIT_4 - 1;
    patternPtr->mpls.channelTypeProfile = BIT_3 - 1;
    patternPtr->mpls.cwFirstNibble = BIT_4 - 1;
}

/**
* @internal prvSetDefaultEthPattern function
* @endinternal
*
* @brief   This routine set default Ethernet pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultEthPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT            *patternPtr
)
{
    prvSetDefaultCommonPattern(&patternPtr->eth.common);

    patternPtr->eth.up0             = 0;
    patternPtr->eth.cfi0            = 0;
    patternPtr->eth.isVlan1Exists   = GT_FALSE;
    patternPtr->eth.vid1            = 0;
    patternPtr->eth.up1             = 0;
    patternPtr->eth.cfi1            = 0;
    patternPtr->eth.etherType       = 0;
    patternPtr->eth.macToMe         = GT_FALSE;
    patternPtr->eth.srcId           = 0;
    patternPtr->eth.dsaQosProfile   = 0;
    patternPtr->eth.tag0TpidIndex   = 0;
    patternPtr->eth.tag1TpidIndex   = 0;
    patternPtr->eth.eTagGrp         = 0;
}

/**
* @internal prvSetRandomValuesEthPattern function
* @endinternal
*
* @brief   This routine set Ethernet pattern with random field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetRandomValuesCommonPattern(devNum, &patternPtr->eth.common);

    patternPtr->eth.up0             = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
    patternPtr->eth.cfi0            = ETH_CFI_MAX_CNS / 2;
    patternPtr->eth.isVlan1Exists   = GT_FALSE;
    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
    {
        patternPtr->eth.vid1        = (GT_U16) ((UTF_CPSS_PP_MAX_VLAN_NUM_CNS(devNum) - 1) / 2);
    }
    else
    {
        patternPtr->eth.vid1        = BIT_6 - 1;
    }
    patternPtr->eth.up1             = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
    patternPtr->eth.cfi1            = ETH_CFI_MAX_CNS / 2;
    patternPtr->eth.etherType       = BIT_8 - 1;
    patternPtr->eth.macToMe         = GT_TRUE;
    patternPtr->eth.srcId           = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum) / 2;
    patternPtr->eth.dsaQosProfile   = QOS_PROFILE_MAX_CNS / 2;
    patternPtr->eth.tag0TpidIndex   = BIT_2 - 1;
    patternPtr->eth.tag1TpidIndex   = BIT_2 - 1;
    patternPtr->eth.eTagGrp         = BIT_1;
}

/**
* @internal prvSetMaximumValuesAndPortCasesEthPattern function
* @endinternal
*
* @brief   This routine set Ethernet pattern with maximum field values and port
*         cases of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndPortCasesCommonPattern(devNum, &patternPtr->eth.common);

    patternPtr->eth.up0             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->eth.cfi0            = ETH_CFI_MAX_CNS;
    patternPtr->eth.isVlan1Exists   = GT_TRUE;
    patternPtr->eth.vid1            = BIT_12 - 1;
    patternPtr->eth.up1             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->eth.cfi1            = ETH_CFI_MAX_CNS;
    patternPtr->eth.etherType       = BIT_16 - 1;
    patternPtr->eth.macToMe         = GT_TRUE;
    patternPtr->eth.srcId           = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum);
    patternPtr->eth.dsaQosProfile   = QOS_PROFILE_MAX_CNS;
    patternPtr->eth.tag0TpidIndex   = BIT_3 - 1;
    patternPtr->eth.tag1TpidIndex   = BIT_3 - 1;
    patternPtr->eth.eTagGrp         = BIT_2 - 1;
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesEthPattern function
* @endinternal
*
* @brief   This routine set Ethernet pattern with maximum field values and trunk
*         cases of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesEthPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndTrunkCasesCommonPattern(devNum, &patternPtr->eth.common);

    patternPtr->eth.up0             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->eth.cfi0            = ETH_CFI_MAX_CNS;
    patternPtr->eth.isVlan1Exists   = GT_TRUE;
    patternPtr->eth.vid1            = BIT_12 - 1;
    patternPtr->eth.up1             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->eth.cfi1            = ETH_CFI_MAX_CNS;
    patternPtr->eth.etherType       = BIT_16 - 1;
    patternPtr->eth.macToMe         = GT_TRUE;
    patternPtr->eth.srcId           = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum);
    patternPtr->eth.dsaQosProfile   = QOS_PROFILE_MAX_CNS;
    patternPtr->eth.tag0TpidIndex   = BIT_3 - 1;
    patternPtr->eth.tag1TpidIndex   = BIT_3 - 1;
    patternPtr->eth.eTagGrp         = BIT_2 - 1;
}

/**
* @internal prvSetDefaultMimPattern function
* @endinternal
*
* @brief   This routine set default Mim pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultMimPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetDefaultCommonPattern(&patternPtr->mim.common);

    patternPtr->mim.bUp                     = 0;
    patternPtr->mim.bDp                     = 0;
    patternPtr->mim.iSid                    = 0;
    patternPtr->mim.iUp                     = 0;
    patternPtr->mim.iDp                     = 0;
    patternPtr->mim.iRes1                   = 0;
    patternPtr->mim.iRes2                   = 0;
    patternPtr->mim.macToMe                 = GT_FALSE;
    patternPtr->mim.passengerPacketOuterTagExists   = GT_FALSE;
    patternPtr->mim.passengerPacketOuterTagVid      = 0;
    patternPtr->mim.passengerPacketOuterTagUp       = 0;
    patternPtr->mim.passengerPacketOuterTagDei      = 0;
}

/**
* @internal prvSetRandomValuesMimPattern function
* @endinternal
*
* @brief   This routine set default Mim pattern with random field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetRandomValuesCommonPattern(devNum, &patternPtr->mim.common);

    patternPtr->mim.bUp                     = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
    patternPtr->mim.bDp                     = DP_MAX_CNS / 2;
    patternPtr->mim.iSid                    = MIM_ISID_MAX_CNS / 2;
    patternPtr->mim.iUp                     = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
    patternPtr->mim.iDp                     = DP_MAX_CNS / 2;
    patternPtr->mim.iRes1                   = MIM_IRES_MAX_CNS / 2;
    patternPtr->mim.iRes2                   = MIM_IRES_MAX_CNS / 2;
    patternPtr->mim.macToMe                 = GT_FALSE;
    patternPtr->mim.passengerPacketOuterTagExists   = GT_TRUE;
    patternPtr->mim.passengerPacketOuterTagVid      = BIT_6 - 1;
    patternPtr->mim.passengerPacketOuterTagUp       = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
    patternPtr->mim.passengerPacketOuterTagDei      = BIT_1 - 1;
}

/**
* @internal prvSetMaximumValuesAndPortCasesMimPattern function
* @endinternal
*
* @brief   This routine set Mim pattern with maximum field values and port cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndPortCasesCommonPattern(devNum, &patternPtr->mim.common);

    patternPtr->mim.bUp                     = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.bDp                     = DP_MAX_CNS;
    patternPtr->mim.iSid                    = MIM_ISID_MAX_CNS;
    patternPtr->mim.iUp                     = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.iDp                     = DP_MAX_CNS;
    patternPtr->mim.iRes1                   = MIM_IRES_MAX_CNS;
    patternPtr->mim.iRes2                   = MIM_IRES_MAX_CNS;
    patternPtr->mim.macToMe                 = GT_TRUE;
    patternPtr->mim.passengerPacketOuterTagExists   = GT_TRUE;
    patternPtr->mim.passengerPacketOuterTagVid      = BIT_12 - 1;
    patternPtr->mim.passengerPacketOuterTagUp       = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.passengerPacketOuterTagDei      = BIT_1 - 1;
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesMimPattern function
* @endinternal
*
* @brief   This routine set Mim pattern with maximum field values and trunk cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesMimPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndTrunkCasesCommonPattern(devNum, &patternPtr->mim.common);

    patternPtr->mim.bUp                     = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.bDp                     = DP_MAX_CNS;
    patternPtr->mim.iSid                    = MIM_ISID_MAX_CNS;
    patternPtr->mim.iUp                     = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.iDp                     = DP_MAX_CNS;
    patternPtr->mim.iRes1                   = MIM_IRES_MAX_CNS;
    patternPtr->mim.iRes2                   = MIM_IRES_MAX_CNS;
    patternPtr->mim.macToMe                 = GT_TRUE;
    patternPtr->mim.passengerPacketOuterTagExists   = GT_TRUE;
    patternPtr->mim.passengerPacketOuterTagVid      = BIT_12 - 1;
    patternPtr->mim.passengerPacketOuterTagUp       = CPSS_USER_PRIORITY_RANGE_CNS - 1;
    patternPtr->mim.passengerPacketOuterTagDei      = BIT_1 - 1;
}
/* TBD TRILL */
#if 0
/**
* @internal prvSetDefaultTrillPattern function
* @endinternal
*
* @brief   This routine set default Trill pattern.
*
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultTrillPattern
(
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetDefaultCommonPattern(&patternPtr->trill.common);

    patternPtr->trill.common.vid                    = BIT_12 - 1;
    patternPtr->trill.trillMBit                     = GT_FALSE;
    patternPtr->trill.trillEgressRbid               = 0;
    patternPtr->trill.trillIngressRbid              = 0;
    patternPtr->trill.innerPacketMacDa.arEther[0]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[1]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[2]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[3]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[4]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[5]   = 0xAA;
    patternPtr->trill.innerPacketTag0Exists         = GT_FALSE;
    patternPtr->trill.innerPacketTag0Vid            = 0;
    patternPtr->trill.innerPacketFieldsAreValid     = GT_FALSE;
    patternPtr->trill.trillMcDescriptorInstance     = GT_FALSE;
}

/**
* @internal prvSetRandomValuesTrillPattern function
* @endinternal
*
* @brief   This routine set Trill pattern with random field values.
*
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetRandomValuesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetRandomValuesCommonPattern(devNum, &patternPtr->trill.common);

    patternPtr->trill.common.vid                    = BIT_12 - 1;
    patternPtr->trill.trillMBit                     = GT_TRUE;
    patternPtr->trill.trillEgressRbid               = BIT_8 - 1;
    patternPtr->trill.trillIngressRbid              = BIT_8 - 1;
    patternPtr->trill.innerPacketMacDa.arEther[0]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[1]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[2]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[3]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[4]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[5]   = 0xAA;
    patternPtr->trill.innerPacketTag0Exists         = GT_FALSE;
    patternPtr->trill.innerPacketTag0Vid            = BIT_6 - 1;
    patternPtr->trill.innerPacketFieldsAreValid     = GT_TRUE;
    patternPtr->trill.trillMcDescriptorInstance     = GT_FALSE;
}

/**
* @internal prvSetMaximumValuesAndPortCasesTrillPattern function
* @endinternal
*
* @brief   This routine set Trill pattern with maximum field values and port cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndPortCasesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndPortCasesCommonPattern(devNum, &patternPtr->trill.common);

    patternPtr->trill.common.vid                    = BIT_12 - 1;
    patternPtr->trill.trillMBit                     = GT_TRUE;
    patternPtr->trill.trillEgressRbid               = BIT_16 - 1;
    patternPtr->trill.trillIngressRbid              = BIT_16 - 1;
    patternPtr->trill.innerPacketMacDa.arEther[0]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[1]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[2]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[3]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[4]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[5]   = 0xAA;
    patternPtr->trill.innerPacketTag0Exists         = GT_TRUE;
    patternPtr->trill.innerPacketTag0Vid            = BIT_12 - 1;
    patternPtr->trill.innerPacketFieldsAreValid     = GT_TRUE;
    patternPtr->trill.trillMcDescriptorInstance     = GT_TRUE;
}

/**
* @internal prvSetMaximumValuesAndTrunkCasesTrillPattern function
* @endinternal
*
* @brief   This routine set Trill pattern with maximum field values and trunk cases
*         of port/trunk switch.
* @param[in] devNum                   - device number
* @param[in] patternPtr               - (pointer to) pattern union
*/
static GT_VOID prvSetMaximumValuesAndTrunkCasesTrillPattern
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *patternPtr
)
{
    prvSetMaximumValuesAndTrunkCasesCommonPattern(devNum, &patternPtr->trill.common);

    patternPtr->trill.common.vid                    = BIT_12 - 1;
    patternPtr->trill.trillMBit                     = GT_TRUE;
    patternPtr->trill.trillEgressRbid               = BIT_16 - 1;
    patternPtr->trill.trillIngressRbid              = BIT_16 - 1;
    patternPtr->trill.innerPacketMacDa.arEther[0]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[1]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[2]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[3]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[4]   = 0xAA;
    patternPtr->trill.innerPacketMacDa.arEther[5]   = 0xAA;
    patternPtr->trill.innerPacketTag0Exists         = GT_TRUE;
    patternPtr->trill.innerPacketTag0Vid            = BIT_12 - 1;
    patternPtr->trill.innerPacketFieldsAreValid     = GT_TRUE;
    patternPtr->trill.trillMcDescriptorInstance     = GT_TRUE;
}
#endif
/**
* @internal prvSetDefaultCommonMask function
* @endinternal
*
* @brief   This routine set defaultCommon mask.
*
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultCommonMask
(
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *maskPtr
)
{
    GT_U8 devNum = ttiGlobal_devNum;

    cpssOsMemSet(maskPtr, 0xFF, sizeof(*maskPtr));

    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
    {
        maskPtr->pclId              &= BIT_10 - 1;/*10 bits*/
        maskPtr->srcIsTrunk         &= 0x01;
        maskPtr->srcPortTrunk       &= BIT_8 - 1;
        maskPtr->vid                &= BIT_13 - 1;/*13 bits*/
        maskPtr->isTagged           &= 0x01;
        maskPtr->dsaSrcIsTrunk      &= 0x01;
        maskPtr->dsaSrcPortTrunk    &= BIT_13 - 1;
        maskPtr->dsaSrcDevice       &= BIT_10 - 1;
        maskPtr->sourcePortGroupId  &= PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PORT_GROUP_ID_MAC(devNum);
    }
    else
    {
        maskPtr->pclId              = 0x000003FF;
        maskPtr->srcIsTrunk         = 0x01;
        maskPtr->srcPortTrunk       = 0x000000FF;
        maskPtr->vid                = 0x0FFF;
        maskPtr->isTagged           = 0x01;
        maskPtr->dsaSrcIsTrunk      = 0x01;
        maskPtr->dsaSrcPortTrunk    = 0x7F;
        if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
        {
            /* dsaSrcDevice is 7 bits but only 5 bits are used  */
            maskPtr->dsaSrcDevice       = 0x1F;
        }
        else
        {
            maskPtr->dsaSrcDevice       = 0x7F;
        }
    }
    maskPtr->sourcePortGroupId  = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PORT_GROUP_ID_MAC(devNum);
}

/**
* @internal prvSetDefaultDeviceDependentCommonMask function
* @endinternal
*
* @brief   This routine set device dependent defaultCommon mask.
*
* @param[in] devNum                   - device number
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentCommonMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *maskPtr
)
{
    prvSetDefaultCommonMask(maskPtr);

    /* to avoid compilation warnings */
    TGF_PARAM_NOT_USED(devNum);
}

/**
* @internal prvSetDefaultIpv4Mask function
* @endinternal
*
* @brief   This routine set default Ipv4 mask.
*
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultIpv4Mask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *maskPtr
)
{
    prvSetDefaultCommonMask(&maskPtr->ipv4.common);

    cpssOsMemSet(&maskPtr->ipv4.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->ipv4.common));
    maskPtr->ipv4.tunneltype        = 0x00000007;
    maskPtr->ipv4.isArp             = 0x01;
}

/**
* @internal prvSetDefaultDeviceDependentIpv4Mask function
* @endinternal
*
* @brief   This routine set default device dependent Ipv4 mask.
*
* @param[in] devNum                   - deviceNumber
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentIpv4Mask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *maskPtr
)
{
    prvSetDefaultDeviceDependentCommonMask(devNum, &maskPtr->ipv4.common);

    cpssOsMemSet(&maskPtr->ipv4.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->ipv4.common));
    maskPtr->ipv4.tunneltype        = 0x00000007;
    maskPtr->ipv4.isArp             = 0x01;
}


/**
* @internal prvSetDefaultMplsMask function
* @endinternal
*
* @brief   This routine set default Mpls mask.
*
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultMplsMask
(
    IN CPSS_DXCH_TTI_RULE_UNT           *maskPtr
)
{
    prvSetDefaultCommonMask(&maskPtr->mpls.common);

    cpssOsMemSet(&maskPtr->mpls.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->mpls.common));
    maskPtr->mpls.label0                = 0x000FFFFF;
    maskPtr->mpls.exp0                  = 0x00000007;
    maskPtr->mpls.label1                = 0x000FFFFF;
    maskPtr->mpls.exp1                  = 0x00000007;
    maskPtr->mpls.label2                = 0x000FFFFF;
    maskPtr->mpls.exp2                  = 0x00000007;
    maskPtr->mpls.numOfLabels           = 0x00000003;
    maskPtr->mpls.protocolAboveMPLS     = 0x00000003;
    maskPtr->mpls.reservedLabelExist    = 0x01;
    maskPtr->mpls.reservedLabelValue    = 0x0000000F;
    maskPtr->mpls.channelTypeProfile    = 0x00000007;
    maskPtr->mpls.dataAfterInnerLabel   = BIT_5 - 1;/* 5 bits */
    maskPtr->mpls.cwFirstNibble         = BIT_4 - 1;/* 4 bits */
}

/**
* @internal prvSetDefaultDeviceDependentMplsMask function
* @endinternal
*
* @brief   This routine set default device dependent Mpls mask.
*
* @param[in] devNum                   - device number
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentMplsMask
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_RULE_UNT           *maskPtr
)
{
    prvSetDefaultDeviceDependentCommonMask(devNum, &maskPtr->mpls.common);

    cpssOsMemSet(&maskPtr->mpls.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->mpls.common));
    maskPtr->mpls.label0                = 0x000FFFFF;
    maskPtr->mpls.exp0                  = 0x00000007;
    maskPtr->mpls.label1                = 0x000FFFFF;
    maskPtr->mpls.exp1                  = 0x00000007;
    maskPtr->mpls.label2                = 0x000FFFFF;
    maskPtr->mpls.exp2                  = 0x00000007;
    maskPtr->mpls.numOfLabels           = 0x00000003;
    maskPtr->mpls.protocolAboveMPLS     = 0x00000003;
    maskPtr->mpls.reservedLabelExist    = 0x01;
    maskPtr->mpls.reservedLabelValue    = 0x0000000F;
    maskPtr->mpls.channelTypeProfile    = 0x00000007;
    maskPtr->mpls.dataAfterInnerLabel   = BIT_5 - 1;/* 5 bits */
    maskPtr->mpls.cwFirstNibble         = BIT_4 - 1;/* 5 bits */
}

/**
* @internal prvSetDefaultDeviceDependentEthMask function
* @endinternal
*
* @brief   This routine set default device dependent Ethernet mask.
*
* @param[in] devNum                   - device number
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentEthMask
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_RULE_UNT          *maskPtr
)
{
    prvSetDefaultDeviceDependentCommonMask(devNum, &maskPtr->eth.common);

    cpssOsMemSet(&maskPtr->eth.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->eth.common));
    maskPtr->eth.up0            = 0x00000007;
    maskPtr->eth.cfi0           = 0x00000001;
    maskPtr->eth.isVlan1Exists  = 0x01;
    maskPtr->eth.vid1           = 0x00000FFF;
    maskPtr->eth.up1            = 0x00000007;
    maskPtr->eth.cfi1           = 0x00000001;
    maskPtr->eth.etherType      = 0x0000FFFF;
    maskPtr->eth.macToMe        = 0x01;
    maskPtr->eth.srcId          = 0x00000FFF;
    maskPtr->eth.dsaQosProfile  = 0x0000007F;
    maskPtr->eth.tag0TpidIndex  = 0x00000007;
    maskPtr->eth.tag1TpidIndex  = 0x00000007;

    if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
    {
        maskPtr->eth.srcId          = 0x00000FFF;
    }
    else
    {
        maskPtr->eth.srcId          = 0x0000001F;
    }

    maskPtr->eth.eTagGrp         = 0x3;
}

/**
* @internal prvSetDefaultMimMask function
* @endinternal
*
* @brief   This routine set default Mim mask.
*
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultMimMask
(
    IN  CPSS_DXCH_TTI_RULE_UNT          *maskPtr
)
{
    prvSetDefaultCommonMask(&maskPtr->mim.common);

    cpssOsMemSet(&maskPtr->mim.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->mim.common));
    maskPtr->mim.bUp                    = 0x00000007;
    maskPtr->mim.bDp                    = 0x00000001;
    maskPtr->mim.iSid                   = 0x00000001;
    maskPtr->mim.iUp                    = 0x00000007;
    maskPtr->mim.iDp                    = 0x00000001;
    maskPtr->mim.iRes1                  = 0x00000003;
    maskPtr->mim.iRes2                  = 0x00000003;
    maskPtr->mim.macToMe                = 0x01;
    maskPtr->mim.passengerPacketOuterTagExists  = 0x01;
    maskPtr->mim.passengerPacketOuterTagVid     = 0x00000FFF;
    maskPtr->mim.passengerPacketOuterTagUp      = 0x00000007;
    maskPtr->mim.passengerPacketOuterTagDei     = 0x00000001;
}

/**
* @internal prvSetDefaultDeviceDependentMimMask function
* @endinternal
*
* @brief   This routine set default device dependent Mim mask.
*
* @param[in] devNum                   - device number
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentMimMask
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_RULE_UNT          *maskPtr
)
{
    prvSetDefaultDeviceDependentCommonMask(devNum, &maskPtr->mim.common);

    cpssOsMemSet(&maskPtr->mim.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->mim.common));
    maskPtr->mim.bUp                    = 0x00000007;
    maskPtr->mim.bDp                    = 0x00000001;
    maskPtr->mim.iSid                   = 0x00FFFFFF;
    maskPtr->mim.iUp                    = 0x00000007;
    maskPtr->mim.iDp                    = 0x00000001;
    maskPtr->mim.iRes1                  = 0x00000003;
    maskPtr->mim.iRes2                  = 0x00000003;
    maskPtr->mim.macToMe                = 0x01;
    maskPtr->mim.passengerPacketOuterTagExists  = 0x01;
    maskPtr->mim.passengerPacketOuterTagVid     = 0x00000FFF;
    maskPtr->mim.passengerPacketOuterTagUp      = 0x00000007;
    maskPtr->mim.passengerPacketOuterTagDei     = 0x00000001;
}
/* TBD TRILL */
#if 0
/**
* @internal prvSetDefaultTrillMask function
* @endinternal
*
* @brief   This routine set default Trill mask.
*
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultTrillMask
(
    IN  CPSS_DXCH_TTI_RULE_UNT          *maskPtr
)
{
    prvSetDefaultCommonMask(&maskPtr->trill.common);

    maskPtr->trill.common.vid = 0x00000FFF;

    cpssOsMemSet(&maskPtr->trill.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->trill.common));
    maskPtr->trill.trillMBit                    = 0x01;
    maskPtr->trill.trillEgressRbid              = 0x0000FFFF;
    maskPtr->trill.trillIngressRbid             = 0x0000FFFF;
    maskPtr->trill.innerPacketTag0Exists        = 0x01;
    maskPtr->trill.innerPacketTag0Vid           = 0x00000FFF;
    maskPtr->trill.innerPacketFieldsAreValid    = 0x01;
    maskPtr->trill.trillMcDescriptorInstance    = 0x01;
}

/**
* @internal prvSetDefaultDeviceDependentTrillMask function
* @endinternal
*
* @brief   This routine set default device dependent Trill mask.
*
* @param[in] devNum                   - device number
* @param[in] maskPtr                  - (pointer to) pattern union
*/
static GT_VOID prvSetDefaultDeviceDependentTrillMask
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_RULE_UNT          *maskPtr
)
{
    prvSetDefaultDeviceDependentCommonMask(devNum, &maskPtr->trill.common);

    cpssOsMemSet(&maskPtr->trill.common + 1, 0xFF,
                 sizeof(*maskPtr) - sizeof(maskPtr->trill.common));

    maskPtr->trill.common.vid                   = 0xFFF;
    maskPtr->trill.trillMBit                    = 0x01;
    maskPtr->trill.trillEgressRbid              = 0x0000FFFF;
    maskPtr->trill.trillIngressRbid             = 0x0000FFFF;
    maskPtr->trill.innerPacketTag0Exists        = 0x01;
    maskPtr->trill.innerPacketTag0Vid           = 0x00000FFF;
    maskPtr->trill.innerPacketFieldsAreValid    = 0x01;
    maskPtr->trill.trillMcDescriptorInstance    = 0x01;
}
#endif
/**
* @internal prvSetDefaultAction function
* @endinternal
*
* @brief   This routine set default TTI TCAM rule action.
*
* @param[in] actionPtr                - (pointer to) action
* @param[in] type                     - action type
*/
static GT_VOID prvSetDefaultAction
(
    IN  CPSS_DXCH_TTI_ACTION_UNT        *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
)
{
    cpssOsBzero((GT_VOID*) actionPtr,         sizeof(CPSS_DXCH_TTI_ACTION_UNT));
    switch(type)
    {
    case CPSS_DXCH_TTI_ACTION_TYPE2_ENT:
        actionPtr->type2.tunnelTerminate                    = GT_FALSE;
        actionPtr->type2.ttPassengerPacketType              = CPSS_DXCH_TTI_PASSENGER_IPV4V6_E;
        actionPtr->type2.tsPassengerPacketType              = CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E;

        actionPtr->type2.ttHeaderLength                     = 0;
        actionPtr->type2.continueToNextTtiLookup            = GT_FALSE;

        actionPtr->type2.copyTtlExpFromTunnelHeader         = GT_FALSE;

        actionPtr->type2.mplsCommand                        = CPSS_DXCH_TTI_MPLS_NOP_CMD_E;
        actionPtr->type2.mplsTtl                            = 0;

        actionPtr->type2.passengerParsingOfTransitMplsTunnelMode = CPSS_DXCH_TTI_PASSENGER_PARSING_OF_TRANSIT_MPLS_TUNNEL_MODE_DISABLE_E;
        actionPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable = GT_TRUE;

        actionPtr->type2.enableDecrementTtl                 = GT_FALSE;

        actionPtr->type2.command                            = CPSS_PACKET_CMD_FORWARD_E;

        actionPtr->type2.redirectCommand                    = CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E;
        actionPtr->type2.egressInterface.type               = CPSS_INTERFACE_PORT_E;
        actionPtr->type2.egressInterface.devPort.hwDevNum     = 0;
        actionPtr->type2.egressInterface.devPort.portNum    = TTI_VALID_PORT_TRUNK_CNS;
        actionPtr->type2.egressInterface.trunkId            = TTI_VALID_PORT_TRUNK_CNS;
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(actionPtr->type2.egressInterface.trunkId);
        actionPtr->type2.egressInterface.vidx               = 0;
        actionPtr->type2.egressInterface.vlanId             = 0;
        actionPtr->type2.egressInterface.hwDevNum             = 0;
        actionPtr->type2.egressInterface.fabricVidx         = 0;
        actionPtr->type2.egressInterface.index              = 0;
        actionPtr->type2.arpPtr                             = 0;
        actionPtr->type2.tunnelStart                        = GT_TRUE;
        actionPtr->type2.tunnelStartPtr                     = 0;
        actionPtr->type2.routerLttPtr                       = 0;
        actionPtr->type2.vrfId                              = 0;

        actionPtr->type2.sourceIdSetEnable                  = GT_FALSE;
        actionPtr->type2.sourceId = 0;

        actionPtr->type2.tag0VlanCmd                        = CPSS_DXCH_TTI_VLAN_DO_NOT_MODIFY_E;
        actionPtr->type2.tag0VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag1VlanCmd                        = CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E;
        actionPtr->type2.tag1VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag0VlanPrecedence                 = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E;
        actionPtr->type2.nestedVlanEnable                   = GT_FALSE;

        actionPtr->type2.bindToPolicerMeter                 = GT_FALSE;
        actionPtr->type2.bindToPolicer                      = GT_FALSE;
        actionPtr->type2.policerIndex                       = 0;

        actionPtr->type2.qosPrecedence                      = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E;
        actionPtr->type2.keepPreviousQoS                    = GT_FALSE;
        actionPtr->type2.trustUp                            = GT_FALSE;
        actionPtr->type2.trustDscp                          = GT_FALSE;
        actionPtr->type2.trustExp                           = GT_FALSE;
        actionPtr->type2.qosProfile                         = 0;
        actionPtr->type2.modifyTag0Up                       = CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_UP_E;
        actionPtr->type2.tag1UpCommand                      = CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN1_UNTAGGED_E;
        actionPtr->type2.modifyDscp                         = CPSS_DXCH_TTI_DO_NOT_MODIFY_PREV_DSCP_E;
        actionPtr->type2.tag0Up                             = 0;
        actionPtr->type2.tag1Up                             = 0;
        actionPtr->type2.remapDSCP                          = GT_FALSE;

        actionPtr->type2.qosUseUpAsIndexEnable              = GT_FALSE;
        actionPtr->type2.qosMappingTableIndex               = 0;
        actionPtr->type2.mplsLLspQoSProfileEnable           = GT_FALSE;


        actionPtr->type2.pcl0OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E;
        actionPtr->type2.pcl0_1OverrideConfigIndex          = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E;
        actionPtr->type2.pcl1OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E;
        actionPtr->type2.iPclConfigIndex                    = 0;

        actionPtr->type2.iPclUdbConfigTableEnable           = GT_FALSE;
        actionPtr->type2.iPclUdbConfigTableIndex            = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;

        actionPtr->type2.mirrorToIngressAnalyzerEnable      = GT_FALSE;
        actionPtr->type2.mirrorToIngressAnalyzerIndex       = 0;
        actionPtr->type2.userDefinedCpuCode                 = CPSS_NET_FIRST_USER_DEFINED_E + 1;
        actionPtr->type2.bindToCentralCounter               = GT_FALSE;
        actionPtr->type2.centralCounterIndex                = 0;
        actionPtr->type2.vntl2Echo                          = GT_FALSE;
        actionPtr->type2.bridgeBypass                       = GT_FALSE;
        actionPtr->type2.ingressPipeBypass                  = GT_FALSE;
        actionPtr->type2.actionStop                         = GT_FALSE;
        actionPtr->type2.hashMaskIndex                      = 0;
        actionPtr->type2.modifyMacSa                        = GT_FALSE;
        actionPtr->type2.modifyMacDa                        = GT_FALSE;
        actionPtr->type2.ResetSrcPortGroupId                = GT_FALSE;
        actionPtr->type2.multiPortGroupTtiEnable            = GT_FALSE;

        actionPtr->type2.sourceEPortAssignmentEnable        = GT_FALSE;
        actionPtr->type2.sourceEPort                        = TTI_VALID_PORT_TRUNK_CNS;

        actionPtr->type2.flowId                             = 0;
        actionPtr->type2.setMacToMe                         = GT_FALSE;
        actionPtr->type2.rxProtectionSwitchEnable           = GT_FALSE;
        actionPtr->type2.rxIsProtectionPath                 = GT_FALSE;
        actionPtr->type2.pwTagMode                          = CPSS_DXCH_TTI_PW_TAG_DISABLED_MODE_E;

        actionPtr->type2.oamTimeStampEnable                 = GT_FALSE;
        actionPtr->type2.oamOffsetIndex                     = 0;
        actionPtr->type2.oamProcessEnable                   = GT_FALSE;
        actionPtr->type2.oamProfile                         = 0;
        actionPtr->type2.oamChannelTypeToOpcodeMappingEnable= GT_FALSE;
        actionPtr->type2.isPtpPacket                        = GT_FALSE;
        actionPtr->type2.ptpTriggerType                     = CPSS_DXCH_TTI_PTP_TRIGGER_TYPE_PTP_OVER_L2_E;
        actionPtr->type2.ptpOffset                          = 0;

        actionPtr->type2.cwBasedPw                          = GT_FALSE;
        actionPtr->type2.ttlExpiryVccvEnable                = GT_FALSE;
        actionPtr->type2.pwe3FlowLabelExist                 = GT_FALSE;
        actionPtr->type2.pwCwBasedETreeEnable               = GT_FALSE;
        actionPtr->type2.applyNonDataCwCommand              = GT_FALSE;

        actionPtr->type2.unknownSaCommandEnable             = GT_FALSE;
        actionPtr->type2.unknownSaCommand                   = CPSS_PACKET_CMD_FORWARD_E;
        actionPtr->type2.sourceMeshIdSetEnable              = GT_FALSE;
        actionPtr->type2.sourceMeshId                       = 0;

        break;

    default:
        break;
    }
}

/**
* @internal prvSetRandomValuesAction function
* @endinternal
*
* @brief   This routine set TTI TCAM rule action with random values.
*
* @param[in] devNum                   - device number
* @param[in] actionPtr                - (pointer to) action
* @param[in] type                     - action type
*/
static GT_VOID prvSetRandomValuesAction
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_ACTION_UNT        *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
)
{
    cpssOsBzero((GT_VOID*) actionPtr,         sizeof(CPSS_DXCH_TTI_ACTION_UNT));
    switch(type)
    {
    case CPSS_DXCH_TTI_ACTION_TYPE2_ENT:
        actionPtr->type2.tunnelTerminate                    = GT_TRUE;
        actionPtr->type2.ttPassengerPacketType              = CPSS_DXCH_TTI_PASSENGER_ETHERNET_CRC_E;
        actionPtr->type2.tsPassengerPacketType              = CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E;

        actionPtr->type2.ttHeaderLength                     = TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(devNum)-2;
        actionPtr->type2.continueToNextTtiLookup            = GT_TRUE;

        actionPtr->type2.copyTtlExpFromTunnelHeader         = GT_FALSE;

        actionPtr->type2.mplsCommand                        = CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E;
        actionPtr->type2.mplsTtl                            = 1;

        actionPtr->type2.passengerParsingOfTransitMplsTunnelMode = CPSS_DXCH_TTI_PASSENGER_PARSING_OF_TRANSIT_MPLS_TUNNEL_MODE_AS_ETH_E;
        actionPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable = GT_TRUE;

        actionPtr->type2.enableDecrementTtl                 = GT_TRUE;

        actionPtr->type2.command                            = CPSS_PACKET_CMD_FORWARD_E;

        actionPtr->type2.redirectCommand                    = CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E;
        actionPtr->type2.egressInterface.type               = CPSS_INTERFACE_TRUNK_E;
        actionPtr->type2.egressInterface.devPort.hwDevNum     = (UTF_CPSS_PP_MAX_HW_DEV_NUM_CNS(devNum) - 1) / 2;
        actionPtr->type2.egressInterface.devPort.portNum    = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum) / 2;
        if (PRV_CPSS_DXCH_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(devNum)->hwDevNum))
        {
            actionPtr->type2.egressInterface.devPort.hwDevNum &= 0xfffffffe;
            if (actionPtr->type2.egressInterface.devPort.portNum > 127)
            {
                actionPtr->type2.egressInterface.devPort.portNum = 127;
            }
        }
        actionPtr->type2.egressInterface.trunkId            = (GT_U16) ((UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) - 1) / 2);
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(actionPtr->type2.egressInterface.trunkId);
        actionPtr->type2.egressInterface.vidx               = (GT_U16) (PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VIDX_MAC(devNum) / 2);
        actionPtr->type2.egressInterface.vlanId             = (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) / 2;
        actionPtr->type2.egressInterface.hwDevNum             = (UTF_CPSS_PP_MAX_HW_DEV_NUM_CNS(devNum) - 1) / 2;
        actionPtr->type2.egressInterface.fabricVidx         = 0x00FF;
        actionPtr->type2.egressInterface.index              = 0x0000FFFF;
        actionPtr->type2.arpPtr                             = 0;
        actionPtr->type2.tunnelStart                        = GT_FALSE;
        actionPtr->type2.tunnelStartPtr                     = 0;
        actionPtr->type2.routerLttPtr                       = 0;
        actionPtr->type2.vrfId                              = 0;

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.egressInterface.type           = CPSS_INTERFACE_PORT_E;
        }

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            actionPtr->type2.egressInterface.devPort.hwDevNum  &= BIT_MASK_MAC(10);
            actionPtr->type2.egressInterface.devPort.portNum &= BIT_MASK_MAC(13);
            actionPtr->type2.egressInterface.trunkId         &= BIT_MASK_MAC(12);
            actionPtr->type2.egressInterface.vidx            &= BIT_MASK_MAC(16);
        }

        actionPtr->type2.sourceIdSetEnable                  = GT_TRUE;
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            actionPtr->type2.sourceId = 2047;
        }
        else
        {
            actionPtr->type2.sourceId = 15;
        }

        actionPtr->type2.tag0VlanCmd                        = CPSS_DXCH_TTI_VLAN_MODIFY_TAGGED_E;
        actionPtr->type2.tag0VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag1VlanCmd                        = CPSS_DXCH_TTI_VLAN_MODIFY_UNTAGGED_E;
        actionPtr->type2.tag1VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag0VlanPrecedence                 = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E;
        actionPtr->type2.nestedVlanEnable                   = GT_FALSE;

        actionPtr->type2.bindToPolicerMeter                 = GT_TRUE;
        actionPtr->type2.bindToPolicer                      = GT_FALSE;
        actionPtr->type2.policerIndex                       = BIT_6 - 1;

        actionPtr->type2.qosPrecedence                      = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_HARD_E;
        actionPtr->type2.keepPreviousQoS                    = GT_TRUE;
        actionPtr->type2.trustUp                            = GT_FALSE;
        actionPtr->type2.trustDscp                          = GT_TRUE;
        actionPtr->type2.trustExp                           = GT_FALSE;
        actionPtr->type2.qosProfile                         = QOS_PROFILE_MAX_CNS / 2;
        actionPtr->type2.modifyTag0Up                       = CPSS_DXCH_TTI_MODIFY_UP_DISABLE_E;
        actionPtr->type2.tag1UpCommand                      = CPSS_DXCH_TTI_TAG1_UP_ASSIGN_VLAN0_UNTAGGED_E;
        actionPtr->type2.modifyDscp                         = CPSS_DXCH_TTI_MODIFY_DSCP_DISABLE_E;
        actionPtr->type2.tag0Up                             = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
        actionPtr->type2.tag1Up                             = (CPSS_USER_PRIORITY_RANGE_CNS - 1) / 2;
        actionPtr->type2.remapDSCP                          = GT_TRUE;

        actionPtr->type2.qosUseUpAsIndexEnable              = GT_FALSE;
        actionPtr->type2.qosMappingTableIndex               = 0;
        actionPtr->type2.mplsLLspQoSProfileEnable           = GT_FALSE;

        actionPtr->type2.pcl0OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E;
        actionPtr->type2.pcl0_1OverrideConfigIndex          = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E;
        actionPtr->type2.pcl1OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_RETAIN_E;

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.iPclConfigIndex                = IPCL_INDEX_MAX_FOR_VPLS_CNS / 2;
        }
        else
        {
            actionPtr->type2.iPclConfigIndex                = IPCL_INDEX_MAX_CNS / 2;
        }

        actionPtr->type2.iPclUdbConfigTableEnable           = GT_FALSE;
        actionPtr->type2.iPclUdbConfigTableIndex            = CPSS_DXCH_PCL_PACKET_TYPE_UDE1_E;

        actionPtr->type2.mirrorToIngressAnalyzerEnable      = GT_TRUE;
        actionPtr->type2.mirrorToIngressAnalyzerIndex       = 5;
        actionPtr->type2.userDefinedCpuCode                 = CPSS_NET_LAST_USER_DEFINED_E - 1;
        actionPtr->type2.bindToCentralCounter               = GT_TRUE;
        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.centralCounterIndex            = 2047;
        }
        else
        {
            actionPtr->type2.centralCounterIndex            = CENTRAL_COUNTER_MAX_CNS / 2;
        }
        actionPtr->type2.vntl2Echo                          = GT_FALSE;
        actionPtr->type2.bridgeBypass                       = GT_TRUE;
        actionPtr->type2.ingressPipeBypass                  = GT_FALSE;
        actionPtr->type2.actionStop                         = GT_TRUE;
        actionPtr->type2.hashMaskIndex                      = BIT_2 - 1;
        actionPtr->type2.modifyMacSa                        = GT_FALSE;
        actionPtr->type2.modifyMacDa                        = GT_TRUE;
        actionPtr->type2.ResetSrcPortGroupId                = GT_FALSE;
        actionPtr->type2.multiPortGroupTtiEnable            = GT_TRUE;

        actionPtr->type2.sourceEPortAssignmentEnable        = GT_FALSE;
        actionPtr->type2.sourceEPort                        = TTI_VALID_PORT_TRUNK_CNS;

        actionPtr->type2.flowId                             = 0;
        actionPtr->type2.setMacToMe                         = GT_TRUE;
        actionPtr->type2.rxProtectionSwitchEnable           = GT_TRUE;
        actionPtr->type2.rxIsProtectionPath                 = GT_TRUE;
        actionPtr->type2.pwTagMode                          = CPSS_DXCH_TTI_PW_TAG_DISABLED_MODE_E;

        actionPtr->type2.oamTimeStampEnable                 = GT_TRUE;
        actionPtr->type2.oamOffsetIndex                     = 64;
        actionPtr->type2.oamProcessEnable                   = GT_TRUE;
        actionPtr->type2.oamProfile                         = 1;
        actionPtr->type2.oamChannelTypeToOpcodeMappingEnable= GT_FALSE;
        actionPtr->type2.isPtpPacket                        = GT_TRUE;
        actionPtr->type2.ptpTriggerType                     = CPSS_DXCH_TTI_PTP_TRIGGER_TYPE_PTP_OVER_IPV4_UDP_E;
        actionPtr->type2.ptpOffset                          = PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) ? 32 : 64;

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.cwBasedPw                          = GT_TRUE;
        }
        else
        {
            actionPtr->type2.cwBasedPw                          = GT_FALSE;
        }
        actionPtr->type2.ttlExpiryVccvEnable                = GT_TRUE;
        actionPtr->type2.pwe3FlowLabelExist                 = GT_FALSE;
        actionPtr->type2.pwCwBasedETreeEnable               = GT_TRUE;
        actionPtr->type2.applyNonDataCwCommand              = GT_FALSE;
        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.unknownSaCommandEnable             = GT_TRUE;
            actionPtr->type2.unknownSaCommand                   = CPSS_PACKET_CMD_DROP_SOFT_E;
            actionPtr->type2.sourceMeshIdSetEnable              = GT_TRUE;
            actionPtr->type2.sourceMeshId                       = 2;
        }
        else
        {
            actionPtr->type2.unknownSaCommandEnable             = GT_FALSE;
            actionPtr->type2.unknownSaCommand                   = CPSS_PACKET_CMD_FORWARD_E;
            actionPtr->type2.sourceMeshIdSetEnable              = GT_FALSE;
            actionPtr->type2.sourceMeshId                       = 0;
        }


        break;

    default:
        break;
    }
}

/**
* @internal prvSetMaximumValuesAction function
* @endinternal
*
* @brief   This routine set TTI TCAM rule action with random values.
*
* @param[in] devNum                   - device number
* @param[in] actionPtr                - (pointer to) action
* @param[in] type                     - action type
*/
static GT_VOID prvSetMaximumValuesAction
(
    IN GT_U8                            devNum,
    IN  CPSS_DXCH_TTI_ACTION_UNT        *actionPtr,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    type
)
{
    cpssOsBzero((GT_VOID*) actionPtr,         sizeof(CPSS_DXCH_TTI_ACTION_UNT));
    switch(type)
    {
    case CPSS_DXCH_TTI_ACTION_TYPE2_ENT:
        actionPtr->type2.tunnelTerminate                    = GT_TRUE;
        actionPtr->type2.ttPassengerPacketType              = CPSS_DXCH_TTI_PASSENGER_MPLS_E;
        actionPtr->type2.tsPassengerPacketType              = CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E;

        actionPtr->type2.ttHeaderLength                     = TT_HEADER_LENGTH___OUT_OF_RANGE_CNS(devNum)-2;
        actionPtr->type2.continueToNextTtiLookup            = GT_TRUE;

        actionPtr->type2.copyTtlExpFromTunnelHeader         = GT_TRUE;

        actionPtr->type2.mplsCommand                        = CPSS_DXCH_TTI_MPLS_POP1_CMD_E;
        actionPtr->type2.mplsTtl                            = TTL_MAX_CNS;

        actionPtr->type2.passengerParsingOfTransitMplsTunnelMode = CPSS_DXCH_TTI_PASSENGER_PARSING_OF_TRANSIT_MPLS_TUNNEL_MODE_AS_IP_E;
        actionPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable = GT_FALSE;

        actionPtr->type2.enableDecrementTtl                 = GT_TRUE;

        actionPtr->type2.command                            = CPSS_PACKET_CMD_FORWARD_E;

        actionPtr->type2.redirectCommand                    = CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E;
        actionPtr->type2.egressInterface.type               = CPSS_INTERFACE_PORT_E;
        actionPtr->type2.egressInterface.devPort.hwDevNum     = UTF_CPSS_PP_MAX_HW_DEV_NUM_CNS(devNum) - 1;
        actionPtr->type2.egressInterface.devPort.portNum    = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum);
        if (PRV_CPSS_DXCH_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(devNum)->hwDevNum))
        {
            actionPtr->type2.egressInterface.devPort.hwDevNum &= 0xfffffffe;
            if (actionPtr->type2.egressInterface.devPort.portNum > 127)
            {
                actionPtr->type2.egressInterface.devPort.portNum = 127;
            }
        }
        actionPtr->type2.egressInterface.trunkId            = (GT_U16) (UTF_CPSS_PP_MAX_TRUNK_ID_MAC(devNum) - 1);
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(actionPtr->type2.egressInterface.trunkId);
        actionPtr->type2.egressInterface.vidx               = (GT_U16) PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VIDX_MAC(devNum);
        actionPtr->type2.egressInterface.vlanId             = PRV_CPSS_MAX_NUM_VLANS_CNS - 1;
        actionPtr->type2.egressInterface.hwDevNum             = UTF_CPSS_PP_MAX_HW_DEV_NUM_CNS(devNum) - 1;
        actionPtr->type2.egressInterface.fabricVidx         = 0xFFFF;
        actionPtr->type2.egressInterface.index              = 0xFFFFFFFF;
        actionPtr->type2.arpPtr                             = 0;
        actionPtr->type2.tunnelStart                        = GT_TRUE;
        actionPtr->type2.tunnelStartPtr                     = 0;
        actionPtr->type2.routerLttPtr                       = 0;
        actionPtr->type2.vrfId                              = 0;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            actionPtr->type2.egressInterface.devPort.hwDevNum  &= BIT_MASK_MAC(10);
            actionPtr->type2.egressInterface.devPort.portNum &= BIT_MASK_MAC(13);
            actionPtr->type2.egressInterface.trunkId         &= BIT_MASK_MAC(12);
            actionPtr->type2.egressInterface.vidx            &= BIT_MASK_MAC(16);
        }

        actionPtr->type2.sourceIdSetEnable                  = GT_TRUE;

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            actionPtr->type2.sourceId = 4095;
        }
        else
        {
            actionPtr->type2.sourceId = 31;
        }


        actionPtr->type2.tag0VlanCmd                        = CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E;
        actionPtr->type2.tag0VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag1VlanCmd                        = CPSS_DXCH_TTI_VLAN_MODIFY_ALL_E;
        actionPtr->type2.tag1VlanId                         = TTI_VALID_VLAN_ID_CNS;
        actionPtr->type2.tag0VlanPrecedence                 = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E;
        actionPtr->type2.nestedVlanEnable                   = GT_TRUE;

        actionPtr->type2.bindToPolicerMeter                 = GT_TRUE;
        actionPtr->type2.bindToPolicer                      = GT_TRUE;
        actionPtr->type2.policerIndex                       = BIT_12 - 1;

        actionPtr->type2.qosPrecedence                      = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E;
        actionPtr->type2.keepPreviousQoS                    = GT_FALSE;
        actionPtr->type2.trustUp                            = GT_TRUE;
        actionPtr->type2.trustDscp                          = GT_TRUE;
        actionPtr->type2.trustExp                           = GT_TRUE;
        actionPtr->type2.qosProfile                         = QOS_PROFILE_MAX_CNS;
        actionPtr->type2.modifyTag0Up                       = CPSS_DXCH_TTI_MODIFY_UP_ENABLE_E;
        actionPtr->type2.tag1UpCommand                      = CPSS_DXCH_TTI_TAG1_UP_ASSIGN_ALL_E;
        actionPtr->type2.modifyDscp                         = CPSS_DXCH_TTI_MODIFY_DSCP_ENABLE_E;
        actionPtr->type2.tag0Up                             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
        actionPtr->type2.tag1Up                             = CPSS_USER_PRIORITY_RANGE_CNS - 1;
        actionPtr->type2.remapDSCP                          = GT_TRUE;

        actionPtr->type2.qosUseUpAsIndexEnable              = GT_TRUE;
        actionPtr->type2.qosMappingTableIndex               = 11;
        actionPtr->type2.mplsLLspQoSProfileEnable           = GT_TRUE;

        actionPtr->type2.pcl0OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E;
        actionPtr->type2.pcl0_1OverrideConfigIndex          = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E;
        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass == GT_FALSE)
        {
            actionPtr->type2.pcl1OverrideConfigIndex            = CPSS_DXCH_PCL_LOOKUP_CONFIG_INDEX_OVERRIDE_E;
        }

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.iPclConfigIndex                = IPCL_INDEX_MAX_FOR_VPLS_CNS;
        }
        else
        {
            actionPtr->type2.iPclConfigIndex                = IPCL_INDEX_MAX_CNS;
        }

        actionPtr->type2.iPclUdbConfigTableEnable           = GT_TRUE;
        actionPtr->type2.iPclUdbConfigTableIndex            = CPSS_DXCH_PCL_PACKET_TYPE_UDE1_E;

        actionPtr->type2.mirrorToIngressAnalyzerEnable      = GT_TRUE;
        actionPtr->type2.mirrorToIngressAnalyzerIndex       = 1;
        actionPtr->type2.userDefinedCpuCode                 = CPSS_NET_FIRST_USER_DEFINED_E + 1;
        actionPtr->type2.bindToCentralCounter               = GT_TRUE;
        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum))
        {
            actionPtr->type2.centralCounterIndex            = 4095;
        }
        else
        {
            actionPtr->type2.centralCounterIndex            = CENTRAL_COUNTER_MAX_CNS;
        }
        actionPtr->type2.vntl2Echo                          = GT_TRUE;
        actionPtr->type2.bridgeBypass                       = GT_TRUE;
        actionPtr->type2.ingressPipeBypass                  = GT_TRUE;
        actionPtr->type2.actionStop                         = GT_TRUE;
        actionPtr->type2.hashMaskIndex                      = BIT_4 - 1;
        actionPtr->type2.modifyMacSa                        = GT_TRUE;
        actionPtr->type2.modifyMacDa                        = GT_FALSE;
        actionPtr->type2.ResetSrcPortGroupId                = GT_TRUE;
        actionPtr->type2.multiPortGroupTtiEnable            = GT_TRUE;

        actionPtr->type2.sourceEPortAssignmentEnable        = GT_TRUE;
        actionPtr->type2.sourceEPort                        = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? _16K -1:BIT_13 -1 ;

        actionPtr->type2.flowId                             = BIT_12 - 1;
        actionPtr->type2.setMacToMe                         = GT_TRUE;
        actionPtr->type2.rxProtectionSwitchEnable           = GT_TRUE;
        actionPtr->type2.rxIsProtectionPath                 = GT_TRUE;
        actionPtr->type2.pwTagMode                          = PRV_CPSS_SIP_5_CHECK_MAC(devNum) ? 
            CPSS_DXCH_TTI_PW_TAG_DISABLED_MODE_E:CPSS_DXCH_TTI_PW_TAG_TAGGED_PW_MODE_E;

        actionPtr->type2.oamTimeStampEnable                 = GT_TRUE;
        actionPtr->type2.oamOffsetIndex                     = 127;
        actionPtr->type2.oamProcessEnable                   = GT_TRUE;
        actionPtr->type2.oamProfile                         = 1;
        actionPtr->type2.oamChannelTypeToOpcodeMappingEnable= GT_TRUE;

        actionPtr->type2.isPtpPacket                        = GT_TRUE;
        actionPtr->type2.ptpTriggerType                     = CPSS_DXCH_TTI_PTP_TRIGGER_TYPE_PTP_OVER_IPV4_UDP_E;
        actionPtr->type2.ptpOffset                          = PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) ? 63 : 127;

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.cwBasedPw                          = GT_TRUE;
        }
        else
        {
            actionPtr->type2.cwBasedPw                          = GT_FALSE;
        }
        actionPtr->type2.ttlExpiryVccvEnable                = GT_TRUE;
        actionPtr->type2.pwe3FlowLabelExist                 = GT_TRUE;
        actionPtr->type2.pwCwBasedETreeEnable               = GT_TRUE;
        actionPtr->type2.applyNonDataCwCommand              = GT_TRUE;

        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
        {
            actionPtr->type2.unknownSaCommandEnable             = GT_TRUE;
            actionPtr->type2.unknownSaCommand                   = CPSS_PACKET_CMD_DROP_SOFT_E;
            actionPtr->type2.sourceMeshIdSetEnable              = GT_TRUE;
            actionPtr->type2.sourceMeshId                       = 3;
        }
        else
        {
            actionPtr->type2.unknownSaCommandEnable             = GT_FALSE;
            actionPtr->type2.unknownSaCommand                   = CPSS_PACKET_CMD_FORWARD_E;
            actionPtr->type2.sourceMeshIdSetEnable              = GT_FALSE;
            actionPtr->type2.sourceMeshId                       = 0;
        }

        break;

    default:
        break;
    }
}

/**
* @internal prvCompareCommonRuleStructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 TTI Rule structures.
*
* @param[in] devNum                   - device number
* @param[in] keyType                  - TTI key type
* @param[in] unionName                - name of tested union objects
* @param[in] unionMemberName          - name of tested union member
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareCommonRuleStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN CPSS_DXCH_TTI_KEY_TYPE_ENT       keyType,
    IN GT_CHAR                          *unionName,
    IN GT_CHAR                          *unionMemberName,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *firstPtr,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *secondPtr
)
{
    GT_STATUS                           st = GT_OK;
    GT_BOOL                             isEqual;

    if(firstPtr->pclId != secondPtr->pclId)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.pclId than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->pclId, secondPtr->pclId);
        st = GT_FAIL;
    }
    if(firstPtr->srcIsTrunk != secondPtr->srcIsTrunk)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.srcIsTrunk than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->srcIsTrunk, secondPtr->srcIsTrunk);
        st = GT_FAIL;
    }

    if ((firstPtr->srcIsTrunk == GT_FALSE) &&
        ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
         (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E && GT_FALSE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum)))
         )
    {
        if ((portGroupId == PORT_GROUP_ID_FROM_GLOBAL_PORT_MAC(devNum,firstPtr->srcPortTrunk)) && (firstPtr->sourcePortGroupId == portGroupId) )
        {
            if(firstPtr->srcPortTrunk != secondPtr->srcPortTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.srcPortTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName,
                                 firstPtr->srcPortTrunk, secondPtr->srcPortTrunk);
                st = GT_FAIL;
            }
        }
        else
        {
            if(CPSS_NULL_PORT_NUM_CNS != secondPtr->srcPortTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.srcPortTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName,
                                 CPSS_NULL_PORT_NUM_CNS, secondPtr->srcPortTrunk);
                st = GT_FAIL;
            }
        }
    }
    else
    {
        if(firstPtr->srcPortTrunk != secondPtr->srcPortTrunk)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.srcPortTrunk than was set, expected = %d, received = %d\n",
                             unionName, unionMemberName,
                             firstPtr->srcPortTrunk, secondPtr->srcPortTrunk);
            st = GT_FAIL;
        }
    }

    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->mac,
                                 (GT_VOID*) &secondPtr->mac,
                                 sizeof(&firstPtr->mac))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG2_MAC("got another %s.%s.mac then was set\n",
                         unionName, unionMemberName);
        st = GT_FAIL;
    }
    if(firstPtr->vid != secondPtr->vid)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.vid than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->vid, secondPtr->vid);
        st = GT_FAIL;
    }

    if (CPSS_DXCH_TTI_KEY_IPV4_E  == keyType || CPSS_DXCH_TTI_KEY_MPLS_E  == keyType || CPSS_DXCH_TTI_KEY_ETH_E   == keyType || CPSS_DXCH_TTI_KEY_MIM_E   == keyType)
    {
        if(firstPtr->isTagged != secondPtr->isTagged)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.isTagged than was set, expected = %d, received = %d\n",
                             unionName, unionMemberName, firstPtr->isTagged,
                             secondPtr->isTagged);
            st = GT_FAIL;
        }
    }
    if(GT_TRUE == firstPtr->isTagged)
    {
        if (CPSS_DXCH_TTI_KEY_IPV4_E  == keyType || CPSS_DXCH_TTI_KEY_MPLS_E  == keyType || CPSS_DXCH_TTI_KEY_ETH_E   == keyType || CPSS_DXCH_TTI_KEY_MIM_E   == keyType)
        {
            if(firstPtr->dsaSrcIsTrunk != secondPtr->dsaSrcIsTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcIsTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName, firstPtr->dsaSrcIsTrunk,
                                 secondPtr->dsaSrcIsTrunk);
                st = GT_FAIL;
            }
            if(firstPtr->dsaSrcPortTrunk != secondPtr->dsaSrcPortTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcPortTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName, firstPtr->dsaSrcPortTrunk,
                                 secondPtr->dsaSrcPortTrunk);
                st = GT_FAIL;
            }
        }
        if(firstPtr->dsaSrcDevice != secondPtr->dsaSrcDevice)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcDevice than was set, expected = %d, received = %d\n",
                             unionName, unionMemberName, firstPtr->dsaSrcDevice,
                             secondPtr->dsaSrcDevice);
            st = GT_FAIL;
        }
    }
    if(CPSS_DXCH_TTI_KEY_MIM_E == keyType)
    {
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            if(firstPtr->sourcePortGroupId != secondPtr->sourcePortGroupId)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.sourcePortGroupId than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName,
                                 firstPtr->sourcePortGroupId, secondPtr->sourcePortGroupId);
                st = GT_FAIL;
            }
        }
    }

    return st;
}


/**
* @internal prvCompareCommonRuleStructs function
* @endinternal
*
* @brief   This routine set compares 2 TTI Rule structures.
*
* @param[in] devNum                   - device number
* @param[in] keyType                  - TTI key type
* @param[in] unionName                - name of tested union objects
* @param[in] unionMemberName          - name of tested union member
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareCommonRuleStructs
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_TTI_KEY_TYPE_ENT       keyType,
    IN GT_CHAR                          *unionName,
    IN GT_CHAR                          *unionMemberName,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *firstPtr,
    IN CPSS_DXCH_TTI_RULE_COMMON_STC    *secondPtr
)
{
    GT_STATUS                           st = GT_OK;
    GT_BOOL                             isEqual;

    if(firstPtr->pclId != secondPtr->pclId)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.pclId than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->pclId, secondPtr->pclId);
        st = GT_FAIL;
    }
    if(firstPtr->srcIsTrunk != secondPtr->srcIsTrunk)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.srcIsTrunk than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->srcIsTrunk, secondPtr->srcIsTrunk);
        st = GT_FAIL;
    }
    if(firstPtr->srcPortTrunk != secondPtr->srcPortTrunk)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.srcPortTrunk than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->srcPortTrunk, secondPtr->srcPortTrunk);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->mac,
                                 (GT_VOID*) &secondPtr->mac,
                                 sizeof(&firstPtr->mac))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG2_MAC("got another %s.%s.mac then was set\n",
                         unionName, unionMemberName);
        st = GT_FAIL;
    }
    if(firstPtr->vid != secondPtr->vid)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.vid than was set, expected = %d, received = %d\n",
                         unionName, unionMemberName,
                         firstPtr->vid, secondPtr->vid);
        st = GT_FAIL;
    }
    if (CPSS_DXCH_TTI_KEY_IPV4_E  == keyType || CPSS_DXCH_TTI_KEY_MPLS_E  == keyType || CPSS_DXCH_TTI_KEY_ETH_E   == keyType || CPSS_DXCH_TTI_KEY_MIM_E   == keyType)
    {
        if(firstPtr->isTagged != secondPtr->isTagged)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.isTagged than was set, expected = %d, received = %d\n",
                             unionName, unionMemberName, firstPtr->isTagged,
                             secondPtr->isTagged);
            st = GT_FAIL;
        }
    }
    if(GT_TRUE == firstPtr->isTagged)
    {
        if (CPSS_DXCH_TTI_KEY_IPV4_E  == keyType || CPSS_DXCH_TTI_KEY_MPLS_E  == keyType || CPSS_DXCH_TTI_KEY_ETH_E   == keyType || CPSS_DXCH_TTI_KEY_MIM_E   == keyType)
        {
            if(firstPtr->dsaSrcIsTrunk != secondPtr->dsaSrcIsTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcIsTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName, firstPtr->dsaSrcIsTrunk,
                                 secondPtr->dsaSrcIsTrunk);
                st = GT_FAIL;
            }
            if(firstPtr->dsaSrcPortTrunk != secondPtr->dsaSrcPortTrunk)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcPortTrunk than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName, firstPtr->dsaSrcPortTrunk,
                                 secondPtr->dsaSrcPortTrunk);
                st = GT_FAIL;
            }
        }
        if(firstPtr->dsaSrcDevice != secondPtr->dsaSrcDevice)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.dsaSrcDevice than was set, expected = %d, received = %d\n",
                             unionName, unionMemberName, firstPtr->dsaSrcDevice,
                             secondPtr->dsaSrcDevice);
            st = GT_FAIL;
        }
    }
    if(CPSS_DXCH_TTI_KEY_MIM_E == keyType)
    {
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            if(firstPtr->sourcePortGroupId != secondPtr->sourcePortGroupId)
            {
                PRV_UTF_LOG4_MAC("get another %s.%s.sourcePortGroupId than was set, expected = %d, received = %d\n",
                                 unionName, unionMemberName,
                                 firstPtr->sourcePortGroupId, secondPtr->sourcePortGroupId);
                st = GT_FAIL;
            }
        }
    }

    return st;
}

/**
* @internal prvCompareIpv4StructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 Ipv4 structures.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - current port group id in loop
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareIpv4StructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *secondPtr
)
{
    GT_STATUS                           st = GT_OK;
    GT_BOOL                             isEqual;

    st = prvCompareCommonRuleStructsPortGroup(devNum, portGroupId, CPSS_DXCH_TTI_KEY_IPV4_E, name,
                                     "ipv4.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->tunneltype != secondPtr->tunneltype)
    {
        PRV_UTF_LOG3_MAC("get another %s.ipv4.tunneltype than was set, expected = %d, received = %d\n",
                         name, firstPtr->tunneltype, secondPtr->tunneltype);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->srcIp,
                                 (GT_VOID*) &secondPtr->srcIp,
                                 sizeof(firstPtr->srcIp))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %s.ipv4.srcIp then was set\n", name);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->destIp,
                                 (GT_VOID*) &secondPtr->destIp,
                                 sizeof(&firstPtr->destIp))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %sipv4.destIp then was set", name);
        st = GT_FAIL;
    }
    if(firstPtr->isArp != secondPtr->isArp)
    {
        PRV_UTF_LOG3_MAC("get another %s.ipv4.isArp than was set, expected = %d, received = %d\n",
                         name, firstPtr->isArp, secondPtr->isArp);
        st = GT_FAIL;
    }

    return st;
}

/**
* @internal prvCompareIpv4Structs function
* @endinternal
*
* @brief   This routine set compares 2 Ipv4 structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareIpv4Structs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_IPV4_RULE_STC      *secondPtr
)
{
    GT_STATUS                           st = GT_OK;
    GT_BOOL                             isEqual;

    st = prvCompareCommonRuleStructs(devNum, CPSS_DXCH_TTI_KEY_IPV4_E, name,
                                     "ipv4.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->tunneltype != secondPtr->tunneltype)
    {
        PRV_UTF_LOG3_MAC("get another %s.ipv4.tunneltype than was set, expected = %d, received = %d\n",
                         name, firstPtr->tunneltype, secondPtr->tunneltype);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->srcIp,
                                 (GT_VOID*) &secondPtr->srcIp,
                                 sizeof(firstPtr->srcIp))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %s.ipv4.srcIp then was set\n", name);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->destIp,
                                 (GT_VOID*) &secondPtr->destIp,
                                 sizeof(&firstPtr->destIp))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %sipv4.destIp then was set", name);
        st = GT_FAIL;
    }
    if(firstPtr->isArp != secondPtr->isArp)
    {
        PRV_UTF_LOG3_MAC("get another %s.ipv4.isArp than was set, expected = %d, received = %d\n",
                         name, firstPtr->isArp, secondPtr->isArp);
        st = GT_FAIL;
    }

    return st;
}

/**
* @internal prvCompareMplsStructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 Mpls structures.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - current port group id in loop
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareMplsStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructsPortGroup(devNum,portGroupId, CPSS_DXCH_TTI_KEY_MPLS_E, name,
                                     "mpls.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->label0 != secondPtr->label0)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label0, secondPtr->label0);
        st = GT_FAIL;
    }
    if(firstPtr->exp0 != secondPtr->exp0)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp0, secondPtr->exp0);
        st = GT_FAIL;
    }
    if(firstPtr->label1 != secondPtr->label1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label1, secondPtr->label1);
        st = GT_FAIL;
    }
    if(firstPtr->exp1 != secondPtr->exp1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp1, secondPtr->exp1);
        st = GT_FAIL;
    }
    if(firstPtr->label2 != secondPtr->label2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label2, secondPtr->label2);
        st = GT_FAIL;
    }
    if(firstPtr->exp2 != secondPtr->exp2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp2, secondPtr->exp2);
        st = GT_FAIL;
    }
    if(firstPtr->numOfLabels != secondPtr->numOfLabels)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.numOfLabels than was set, expected = %d, received = %d\n",
                         name, firstPtr->numOfLabels, secondPtr->numOfLabels);
        st = GT_FAIL;
    }
    if(firstPtr->protocolAboveMPLS != secondPtr->protocolAboveMPLS)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.protocolAboveMPLS than was set, expected = %d, received = %d\n",
                         name, firstPtr->protocolAboveMPLS,
                         secondPtr->protocolAboveMPLS);
        st = GT_FAIL;
    }
    if(
       (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->reservedLabelExist != secondPtr->reservedLabelExist)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.reservedLabelExist than was set, expected = %d, received = %d\n",
                             name, firstPtr->reservedLabelExist,
                             secondPtr->reservedLabelExist);
            st = GT_FAIL;
        }
        if(firstPtr->reservedLabelValue != secondPtr->reservedLabelValue)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.reservedLabelValue than was set, expected = %d, received = %d\n",
                             name, firstPtr->reservedLabelValue,
                             secondPtr->reservedLabelValue);
            st = GT_FAIL;
        }
        if(firstPtr->channelTypeProfile != secondPtr->channelTypeProfile)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.channelTypeProfile than was set, expected = %d, received = %d\n",
                             name, firstPtr->channelTypeProfile,
                             secondPtr->channelTypeProfile);
            st = GT_FAIL;
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        if(firstPtr->cwFirstNibble != secondPtr->cwFirstNibble)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.cwFirstNibble than was set, expected = %d, received = %d\n",
                             name, firstPtr->cwFirstNibble,
                             secondPtr->cwFirstNibble);
            st = GT_FAIL;
        }
    }

    return st;
}

/**
* @internal prvCompareMplsStructs function
* @endinternal
*
* @brief   This routine set compares 2 Mpls structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareMplsStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *firstPtr,
    IN CPSS_DXCH_TTI_MPLS_RULE_STC      *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructs(devNum, CPSS_DXCH_TTI_KEY_MPLS_E, name,
                                     "mpls.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->label0 != secondPtr->label0)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label0, secondPtr->label0);
        st = GT_FAIL;
    }
    if(firstPtr->exp0 != secondPtr->exp0)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp0, secondPtr->exp0);
        st = GT_FAIL;
    }
    if(firstPtr->label1 != secondPtr->label1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label1, secondPtr->label1);
        st = GT_FAIL;
    }
    if(firstPtr->exp1 != secondPtr->exp1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp1, secondPtr->exp1);
        st = GT_FAIL;
    }
    if(firstPtr->label2 != secondPtr->label2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.label2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->label2, secondPtr->label2);
        st = GT_FAIL;
    }
    if(firstPtr->exp2 != secondPtr->exp2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.exp2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->exp2, secondPtr->exp2);
        st = GT_FAIL;
    }
    if(firstPtr->numOfLabels != secondPtr->numOfLabels)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.numOfLabels than was set, expected = %d, received = %d\n",
                         name, firstPtr->numOfLabels, secondPtr->numOfLabels);
        st = GT_FAIL;
    }
    if(firstPtr->protocolAboveMPLS != secondPtr->protocolAboveMPLS)
    {
        PRV_UTF_LOG3_MAC("get another %s.mpls.protocolAboveMPLS than was set, expected = %d, received = %d\n",
                         name, firstPtr->protocolAboveMPLS,
                         secondPtr->protocolAboveMPLS);
        st = GT_FAIL;
    }
    if(
       (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->reservedLabelExist != secondPtr->reservedLabelExist)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.reservedLabelExist than was set, expected = %d, received = %d\n",
                             name, firstPtr->reservedLabelExist,
                             secondPtr->reservedLabelExist);
            st = GT_FAIL;
        }
        if(firstPtr->reservedLabelValue != secondPtr->reservedLabelValue)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.reservedLabelValue than was set, expected = %d, received = %d\n",
                             name, firstPtr->reservedLabelValue,
                             secondPtr->reservedLabelValue);
            st = GT_FAIL;
        }
        if(firstPtr->channelTypeProfile != secondPtr->channelTypeProfile)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.channelTypeProfile than was set, expected = %d, received = %d\n",
                             name, firstPtr->channelTypeProfile,
                             secondPtr->channelTypeProfile);
            st = GT_FAIL;
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        if(firstPtr->cwFirstNibble != secondPtr->cwFirstNibble)
        {
            PRV_UTF_LOG3_MAC("get another %s.mpls.cwFirstNibble than was set, expected = %d, received = %d\n",
                             name, firstPtr->cwFirstNibble,
                             secondPtr->cwFirstNibble);
            st = GT_FAIL;
        }
    }

    return st;
}


/**
* @internal prvCompareEthStructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 Eth structures.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - current  in loop
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareEthStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructsPortGroup(devNum, portGroupId,CPSS_DXCH_TTI_KEY_ETH_E, name,
                                     "eth.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->up0 != secondPtr->up0)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.up0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->up0, secondPtr->up0);
        st = GT_FAIL;
    }
    if(firstPtr->cfi0 != secondPtr->cfi0)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.cfi0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->cfi0, secondPtr->cfi0);
        st = GT_FAIL;
    }
    if(firstPtr->isVlan1Exists != secondPtr->isVlan1Exists)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.isVlan1Exists than was set, expected = %d, received = %d\n",
                         name, firstPtr->isVlan1Exists,
                         secondPtr->isVlan1Exists);
        st = GT_FAIL;
    }
    if(firstPtr->vid1 != secondPtr->vid1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.vid1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->vid1, secondPtr->vid1);
        st = GT_FAIL;
    }
    if(firstPtr->up1 != secondPtr->up1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.up1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->up1, secondPtr->up1);
        st = GT_FAIL;
    }
    if(firstPtr->cfi1 != secondPtr->cfi1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.cfi1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->cfi1, secondPtr->cfi1);
        st = GT_FAIL;
    }
    if(firstPtr->etherType != secondPtr->etherType)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.etherType than was set, expected = %d, received = %d\n",
                         name, firstPtr->etherType, secondPtr->etherType);
        st = GT_FAIL;
    }
    if(firstPtr->macToMe != secondPtr->macToMe)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.macToMe than was set, expected = %d, received = %d\n",
                         name, firstPtr->macToMe, secondPtr->macToMe);
        st = GT_FAIL;
    }
    if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)  ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E) ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E) ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
       (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        if(firstPtr->srcId != secondPtr->srcId)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.srcId than was set, expected = %d, received = %d\n",
                             name, firstPtr->srcId, secondPtr->srcId);
            st = GT_FAIL;
        }
        if(firstPtr->dsaQosProfile != secondPtr->dsaQosProfile)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.dsaQosProfile than was set, expected = %d, received = %d\n",
                             name, firstPtr->dsaQosProfile,
                             secondPtr->dsaQosProfile);
            st = GT_FAIL;
        }

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            if(firstPtr->eTagGrp != secondPtr->eTagGrp)
            {
                PRV_UTF_LOG3_MAC("get another %s.eth.eTagGrp than was set, expected = %d, received = %d\n",
                             name, firstPtr->eTagGrp,
                             secondPtr->eTagGrp);
                st = GT_FAIL;
            }
        }
    }
    if (
       (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->tag0TpidIndex != secondPtr->tag0TpidIndex)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.tag0TpidIndex than was set, expected = %d, received = %d\n",
                             name, firstPtr->tag0TpidIndex,
                             secondPtr->tag0TpidIndex);
            st = GT_FAIL;
        }
        if(firstPtr->tag1TpidIndex != secondPtr->tag1TpidIndex)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.tag1TpidIndex than was set, expected = %d, received = %d\n",
                             name, firstPtr->tag1TpidIndex,
                             secondPtr->tag1TpidIndex);
            st = GT_FAIL;
        }
    }

    return st;
}

/**
* @internal prvCompareEthStructs function
* @endinternal
*
* @brief   This routine set compares 2 Eth structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareEthStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_ETH_RULE_STC       *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructs(devNum, CPSS_DXCH_TTI_KEY_ETH_E, name,
                                     "eth.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->up0 != secondPtr->up0)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.up0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->up0, secondPtr->up0);
        st = GT_FAIL;
    }
    if(firstPtr->cfi0 != secondPtr->cfi0)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.cfi0 than was set, expected = %d, received = %d\n",
                         name, firstPtr->cfi0, secondPtr->cfi0);
        st = GT_FAIL;
    }
    if(firstPtr->isVlan1Exists != secondPtr->isVlan1Exists)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.isVlan1Exists than was set, expected = %d, received = %d\n",
                         name, firstPtr->isVlan1Exists,
                         secondPtr->isVlan1Exists);
        st = GT_FAIL;
    }
    if(firstPtr->vid1 != secondPtr->vid1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.vid1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->vid1, secondPtr->vid1);
        st = GT_FAIL;
    }
    if(firstPtr->up1 != secondPtr->up1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.up1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->up1, secondPtr->up1);
        st = GT_FAIL;
    }
    if(firstPtr->cfi1 != secondPtr->cfi1)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.cfi1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->cfi1, secondPtr->cfi1);
        st = GT_FAIL;
    }
    if(firstPtr->etherType != secondPtr->etherType)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.etherType than was set, expected = %d, received = %d\n",
                         name, firstPtr->etherType, secondPtr->etherType);
        st = GT_FAIL;
    }
    if(firstPtr->macToMe != secondPtr->macToMe)
    {
        PRV_UTF_LOG3_MAC("get another %s.eth.macToMe than was set, expected = %d, received = %d\n",
                         name, firstPtr->macToMe, secondPtr->macToMe);
        st = GT_FAIL;
    }
    if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)  ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E) ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E) ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
       (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        if(firstPtr->srcId != secondPtr->srcId)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.srcId than was set, expected = %d, received = %d\n",
                             name, firstPtr->srcId, secondPtr->srcId);
            st = GT_FAIL;
        }
        if(firstPtr->dsaQosProfile != secondPtr->dsaQosProfile)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.dsaQosProfile than was set, expected = %d, received = %d\n",
                             name, firstPtr->dsaQosProfile,
                             secondPtr->dsaQosProfile);
            st = GT_FAIL;
        }

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            if(firstPtr->eTagGrp != secondPtr->eTagGrp)
            {
                PRV_UTF_LOG3_MAC("get another %s.eth.eTagGrp than was set, expected = %d, received = %d\n",
                             name, firstPtr->eTagGrp,
                             secondPtr->eTagGrp);
                st = GT_FAIL;
            }
        }
    }
    if (
       (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->tag0TpidIndex != secondPtr->tag0TpidIndex)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.tag0TpidIndex than was set, expected = %d, received = %d\n",
                             name, firstPtr->tag0TpidIndex,
                             secondPtr->tag0TpidIndex);
            st = GT_FAIL;
        }
        if(firstPtr->tag1TpidIndex != secondPtr->tag1TpidIndex)
        {
            PRV_UTF_LOG3_MAC("get another %s.eth.tag1TpidIndex than was set, expected = %d, received = %d\n",
                             name, firstPtr->tag1TpidIndex,
                             secondPtr->tag1TpidIndex);
            st = GT_FAIL;
        }
    }

    return st;
}

/**
* @internal prvCompareMimStructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 Mim structures.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - current  in loop
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareMimStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *secondPtr
)
{

    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructsPortGroup(devNum, portGroupId, CPSS_DXCH_TTI_KEY_MIM_E, name,
                                     "mim.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->bUp != secondPtr->bUp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.bUp than was set, expected = %d, received = %d\n",
                         name, firstPtr->bUp, secondPtr->bUp);
        st = GT_FAIL;
    }
    if(firstPtr->bDp != secondPtr->bDp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.bDp than was set, expected = %d, received = %d\n",
                         name, firstPtr->bDp, secondPtr->bDp);
        st = GT_FAIL;
    }
    if(firstPtr->iSid != secondPtr->iSid)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iSid than was set, expected = %d, received = %d\n",
                         name, firstPtr->iSid, secondPtr->iSid);
        st = GT_FAIL;
    }
    if(firstPtr->iUp != secondPtr->iUp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iUp than was set, expected = %d, received = %d\n",
                         name, firstPtr->iUp, secondPtr->iUp);
        st = GT_FAIL;
    }
    if(firstPtr->iDp != secondPtr->iDp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iDp than was set, expected = %d, received = %d\n",
                         name, firstPtr->iDp, secondPtr->iDp);
        st = GT_FAIL;
    }
    if(firstPtr->iRes1 != secondPtr->iRes1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iRes1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->iRes1, secondPtr->iRes1);
        st = GT_FAIL;
    }
    if(firstPtr->iRes2 != secondPtr->iRes2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iRes2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->iRes2, secondPtr->iRes2);
        st = GT_FAIL;
    }
    if (
        (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->macToMe != secondPtr->macToMe)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.macToMe than was set, expected = %d, received = %d\n",
                             name, firstPtr->macToMe, secondPtr->macToMe);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagExists != secondPtr->passengerPacketOuterTagExists)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagExists than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagExists,
                             secondPtr->passengerPacketOuterTagExists);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagVid != secondPtr->passengerPacketOuterTagVid)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagVid than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagVid,
                             secondPtr->passengerPacketOuterTagVid);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagUp != secondPtr->passengerPacketOuterTagUp)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagUp than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagUp,
                             secondPtr->passengerPacketOuterTagUp);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagDei != secondPtr->passengerPacketOuterTagDei)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagDei than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagDei,
                             secondPtr->passengerPacketOuterTagDei);
            st = GT_FAIL;
        }
    }

    return st;
}

/**
* @internal prvCompareMimStructs function
* @endinternal
*
* @brief   This routine set compares 2 Mim structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareMimStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *firstPtr,
    IN CPSS_DXCH_TTI_MIM_RULE_STC       *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    st = prvCompareCommonRuleStructs(devNum, CPSS_DXCH_TTI_KEY_MIM_E, name,
                                     "mim.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->bUp != secondPtr->bUp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.bUp than was set, expected = %d, received = %d\n",
                         name, firstPtr->bUp, secondPtr->bUp);
        st = GT_FAIL;
    }
    if(firstPtr->bDp != secondPtr->bDp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.bDp than was set, expected = %d, received = %d\n",
                         name, firstPtr->bDp, secondPtr->bDp);
        st = GT_FAIL;
    }
    if(firstPtr->iSid != secondPtr->iSid)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iSid than was set, expected = %d, received = %d\n",
                         name, firstPtr->iSid, secondPtr->iSid);
        st = GT_FAIL;
    }
    if(firstPtr->iUp != secondPtr->iUp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iUp than was set, expected = %d, received = %d\n",
                         name, firstPtr->iUp, secondPtr->iUp);
        st = GT_FAIL;
    }
    if(firstPtr->iDp != secondPtr->iDp)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iDp than was set, expected = %d, received = %d\n",
                         name, firstPtr->iDp, secondPtr->iDp);
        st = GT_FAIL;
    }
    if(firstPtr->iRes1 != secondPtr->iRes1)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iRes1 than was set, expected = %d, received = %d\n",
                         name, firstPtr->iRes1, secondPtr->iRes1);
        st = GT_FAIL;
    }
    if(firstPtr->iRes2 != secondPtr->iRes2)
    {
        PRV_UTF_LOG3_MAC("get another %s.mim.iRes2 than was set, expected = %d, received = %d\n",
                         name, firstPtr->iRes2, secondPtr->iRes2);
        st = GT_FAIL;
    }
    if (
        (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)))
    {
        if(firstPtr->macToMe != secondPtr->macToMe)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.macToMe than was set, expected = %d, received = %d\n",
                             name, firstPtr->macToMe, secondPtr->macToMe);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagExists != secondPtr->passengerPacketOuterTagExists)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagExists than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagExists,
                             secondPtr->passengerPacketOuterTagExists);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagVid != secondPtr->passengerPacketOuterTagVid)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagVid than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagVid,
                             secondPtr->passengerPacketOuterTagVid);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagUp != secondPtr->passengerPacketOuterTagUp)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagUp than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagUp,
                             secondPtr->passengerPacketOuterTagUp);
            st = GT_FAIL;
        }
        if(firstPtr->passengerPacketOuterTagDei != secondPtr->passengerPacketOuterTagDei)
        {
            PRV_UTF_LOG3_MAC("get another %s.mim.passengerPacketOuterTagDei than was set, expected = %d, received = %d\n",
                             name, firstPtr->passengerPacketOuterTagDei,
                             secondPtr->passengerPacketOuterTagDei);
            st = GT_FAIL;
        }
    }

    return st;
}
/* TBD TRILL */
#if 0
/**
* @internal prvCompareTrillStructsPortGroup function
* @endinternal
*
* @brief   This routine set compares 2 Trill structures.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - current  in loop
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareTrillStructsPortGroup
(
    IN GT_U8                            devNum,
    IN GT_U32                           portGroupId,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *firstPtr,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *secondPtr
)
{
    GT_STATUS                           st;
    GT_BOOL                             isEqual;
/* TBD TRILL */
    st = GT_OK;
    isEqual = GT_FALSE;
#if 0
    st = prvCompareCommonRuleStructsPortGroup(devNum, portGroupId, CPSS_DXCH_TTI_KEY_TRILL_E, name,
                                     "trill.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->trillMBit != secondPtr->trillMBit)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillMBit than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillMBit, secondPtr->trillMBit);
        st = GT_FAIL;
    }
    if(firstPtr->trillEgressRbid != secondPtr->trillEgressRbid)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillEgressRbid than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillEgressRbid,
                         secondPtr->trillEgressRbid);
        st = GT_FAIL;
    }
    if(firstPtr->trillIngressRbid != secondPtr->trillIngressRbid)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillIngressRbid than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillIngressRbid,
                         secondPtr->trillIngressRbid);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->innerPacketMacDa,
                                 (GT_VOID*) &secondPtr->innerPacketMacDa,
                                 sizeof(&firstPtr->innerPacketMacDa))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %s.trill.innerPacketMacDa then was set\n",
                         name);
        st = GT_FAIL;
    }
    if(firstPtr->innerPacketTag0Exists != secondPtr->innerPacketTag0Exists)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketTag0Exists than was set, expected = %d, received = %d\n",
                         name, firstPtr->innerPacketTag0Exists,
                         secondPtr->innerPacketTag0Exists);
        st = GT_FAIL;
    }
    if(GT_TRUE == firstPtr->innerPacketTag0Exists)
    {
        if(firstPtr->innerPacketTag0Vid != secondPtr->innerPacketTag0Vid)
        {
            PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketTag0Vid than was set, expected = %d, received = %d\n",
                             name, firstPtr->innerPacketTag0Vid,
                             secondPtr->innerPacketTag0Vid);
            st = GT_FAIL;
        }
        if(firstPtr->innerPacketFieldsAreValid != secondPtr->innerPacketFieldsAreValid)
        {
            PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketFieldsAreValid than was set, expected = %d, received = %d\n",
                             name, firstPtr->innerPacketFieldsAreValid,
                             secondPtr->innerPacketFieldsAreValid);
            st = GT_FAIL;
        }
    }
    if(firstPtr->trillMcDescriptorInstance != secondPtr->trillMcDescriptorInstance)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillMcDescriptorInstance than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillMcDescriptorInstance,
                         secondPtr->trillMcDescriptorInstance);
        st = GT_FAIL;
    }

    return st;
#endif
}


/**
* @internal prvCompareTrillStructs function
* @endinternal
*
* @brief   This routine set compares 2 Trill structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareTrillStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *firstPtr,
    IN CPSS_DXCH_TTI_TRILL_RULE_STC     *secondPtr
)
{
    GT_STATUS                           st;
    GT_BOOL                             isEqual;
/* TBD TRILL*/
    st = GT_OK;
    isEqual = GT_FALSE;
#if 0
    st = prvCompareCommonRuleStructs(devNum, CPSS_DXCH_TTI_KEY_TRILL_E, name,
                                     "trill.common", &firstPtr->common,
                                     &secondPtr->common);

    if(firstPtr->trillMBit != secondPtr->trillMBit)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillMBit than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillMBit, secondPtr->trillMBit);
        st = GT_FAIL;
    }
    if(firstPtr->trillEgressRbid != secondPtr->trillEgressRbid)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillEgressRbid than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillEgressRbid,
                         secondPtr->trillEgressRbid);
        st = GT_FAIL;
    }
    if(firstPtr->trillIngressRbid != secondPtr->trillIngressRbid)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillIngressRbid than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillIngressRbid,
                         secondPtr->trillIngressRbid);
        st = GT_FAIL;
    }
    isEqual = (0 == cpssOsMemCmp((GT_VOID*) &firstPtr->innerPacketMacDa,
                                 (GT_VOID*) &secondPtr->innerPacketMacDa,
                                 sizeof(&firstPtr->innerPacketMacDa))) ? GT_TRUE : GT_FALSE;
    if(GT_TRUE != isEqual)
    {
        PRV_UTF_LOG1_MAC("got another %s.trill.innerPacketMacDa then was set\n",
                         name);
        st = GT_FAIL;
    }
    if(firstPtr->innerPacketTag0Exists != secondPtr->innerPacketTag0Exists)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketTag0Exists than was set, expected = %d, received = %d\n",
                         name, firstPtr->innerPacketTag0Exists,
                         secondPtr->innerPacketTag0Exists);
        st = GT_FAIL;
    }
    if(GT_TRUE == firstPtr->innerPacketTag0Exists)
    {
        if(firstPtr->innerPacketTag0Vid != secondPtr->innerPacketTag0Vid)
        {
            PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketTag0Vid than was set, expected = %d, received = %d\n",
                             name, firstPtr->innerPacketTag0Vid,
                             secondPtr->innerPacketTag0Vid);
            st = GT_FAIL;
        }
        if(firstPtr->innerPacketFieldsAreValid != secondPtr->innerPacketFieldsAreValid)
        {
            PRV_UTF_LOG3_MAC("get another %s.trill.innerPacketFieldsAreValid than was set, expected = %d, received = %d\n",
                             name, firstPtr->innerPacketFieldsAreValid,
                             secondPtr->innerPacketFieldsAreValid);
            st = GT_FAIL;
        }
    }
    if(firstPtr->trillMcDescriptorInstance != secondPtr->trillMcDescriptorInstance)
    {
        PRV_UTF_LOG3_MAC("get another %s.trill.trillMcDescriptorInstance than was set, expected = %d, received = %d\n",
                         name, firstPtr->trillMcDescriptorInstance,
                         secondPtr->trillMcDescriptorInstance);
        st = GT_FAIL;
    }

    return st;
#endif
}
#endif
/**
* @internal prvCompareInterfaceInfoStructs function
* @endinternal
*
* @brief   This routine set compares 2 Interface info structures.
*
* @param[in] actionName               - name of tested action structs
* @param[in] interfaceInfoName        - name of interface member structs
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareInterfaceInfoStructs
(
    IN GT_CHAR                          *actionName,
    IN GT_CHAR                          *interfaceInfoName,
    IN CPSS_INTERFACE_INFO_STC          *firstPtr,
    IN CPSS_INTERFACE_INFO_STC          *secondPtr
)
{
    GT_STATUS                           st = GT_OK;

    if(firstPtr->type != secondPtr->type)
    {
        PRV_UTF_LOG4_MAC("get another %s.%s.type than was set, expected = %d, received = %d\n",
                         actionName, interfaceInfoName, firstPtr->type,
                         secondPtr->type);
        st = GT_FAIL;
    }

    switch(firstPtr->type)
    {
    case CPSS_INTERFACE_PORT_E:
        if(firstPtr->devPort.hwDevNum != secondPtr->devPort.hwDevNum)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.devPort.hwDevNum than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->devPort.hwDevNum, secondPtr->devPort.hwDevNum);
            st = GT_FAIL;
        }
        if(firstPtr->devPort.portNum != secondPtr->devPort.portNum)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.devPort.portNum than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->devPort.portNum, secondPtr->devPort.portNum);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_TRUNK_E:
        if(firstPtr->trunkId != secondPtr->trunkId)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.trunkId than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->trunkId, secondPtr->trunkId);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_VIDX_E:
        if(firstPtr->vidx != secondPtr->vidx)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.vidx than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->vidx, secondPtr->vidx);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_VID_E:
        if(firstPtr->vlanId != secondPtr->vlanId)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.vlanId than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->vlanId, secondPtr->vlanId);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_DEVICE_E:
        if(firstPtr->hwDevNum != secondPtr->hwDevNum)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.hwDevNum than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->hwDevNum, secondPtr->hwDevNum);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_FABRIC_VIDX_E:
        if(firstPtr->fabricVidx != secondPtr->fabricVidx)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.fabricVidx than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->fabricVidx, secondPtr->fabricVidx);
            st = GT_FAIL;
        }
        break;

    case CPSS_INTERFACE_INDEX_E:
        if(firstPtr->index != secondPtr->index)
        {
            PRV_UTF_LOG4_MAC("get another %s.%s.index than was set, expected = %d, received = %d\n",
                             actionName, interfaceInfoName,
                             firstPtr->index, secondPtr->index);
            st = GT_FAIL;
        }
        break;

    default:
        break;
    }

    return st;
}

/**
* @internal prvCompareActionStructs function
* @endinternal
*
* @brief   This routine set compares 2 Action structures.
*
* @param[in] devNum                   - device number
* @param[in] name                     -  of tested sctucts objects
* @param[in] actionType               - type of the action to use
* @param[in] firstPtr                 - (pointer to) first struct
* @param[in] secondPtr                - (pointer to) second struct
*/
static GT_STATUS prvCompareActionStructs
(
    IN GT_U8                            devNum,
    IN GT_CHAR                          *name,
    IN CPSS_DXCH_TTI_ACTION_TYPE_ENT    actionType,
    IN CPSS_DXCH_TTI_ACTION_UNT         *firstPtr,
    IN CPSS_DXCH_TTI_ACTION_UNT         *secondPtr
)
{
    GT_STATUS                           st = GT_OK, op_st;

    switch(actionType)
    {
    case CPSS_DXCH_TTI_ACTION_TYPE2_ENT:
        if(firstPtr->type2.tunnelTerminate != secondPtr->type2.tunnelTerminate)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tunnelTerminate than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tunnelTerminate,
                             secondPtr->type2.tunnelTerminate);
            st = GT_FAIL;
        }
        if(firstPtr->type2.ttPassengerPacketType != secondPtr->type2.ttPassengerPacketType)
        {
            if(((CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E == firstPtr->type2.mplsCommand) ||
                (CPSS_DXCH_TTI_MPLS_POP1_CMD_E == firstPtr->type2.mplsCommand)  ||
                (CPSS_DXCH_TTI_MPLS_POP2_CMD_E == firstPtr->type2.mplsCommand)  ||
                (CPSS_DXCH_TTI_MPLS_POP3_CMD_E == firstPtr->type2.mplsCommand)  ||
                (CPSS_DXCH_TTI_MPLS_POP_AND_SWAP_CMD_E == firstPtr->type2.mplsCommand)) &&
               (CPSS_DXCH_TTI_PASSENGER_MPLS_E != firstPtr->type2.ttPassengerPacketType))
            {
                PRV_UTF_LOG1_MAC("error in test, %s.type2.ttPassengerPacketType is invalid\n",
                                 name);
            }

            PRV_UTF_LOG3_MAC("get another %s.type2.ttPassengerPacketType than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.ttPassengerPacketType,
                             secondPtr->type2.ttPassengerPacketType);
            st = GT_FAIL;
        }
        if((CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E == firstPtr->type2.redirectCommand) &&
           (GT_TRUE == firstPtr->type2.tunnelStart))
        {
            if(firstPtr->type2.tsPassengerPacketType != secondPtr->type2.tsPassengerPacketType)
            {
                if(((CPSS_DXCH_TTI_MPLS_PUSH1_CMD_E == firstPtr->type2.mplsCommand) ||
                    (CPSS_DXCH_TTI_MPLS_POP1_CMD_E == firstPtr->type2.mplsCommand)  ||
                    (CPSS_DXCH_TTI_MPLS_POP2_CMD_E == firstPtr->type2.mplsCommand)  ||
                    (CPSS_DXCH_TTI_MPLS_POP3_CMD_E == firstPtr->type2.mplsCommand)  ||
                    (CPSS_DXCH_TTI_MPLS_POP_AND_SWAP_CMD_E == firstPtr->type2.mplsCommand)) &&
                   (CPSS_DXCH_TUNNEL_PASSENGER_OTHER_E != firstPtr->type2.tsPassengerPacketType))
                {
                    PRV_UTF_LOG1_MAC("error in test, %s.type2.tsPassengerPacketType is invalid\n",
                                     name);
                }

                PRV_UTF_LOG3_MAC("get another %s.type2.tsPassengerPacketType than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.tsPassengerPacketType,
                                 secondPtr->type2.tsPassengerPacketType);
                st = GT_FAIL;
            }
        }

        if(firstPtr->type2.copyTtlExpFromTunnelHeader != secondPtr->type2.copyTtlExpFromTunnelHeader)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.copyTtlExpFromTunnelHeader than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.copyTtlExpFromTunnelHeader,
                             secondPtr->type2.copyTtlExpFromTunnelHeader);
            st = GT_FAIL;
        }

        if(firstPtr->type2.mplsCommand != secondPtr->type2.mplsCommand)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.mplsCommand than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.mplsCommand,
                             secondPtr->type2.mplsCommand);
            st = GT_FAIL;
        }
        if(CPSS_DXCH_TTI_MPLS_NOP_CMD_E != firstPtr->type2.mplsCommand)
        {
            if(firstPtr->type2.mplsTtl != secondPtr->type2.mplsTtl)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.mplsTtl than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.mplsTtl, secondPtr->type2.mplsTtl);
                st = GT_FAIL;
            }
            if(firstPtr->type2.enableDecrementTtl != secondPtr->type2.enableDecrementTtl)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.enableDecrementTtl than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.enableDecrementTtl,
                                 secondPtr->type2.enableDecrementTtl);
                st = GT_FAIL;
            }
        }

        if(firstPtr->type2.command != secondPtr->type2.command)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.command than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.command,
                             secondPtr->type2.command);
            st = GT_FAIL;
        }

        if(firstPtr->type2.redirectCommand != secondPtr->type2.redirectCommand)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.redirectCommand than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.redirectCommand,
                             secondPtr->type2.redirectCommand);
            st = GT_FAIL;
        }
        if(CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E == firstPtr->type2.redirectCommand)
        {
            op_st = prvCompareInterfaceInfoStructs(name,
                                                   "type2.egressInterface",
                                                   &firstPtr->type2.egressInterface,
                                                   &secondPtr->type2.egressInterface);
            st = GT_OK != op_st ? op_st: st;
            if(firstPtr->type2.arpPtr != secondPtr->type2.arpPtr)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.arpPtr than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.arpPtr,
                                 secondPtr->type2.arpPtr);
                st = GT_FAIL;
            }
            if(firstPtr->type2.tunnelStart != secondPtr->type2.tunnelStart)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.tunnelStart than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.tunnelStart,
                                 secondPtr->type2.tunnelStart);
                st = GT_FAIL;
            }
            if(firstPtr->type2.tunnelStartPtr != secondPtr->type2.tunnelStartPtr)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.tunnelStartPtr than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.tunnelStartPtr,
                                 secondPtr->type2.tunnelStartPtr);
                st = GT_FAIL;
            }
        }
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)  ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E) ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            if(CPSS_DXCH_TTI_REDIRECT_TO_ROUTER_LOOKUP_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.routerLttPtr != secondPtr->type2.routerLttPtr)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.routerLttPtr than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.routerLttPtr,
                                     secondPtr->type2.routerLttPtr);
                    st = GT_FAIL;
                }
            }
            if(CPSS_DXCH_TTI_VRF_ID_ASSIGN_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.vrfId != secondPtr->type2.vrfId)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.vrfId than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.vrfId,
                                     secondPtr->type2.vrfId);
                    st = GT_FAIL;
                }
            }
        }

        if(firstPtr->type2.sourceIdSetEnable != secondPtr->type2.sourceIdSetEnable)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.sourceIdSetEnable than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.sourceIdSetEnable,
                             secondPtr->type2.sourceIdSetEnable);
            st = GT_FAIL;
        }
        if (firstPtr->type2.sourceIdSetEnable == GT_TRUE)
        {
            if(firstPtr->type2.sourceId != secondPtr->type2.sourceId)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.sourceId than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.sourceId,
                                 secondPtr->type2.sourceId);
                st = GT_FAIL;
            }
        }

        if(firstPtr->type2.tag0VlanCmd != secondPtr->type2.tag0VlanCmd)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag0VlanCmd than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag0VlanCmd,
                             secondPtr->type2.tag0VlanCmd);
            st = GT_FAIL;
        }
        if(firstPtr->type2.tag0VlanId != secondPtr->type2.tag0VlanId)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag0VlanId than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag0VlanId,
                             secondPtr->type2.tag0VlanId);
            st = GT_FAIL;
        }
        if(CPSS_DXCH_TTI_MPLS_NOP_CMD_E == firstPtr->type2.mplsCommand)
        {
            if(firstPtr->type2.tag1VlanCmd != secondPtr->type2.tag1VlanCmd)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.tag1VlanCmd than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.tag1VlanCmd,
                                 secondPtr->type2.tag1VlanCmd);
                st = GT_FAIL;
            }
            if(firstPtr->type2.tag1VlanId != secondPtr->type2.tag1VlanId)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.tag1VlanId than was set, expected = %d, received = %d\n",
                            name, firstPtr->type2.tag1VlanId,
                            secondPtr->type2.tag1VlanId);
                st = GT_FAIL;
            }
        }
        if(firstPtr->type2.tag0VlanPrecedence != secondPtr->type2.tag0VlanPrecedence)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag0VlanPrecedence than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag0VlanPrecedence,
                             secondPtr->type2.tag0VlanPrecedence);
            st = GT_FAIL;
        }
        if(firstPtr->type2.nestedVlanEnable != secondPtr->type2.nestedVlanEnable)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.nestedVlanEnable than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.nestedVlanEnable,
                             secondPtr->type2.nestedVlanEnable);
            st = GT_FAIL;
        }

        if(firstPtr->type2.bindToPolicerMeter != secondPtr->type2.bindToPolicerMeter)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.bindToPolicerMeter than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.bindToPolicerMeter,
                             secondPtr->type2.bindToPolicerMeter);
            st = GT_FAIL;
        }
        if(firstPtr->type2.bindToPolicer != secondPtr->type2.bindToPolicer)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.bindToPolicer than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.bindToPolicer,
                             secondPtr->type2.bindToPolicer);
            st = GT_FAIL;
        }
        if (GT_TRUE == firstPtr->type2.bindToPolicer)
        {
            if(firstPtr->type2.policerIndex != secondPtr->type2.policerIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.policerIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.policerIndex,
                                 secondPtr->type2.policerIndex);
                st = GT_FAIL;
            }
        }

        if(firstPtr->type2.qosPrecedence != secondPtr->type2.qosPrecedence)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.qosPrecedence than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.qosPrecedence,
                             secondPtr->type2.qosPrecedence);
            st = GT_FAIL;
        }
        if(firstPtr->type2.keepPreviousQoS != secondPtr->type2.keepPreviousQoS)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.keepPreviousQoS than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.keepPreviousQoS,
                             secondPtr->type2.keepPreviousQoS);
            st = GT_FAIL;
        }
        if (GT_FALSE == firstPtr->type2.keepPreviousQoS)
        {
            if(firstPtr->type2.trustUp != secondPtr->type2.trustUp)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.trustUp than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.trustUp,
                                 secondPtr->type2.trustUp);
                st = GT_FAIL;
            }
            if(firstPtr->type2.trustDscp != secondPtr->type2.trustDscp)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.trustDscp than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.trustDscp,
                                 secondPtr->type2.trustDscp);
                st = GT_FAIL;
            }
            if(firstPtr->type2.trustExp != secondPtr->type2.trustExp)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.trustExp than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.trustExp,
                                 secondPtr->type2.trustExp);
                st = GT_FAIL;
            }

            if(firstPtr->type2.qosProfile != secondPtr->type2.qosProfile)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.qosProfile than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.qosProfile,
                                 secondPtr->type2.qosProfile);
                st = GT_FAIL;
            }
        }
        if(firstPtr->type2.modifyTag0Up != secondPtr->type2.modifyTag0Up)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.modifyTag0Up than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.modifyTag0Up,
                             secondPtr->type2.modifyTag0Up);
            st = GT_FAIL;
        }
        if(firstPtr->type2.tag1UpCommand != secondPtr->type2.tag1UpCommand)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag1UpCommand than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag1UpCommand,
                             secondPtr->type2.tag1UpCommand);
            st = GT_FAIL;
        }
        if(firstPtr->type2.modifyDscp != secondPtr->type2.modifyDscp)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.modifyDscp than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.modifyDscp,
                             secondPtr->type2.modifyDscp);
            st = GT_FAIL;
        }
        if(firstPtr->type2.tag0Up != secondPtr->type2.tag0Up)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag0Up than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag0Up,
                             secondPtr->type2.tag0Up);
            st = GT_FAIL;
        }
        if(firstPtr->type2.tag1Up != secondPtr->type2.tag1Up)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.tag1Up than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.tag1Up,
                             secondPtr->type2.tag1Up);
            st = GT_FAIL;
        }
        if(firstPtr->type2.remapDSCP != secondPtr->type2.remapDSCP)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.remapDSCP than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.remapDSCP,
                             secondPtr->type2.remapDSCP);
            st = GT_FAIL;
        }

        if(CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E != firstPtr->type2.redirectCommand)
        {
            if(firstPtr->type2.pcl0OverrideConfigIndex != secondPtr->type2.pcl0OverrideConfigIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.pcl0OverrideConfigIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.pcl0OverrideConfigIndex,
                                 secondPtr->type2.pcl0OverrideConfigIndex);
                st = GT_FAIL;
            }
            if(firstPtr->type2.pcl0_1OverrideConfigIndex != secondPtr->type2.pcl0_1OverrideConfigIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.pcl0_1OverrideConfigIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.pcl0_1OverrideConfigIndex,
                                 secondPtr->type2.pcl0_1OverrideConfigIndex);
                st = GT_FAIL;
            }
            if(firstPtr->type2.pcl1OverrideConfigIndex != secondPtr->type2.pcl1OverrideConfigIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.pcl1OverrideConfigIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.pcl1OverrideConfigIndex,
                                 secondPtr->type2.pcl1OverrideConfigIndex);
                st = GT_FAIL;
            }
            if(firstPtr->type2.iPclConfigIndex != secondPtr->type2.iPclConfigIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.iPclConfigIndex than was set, expected = %d, received = %d\n",
                            name, firstPtr->type2.iPclConfigIndex,
                            secondPtr->type2.iPclConfigIndex);
                st = GT_FAIL;
            }
        }

        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            if(firstPtr->type2.mirrorToIngressAnalyzerEnable != secondPtr->type2.mirrorToIngressAnalyzerEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.mirrorToIngressAnalyzerEnable than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.mirrorToIngressAnalyzerEnable,
                                 secondPtr->type2.mirrorToIngressAnalyzerEnable);
                st = GT_FAIL;
            }
        }
        if(GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            if(firstPtr->type2.mirrorToIngressAnalyzerIndex != secondPtr->type2.mirrorToIngressAnalyzerIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.mirrorToIngressAnalyzerIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.mirrorToIngressAnalyzerIndex,
                                 secondPtr->type2.mirrorToIngressAnalyzerIndex);
                st = GT_FAIL;
            }
        }
        if((CPSS_PACKET_CMD_MIRROR_TO_CPU_E == firstPtr->type2.command) ||
           (CPSS_PACKET_CMD_TRAP_TO_CPU_E == firstPtr->type2.command))
        {
            if(firstPtr->type2.userDefinedCpuCode != secondPtr->type2.userDefinedCpuCode)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.userDefinedCpuCode than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.userDefinedCpuCode,
                                 secondPtr->type2.userDefinedCpuCode);
                st = GT_FAIL;
            }
        }
        if(firstPtr->type2.bindToCentralCounter != secondPtr->type2.bindToCentralCounter)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.bindToCentralCounter than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.bindToCentralCounter,
                             secondPtr->type2.bindToCentralCounter);
            st = GT_FAIL;
        }
        if(GT_TRUE == firstPtr->type2.bindToCentralCounter)
        {
            if(firstPtr->type2.centralCounterIndex != secondPtr->type2.centralCounterIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.centralCounterIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.centralCounterIndex,
                                 secondPtr->type2.centralCounterIndex);
                st = GT_FAIL;
            }
        }
        if(CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E == firstPtr->type2.redirectCommand)
        {
            if(firstPtr->type2.vntl2Echo != secondPtr->type2.vntl2Echo)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.vntl2Echo than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.vntl2Echo,
                                 secondPtr->type2.vntl2Echo);
                st = GT_FAIL;
            }
        }
        if(firstPtr->type2.bridgeBypass != secondPtr->type2.bridgeBypass)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.bridgeBypass than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.bridgeBypass,
                             secondPtr->type2.bridgeBypass);
            st = GT_FAIL;
        }
        if(firstPtr->type2.ingressPipeBypass != secondPtr->type2.ingressPipeBypass)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.ingressPipeBypass than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.ingressPipeBypass,
                             secondPtr->type2.ingressPipeBypass);
            st = GT_FAIL;
        }
        if(firstPtr->type2.actionStop != secondPtr->type2.actionStop)
        {
            PRV_UTF_LOG3_MAC("get another %s.type2.actionStop than was set, expected = %d, received = %d\n",
                             name, firstPtr->type2.actionStop,
                             secondPtr->type2.actionStop);
            st = GT_FAIL;
        }
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)  ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E) ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            if(firstPtr->type2.hashMaskIndex != secondPtr->type2.hashMaskIndex)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.hashMaskIndex than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.hashMaskIndex,
                                 secondPtr->type2.hashMaskIndex);
                st = GT_FAIL;
            }
            if(CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.modifyMacSa != secondPtr->type2.modifyMacSa)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.modifyMacSa than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.modifyMacSa,
                                     secondPtr->type2.modifyMacSa);
                    st = GT_FAIL;
                }

                if(firstPtr->type2.modifyMacDa != secondPtr->type2.modifyMacDa)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.modifyMacDa than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.modifyMacDa,
                                     secondPtr->type2.modifyMacDa);
                    st = GT_FAIL;
                }
            }
        }
        if(GT_TRUE == PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum) && /* in multi-core */
            GT_FALSE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))/* not in e_arch */
        {
            if(CPSS_DXCH_TTI_REDIRECT_TO_EGRESS_E != firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.ResetSrcPortGroupId != secondPtr->type2.ResetSrcPortGroupId)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.ResetSrcPortGroupId than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.ResetSrcPortGroupId,
                                     secondPtr->type2.ResetSrcPortGroupId);
                    st = GT_FAIL;
                }
            }

            if(CPSS_DXCH_TTI_NO_REDIRECT_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.multiPortGroupTtiEnable != secondPtr->type2.multiPortGroupTtiEnable)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.multiPortGroupTtiEnable than was set, expected = %d, received = %d\n",
                                     name, firstPtr->type2.multiPortGroupTtiEnable,
                                     secondPtr->type2.multiPortGroupTtiEnable);
                    st = GT_FAIL;
                }
            }
        }

        if (
           (GT_TRUE == UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum)))
        {
            if(firstPtr->type2.sourceEPortAssignmentEnable != secondPtr->type2.sourceEPortAssignmentEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.sourceEPortAssignmentEnable than was set, expected = %d, received = %d\n",
                                 name, firstPtr->type2.sourceEPortAssignmentEnable,
                                 secondPtr->type2.sourceEPortAssignmentEnable);
                st = GT_FAIL;
            }
            if(GT_TRUE == firstPtr->type2.sourceEPortAssignmentEnable)
            {
                if(firstPtr->type2.sourceEPort != secondPtr->type2.sourceEPort)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.sourceEPort than was set, expected = %d, received = %d",
                                     name, firstPtr->type2.sourceEPort,
                                     secondPtr->type2.sourceEPort);
                    st = GT_FAIL;
                }
            }
        }
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if(firstPtr->type2.cwBasedPw   != secondPtr->type2.cwBasedPw)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.cwBasedPw   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.cwBasedPw,
                                                 secondPtr->type2.cwBasedPw);
                st = GT_FAIL;
            }
        }
        if(GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
        {
            if((GT_TRUE == firstPtr->type2.tunnelTerminate) ||
              (CPSS_DXCH_TTI_PASSENGER_MPLS_E != firstPtr->type2.ttPassengerPacketType))
            {
                if(firstPtr->type2.ttHeaderLength != secondPtr->type2.ttHeaderLength)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.ttHeaderLength than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.ttHeaderLength,
                                                     secondPtr->type2.ttHeaderLength);
                    st = GT_FAIL;
                }
            }

            if(firstPtr->type2.continueToNextTtiLookup != secondPtr->type2.continueToNextTtiLookup)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.continueToNextTtiLookup than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.continueToNextTtiLookup,
                                                 secondPtr->type2.continueToNextTtiLookup);
                st = GT_FAIL;
            }

            if(firstPtr->type2.passengerParsingOfTransitMplsTunnelMode  != secondPtr->type2.passengerParsingOfTransitMplsTunnelMode )
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.passengerParsingOfTransitMplsTunnelMode  than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.passengerParsingOfTransitMplsTunnelMode ,
                                                 secondPtr->type2.passengerParsingOfTransitMplsTunnelMode );
                st = GT_FAIL;
            }

            if(firstPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable   != secondPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable  )
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.passengerParsingOfTransitNonMplsTransitTunnelEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable  ,
                                                 secondPtr->type2.passengerParsingOfTransitNonMplsTransitTunnelEnable  );
                st = GT_FAIL;
            }

            if(GT_FALSE != firstPtr->type2.keepPreviousQoS)
            {
                if(firstPtr->type2.qosUseUpAsIndexEnable != secondPtr->type2.qosUseUpAsIndexEnable)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.qosUseUpAsIndexEnable   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.qosUseUpAsIndexEnable  ,
                                                     secondPtr->type2.qosUseUpAsIndexEnable  );
                    st = GT_FAIL;
                }

                if(GT_FALSE == firstPtr->type2.qosUseUpAsIndexEnable)
                {
                    if(firstPtr->type2.qosMappingTableIndex != secondPtr->type2.qosMappingTableIndex)
                    {
                        PRV_UTF_LOG3_MAC("get another %s.type2.qosUseUpAsIndexEnable   than was set, expected = %d, received = %d\n",
                                                         name, firstPtr->type2.qosUseUpAsIndexEnable  ,
                                                         secondPtr->type2.qosUseUpAsIndexEnable);
                        st = GT_FAIL;
                    }
                }
            }

            if(firstPtr->type2.redirectCommand == CPSS_DXCH_TTI_NO_REDIRECT_E &&
                (firstPtr->type2.iPclUdbConfigTableEnable   != secondPtr->type2.iPclUdbConfigTableEnable  ))
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.iPclUdbConfigTableEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.iPclUdbConfigTableEnable  ,
                                                 secondPtr->type2.iPclUdbConfigTableEnable  );
                st = GT_FAIL;
            }

            if((CPSS_DXCH_TTI_NO_REDIRECT_E == firstPtr->type2.redirectCommand) &&
                firstPtr->type2.iPclUdbConfigTableEnable   )
            {
                if(firstPtr->type2.iPclUdbConfigTableIndex != secondPtr->type2.iPclUdbConfigTableIndex)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.iPclUdbConfigTableIndex   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.iPclUdbConfigTableIndex  ,
                                                     secondPtr->type2.iPclUdbConfigTableIndex  );
                    st = GT_FAIL;
                }
            }

            if(CPSS_DXCH_TTI_NO_REDIRECT_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.flowId != secondPtr->type2.flowId)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.flowId   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.flowId,
                                                     secondPtr->type2.flowId);
                    st = GT_FAIL;
                }
            }

            if(CPSS_DXCH_TTI_NO_REDIRECT_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.flowId != secondPtr->type2.flowId)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.flowId   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.flowId,
                                                     secondPtr->type2.flowId);
                    st = GT_FAIL;
                }
            }

            if(firstPtr->type2.setMacToMe   != secondPtr->type2.setMacToMe)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.setMacToMe   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.setMacToMe,
                                                 secondPtr->type2.setMacToMe);
                st = GT_FAIL;
            }

            if(firstPtr->type2.rxProtectionSwitchEnable   != secondPtr->type2.rxProtectionSwitchEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.rxProtectionSwitchEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.rxProtectionSwitchEnable,
                                                 secondPtr->type2.rxProtectionSwitchEnable);
                st = GT_FAIL;
            }

            if(firstPtr->type2.rxIsProtectionPath   != secondPtr->type2.rxIsProtectionPath)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.rxIsProtectionPath   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.rxIsProtectionPath,
                                                 secondPtr->type2.rxIsProtectionPath);
                st = GT_FAIL;
            }

            if(firstPtr->type2.oamProcessEnable   != secondPtr->type2.oamProcessEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.oamOffsetIndex   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.oamOffsetIndex,
                                                 secondPtr->type2.oamOffsetIndex);
                st = GT_FAIL;
            }

            if(firstPtr->type2.oamProfile   != secondPtr->type2.oamProfile)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.oamProfile   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.oamProfile,
                                                 secondPtr->type2.oamProfile);
                st = GT_FAIL;
            }

            if(firstPtr->type2.oamChannelTypeToOpcodeMappingEnable   != secondPtr->type2.oamChannelTypeToOpcodeMappingEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.oamChannelTypeToOpcodeMappingEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.oamChannelTypeToOpcodeMappingEnable,
                                                 secondPtr->type2.oamChannelTypeToOpcodeMappingEnable);
                st = GT_FAIL;
            }

            if(firstPtr->type2.isPtpPacket   != secondPtr->type2.isPtpPacket)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.isPtpPacket   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.isPtpPacket,
                                                 secondPtr->type2.isPtpPacket);
                st = GT_FAIL;
            }

            if(GT_TRUE == firstPtr->type2.isPtpPacket)
            {
                if(firstPtr->type2.ptpTriggerType != secondPtr->type2.ptpTriggerType)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.ptpTriggerType   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.ptpTriggerType,
                                                     secondPtr->type2.ptpTriggerType);
                    st = GT_FAIL;
                }

                if(firstPtr->type2.ptpOffset != secondPtr->type2.ptpOffset)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.ptpOffset   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.ptpOffset,
                                                     secondPtr->type2.ptpOffset);
                    st = GT_FAIL;
                }
            }
            else
            {
                if(firstPtr->type2.oamTimeStampEnable   != secondPtr->type2.oamTimeStampEnable)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.oamTimeStampEnable   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.oamTimeStampEnable,
                                                     secondPtr->type2.oamTimeStampEnable);
                    st = GT_FAIL;
                }

                if(firstPtr->type2.oamOffsetIndex   != secondPtr->type2.oamOffsetIndex)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.oamOffsetIndex   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.oamOffsetIndex,
                                                     secondPtr->type2.oamOffsetIndex);
                    st = GT_FAIL;
                }
            }

            if(firstPtr->type2.ttlExpiryVccvEnable   != secondPtr->type2.ttlExpiryVccvEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.ttlExpiryVccvEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.ttlExpiryVccvEnable,
                                                 secondPtr->type2.ttlExpiryVccvEnable);
                st = GT_FAIL;
            }

            if(firstPtr->type2.pwe3FlowLabelExist   != secondPtr->type2.pwe3FlowLabelExist)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.pwe3FlowLabelExist   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.pwe3FlowLabelExist,
                                                 secondPtr->type2.pwe3FlowLabelExist);
                st = GT_FAIL;
            }

            if(firstPtr->type2.pwCwBasedETreeEnable   != secondPtr->type2.pwCwBasedETreeEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.pwCwBasedETreeEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.pwCwBasedETreeEnable,
                                                 secondPtr->type2.pwCwBasedETreeEnable);
                st = GT_FAIL;
            }

            if(firstPtr->type2.applyNonDataCwCommand   != secondPtr->type2.applyNonDataCwCommand)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.applyNonDataCwCommand   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.applyNonDataCwCommand,
                                                 secondPtr->type2.applyNonDataCwCommand);
                st = GT_FAIL;
            }
        }
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if(firstPtr->type2.unknownSaCommandEnable   != secondPtr->type2.unknownSaCommandEnable)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.unknownSaCommandEnable   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.unknownSaCommandEnable,
                                                 secondPtr->type2.unknownSaCommandEnable);
                st = GT_FAIL;
            }
            if(firstPtr->type2.unknownSaCommand   != secondPtr->type2.unknownSaCommand)
            {
                PRV_UTF_LOG3_MAC("get another %s.type2.unknownSaCommand   than was set, expected = %d, received = %d\n",
                                                 name, firstPtr->type2.unknownSaCommand,
                                                 secondPtr->type2.unknownSaCommand);
                st = GT_FAIL;
            }
            if(CPSS_DXCH_TTI_LOGICAL_PORT_ASSIGN_E == firstPtr->type2.redirectCommand)
            {
                if(firstPtr->type2.sourceMeshIdSetEnable   != secondPtr->type2.sourceMeshIdSetEnable)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.sourceMeshIdSetEnable   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.sourceMeshIdSetEnable,
                                                     secondPtr->type2.sourceMeshIdSetEnable);
                    st = GT_FAIL;
                }
                if(firstPtr->type2.sourceMeshId   != secondPtr->type2.sourceMeshId)
                {
                    PRV_UTF_LOG3_MAC("get another %s.type2.sourceMeshId   than was set, expected = %d, received = %d\n",
                                                     name, firstPtr->type2.sourceMeshId,
                                                     secondPtr->type2.sourceMeshId);
                    st = GT_FAIL;
                }
            }
        }

        break;

    default:
        break;
    }

    return st;
}

