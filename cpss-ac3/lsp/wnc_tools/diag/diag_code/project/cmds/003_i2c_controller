#!/bin/bash
# Script name: 003_i2c_controller
# Script version: V1.00.00
# Author: WeiHsiang Chen
# History: 
#     V0.00.01 - New release - 2019.12.11
#####################################################################

# ----- Include ----- #
source $(dirname $0)/sh_funcs/include

# ----- Path ----- #
sku_path="/usr/local"
drv_path="/sys/bus/i2c/devices"
## Test path (in VM)
TEST_select=0
if [ ${TEST_select} -eq 1 ]; then
    sku_path=/home/test/${sku_path}
	drv_path=/home/test/${drv_path}
fi

# ----- Declare ----- #
prog_name=`echo $0 | awk -F / '{print $NF}'`
product_name=`cat ${sku_path}/sku`

# ----- Function ----- #
function usage() {
echo "
Usage:
NAME
       ${prog_name} - Probe I2C slave device

SYNOPSIS
       ${prog_name} [-g] [-h]

DESCRIPTION
       This command is used to probe all I2C devices and confirm each
       detected address of the slave device does comply with hardware
	   specification.

MANDATORY OPTIONS
       At least one optional option is needed.
       Only one optional option will be processed at once.

OPTIONAL OPTIONS
       -g    Get and confirm all address of I2C device

       -h    Help message

PASS CRITERIA
       - Get all address of I2C device (-g) :
           SUCCESS: All devices are checked.
             Display: PASS
             Return code: 0

           ERROR: Fail to probe I2C device.
             Display: FAIL
             Return code: 9
			 
EXAMPLE
       ${prog_name} -g
" >&2
}

function get_spec() {
	# Function description: 
	#   Judge SKU to confirm which specification of I2C device address
	# Parameter: N/A

    g_spec_i2c=("") # spec.
    g_spec_poe=("8" "28") # PoE address = Bus 8 0x28 (driver not support)
    gflag_poe="FALSE"

    case ${product_name} in
        OS6360-10 | OS6360-P10)
            g_spec_i2c=("0-0070" "0-007f" "1-0050" "2-0050" "5-0052" "6-0048")
            ;;
        OS6360-P48X | OS6360-P24X | OS6360-PH24)
            g_spec_i2c=("0-0070" "0-007f" "1-0050" "2-0050" "3-0050" "4-0050" "5-0052" "6-0048")
            ;;
        *) # Default SKU = OS6360-P10
            product_name="OS6360-P10"
            g_spec_i2c=("0-0070" "0-007f" "1-0050" "2-0050" "5-0052" "6-0048")
            ;;
    esac

    if [ `echo "${product_name}" | grep 'P'` ]; then
        gflag_poe="TRUE"
    fi
}

function access_drv() {
	# Function description: 
	#   Access driver of I2C device to check address. And use I2C-tool to probe PoE if need.
	# Parameter:
	#   $1=g_spec_i2c

	local arr_spec=("${!1}")
    local i2c_num=${#arr_spec[@]}
    local i2c_bus=""
    local i2c_addr=""
    local get_poe=""
    local cnt_fail=0

    for ((cnt=0; cnt < ${i2c_num}; cnt++))
	do 
		if [ ! -d "${drv_path}/${arr_spec[cnt]}" ]; then
            i2c_bus=`echo "${arr_spec[cnt]}" | awk -F'-' '{print $1}'`
            i2c_addr=`echo "${arr_spec[cnt]}" | awk -F'-' '{print $2}'`
            
            echo -e "\n*[Oops] Fail to probe I2C device." >&2
            echo -e "  - Device address: Bus ${i2c_bus}, Addr=0x${i2c_addr}" >&2
            cnt_fail=$(( ${cnt_fail} +1 ))
        fi
    done
    
    if [ "${gflag_poe}" == "TRUE" ]; then
        # Use I2C-tool to check if PoE DO exist
        get_poe=`i2cdetect -y "${g_spec_poe[0]}" | grep "${g_spec_poe[1]}"`

        if [ -z "${get_poe}" ]; then
            echo -e "\n*[Oops] Fail to probe PoE." >&2
            echo -e "  - Device address: Bus ${g_spec_poe[0]}, Addr=0x00${g_spec_poe[1]}" >&2
            cnt_fail=$(( ${cnt_fail} +1 ))
        fi
    fi

    return ${cnt_fail}
}

# ----- Common function ----- #
## Error Code List ##
Err_Option=1	# Option not suport
Err_Param=2		# Incompatible format or number of parameter
Err_System=5	# Fail to access system directory or file
Err_Verify=9	# Common test or compare fail
#    Err_Read=10	#
#    Err_Write=11	#

function quit_msg() {
	# Parameter:
	#   $1=${err_code}
	#   $2=${err_msg}

    if [ ${1} == ${Err_Option} ]; then
		:	# Don't need to print msg
    elif [ ${1} == ${Err_Param} ]; then
        echo -e "\n ==> [Parameter Error] ${2}" >&2
    elif [ ${1} == ${Err_System} ]; then
        echo -e "\n ==> [System Error] ${2}" >&2
#    elif [ ${1} == ${Err_Read} ]; then
#        echo -e "\n ==> [Read Error] ${2}" >&2
#    elif [ ${1} == ${Err_Write} ]; then
#        echo -e "\n ==> [Write Error] ${2}" >&2
    elif [ ${1} == ${Err_Verify} ]; then
        echo -e "\n ==> [Verify Error] ${2}" >&2
    fi
    quit ${1}
}

function quit_err_cnt() {
	# Function description: 
	#   Check how many times do error happen to decide quit_type
	# Parameter:
	#   $1=${g_cnt_fail}

	if [ ${1} -ne 0 ]; then
		return ${Err_Verify}
	else 
		return ${PASS}
	fi
}

# ----- Initial variable ----- #
g_fail=0

# ----- Main ----- #
# Check option length
if [ $# -ne 1 ]; then
	usage
	quit ${FAIL} # [Option Error] Can only input one option
fi

# Judge option (-g, -h)
if [ ${1} == "-g" ]; then
    echo -e "--- Start to probe all I2C slave device ---" >&2
    get_spec
	access_drv g_spec_i2c[@]
    g_fail=${?}
    echo -e "\n--- End of probing ---" >&2

    quit_err_cnt ${g_fail}   # cnt_fail only means Err_Verify
    quit_msg ${?} "${g_fail} device may NOT be able to probe."
elif [ ${1} == "-h" ]; then
	usage
	quit_ok
else
	usage
	quit ${FAIL} # [Option Error] Option not suport
fi
