#!/bin/bash

source $(dirname $0)/sh_funcs/include

prog_name=`basename $0`
SKU=`cat /usr/local/sku`
MPP_13_LEVEL="/sys/class/gpio/gpio13/value"
CPLD_SYSFS_PREFIX="/sys/bus/i2c/devices/0-007f"
PHY_ID=0
PHY_ID_LIST=""
DEV_ID_LIST=()
START_PORT_LIST=()
SPEED_TYPE_LIST=()
CPLD_SYSFS_LIST=()
RESULT_LIST=()
RELEASE_LIST=()

usage() {

echo "Usage:
NAME
       $prog_name - Verify interrupt from PHYs

SYNOPSIS
       $prog_name [-a] [-p phy_id] [-h]

DESCRIPTION
       The command is to verify each PHY's interrupt can be delivered
       to CPU via CPLD.

       Each PHY's interrupt will be generated by the register of
       'Link Status Changed' or 'temperature' event.

       All PHY's configuration will be restored to default after the test.

MANDATORY OPTIONS
       At least one optional option is needed.

OPTIONAL OPTIONS
       -a    Generate interrupt signal for each PHY and confirm it can be
             delivered to CPU via CPLD.

       -p    Specify PHY ID to generate an interrupt signal
             For OS6360-10/OS6360-P10:
                 ID 0 is 88E1680#0 U22
                 ID 1 is 88E1543#0 U31
             For OS6360-P24X/OS6360-PH24:
                 ID 0 is 88E1680#0 U34
                 ID 1 is 88E1680#1 U33
                 ID 2 is 88E1680#2 U32
                 ID 3 is 88X3220#0 U30
             For OS6360-P48X:
                 ID 0 is 88E1680#0 U41
                 ID 1 is 88E1680#1 U40
                 ID 2 is 88E1680#2 U39
                 ID 3 is 88E1680#3 U43
                 ID 4 is 88E1680#4 U44
                 ID 5 is 88E1680#5 U42
                 ID 6 is 88E2010#0 U31
                 ID 7 is 88E2010#1 U33
                 ID 8 is 88X3220#0 U36

       -h    Help message

PASS CRITERIA
       - Confirm each PHY's interrupt signal (-a):
           SUCCESS: Each PHY's interrupt can be delivered to CPU via CPLD.
             Display: PASS
             Return code : 0

           ERROR: Not each PHY's interrupt can be delivered to CPU via CPLD.
             Display: FAIL: Following PHY's interrupt cannot deliver to CPU.
                      ID 0, 3, 7
             Return code : 1

       - Confirm specific PHY's interrupt signal (-p)
           SUCCESS: Specified PHY's interrupt can be delivered to CPU via CPLD.
             Display: PASS
             Return code : 0

           ERROR:
             (1)Specified PHY's ID is invalid for corresponding SKU.
             Display: FAIL: Invalid PHY ID $PHY_ID for $SKU.
             Return code : 2

             (2)Specified PHY's interrupt cannot be delivered to CPU via CPLD.
             Display: FAIL: PHY ID x interrupt cannot deliver to CPU.
             Return code : 3

EXAMPLE
       $prog_name -a
       $prog_name -p 0
">&2
}

if [ $# -lt 1 ]; then
	usage
	res=$FAIL
	quit $res
  echo "">&2
fi

get_phy_id_list() {
  case $SKU in
    OS6360-10 | OS6360-P10)
      PHY_ID_LIST="0 1"
      DEV_ID_LIST=('0' '0')
      START_PORT_LIST=('0' '24')
      SPEED_TYPE_LIST=('1' '1')
      DRIVER_PHY_ID_LIST=('0' '0')
      CPLD_SYSFS_LIST=('_88e1680_phy_0_int_en' '_88e1543_phy_6_int_en')
      ;;
    OS6360-P24X | OS6360-PH24)
      PHY_ID_LIST="0 1 2 3"
      DEV_ID_LIST=('0' '0' '0' '0')
      START_PORT_LIST=('0' '8' '16' '26')
      SPEED_TYPE_LIST=('1' '1' '1' '10')
      DRIVER_PHY_ID_LIST=('0' '0' '0' '0xd')
      CPLD_SYSFS_LIST=('_88e1680_phy_0_int_en' '_88e1680_phy_1_int_en'
                       '_88e1680_phy_2_int_en' '_88e3220_phy_9_int_en')
      ;;
    OS6360-P48X)
      PHY_ID_LIST="0 1 2 3 4 5 6 7 8"
      DEV_ID_LIST=('0' '0' '0' '1' '1' '1' '1' '0' '1')
      START_PORT_LIST=('0' '8' '16' '0' '8' '16' '27' '24' '25')
      SPEED_TYPE_LIST=('1' '1' '1' '1' '1' '1' '10' '10' '10')
      DRIVER_PHY_ID_LIST=('0' '0' '0' '0' '0' '0' '0x9' '0xa' '0xd')
      CPLD_SYSFS_LIST=('_88e1680_phy_0_int_en' '_88e1680_phy_1_int_en'
                       '_88e1680_phy_2_int_en' '_88e1680_phy_3_int_en'
                       '_88e1680_phy_4_int_en' '_88e1680_phy_5_int_en'
                       '_88e2010_phy_7_int_en' '_88e2010_phy_8_int_en'
                       '_88e3220_phy_9_int_en')
      ;;
    *) # OS6360-10 or OS6360-P10
      PHY_ID_LIST="0 1"
      DEV_ID_LIST=('0' '0')
      START_PORT_LIST=('0' '8')
      SPEED_TYPE_LIST=('1' '1')
      DRIVER_PHY_ID_LIST=('0' '0')
      CPLD_SYSFS_LIST=('_88e1680_phy_0_int_en' '_88e1543_phy_6_int_en')
      ;;
  esac
  #echo ${DEV_ID_LIST[@]}
  #echo ${START_PORT_LIST[@]}
  #echo ${SPEED_TYPE_LIST[@]}
  #echo ${CPLD_SYSFS_LIST[@]}
}

generate_interrupt() {
  local phy_id=$1
  local dev_id=${DEV_ID_LIST[$phy_id]}
  local start_port=${START_PORT_LIST[$phy_id]}
  local speed_type=${SPEED_TYPE_LIST[$phy_id]}
  local cpld_sysfs=${CPLD_SYSFS_LIST[$phy_id]}
  local driver_phy_id=${DRIVER_PHY_ID_LIST[$phy_id]}

  echo Generate interrupt for PHY ID $phy_id "(dev_id=$dev_id start_port=$start_port speed_type=$speed_type cpld_sysfs=$cpld_sysfs driver_phy_id=$driver_phy_id)"
  wait_cpss

  if [ $speed_type -eq 1 ]; then
    # enable phy register 'Link Status Changed' interrupt
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 22 data 0" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 18 data 0x400" | nc 127.0.0.1 54321 > /dev/null 2>&1
  else
    # enable phy register 'Temperature Sensor' interrupt and set threshold to zero
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf08a phyDev 31 data 0x8d00" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf08c phyDev 31 data 0x4b00" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf043 phyDev 31 data 0x80" | nc 127.0.0.1 54321 > /dev/null 2>&1
  fi

  # enable CPLD phy interrupt
  echo 1 > "$CPLD_SYSFS_PREFIX/$cpld_sysfs"

  if [ $speed_type -eq 1 ]; then
    # enable phy stub -> loopback module would link 'UP'
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 22 data 6" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 18 data 0x8" | nc 127.0.0.1 54321 > /dev/null 2>&1
  else
    # read temperature to trigger interrupt
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf089 phyDev 31 data 0xa0" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf089 phyDev 31 data 0x80" | nc 127.0.0.1 54321 > /dev/null 2>&1    
  fi

  # should be low due to low active
  if check_gpio_level; then
    RESULT_LIST+=('low ')
  else
    RESULT_LIST+=('high ')
  fi
}

release_interrupt() {
  local phy_id=$1
  local dev_id=${DEV_ID_LIST[$phy_id]}
  local start_port=${START_PORT_LIST[$phy_id]}
  local speed_type=${SPEED_TYPE_LIST[$phy_id]}
  local cpld_sysfs=${CPLD_SYSFS_LIST[$phy_id]}
  local driver_phy_id=${DRIVER_PHY_ID_LIST[$phy_id]}

  echo Release interrupt for PHY ID $phy_id "(dev_id=$dev_id start_port=$start_port speed_type=$speed_type cpld_sysfs=$cpld_sysfs driver_phy_id=$driver_phy_id)"
  wait_cpss

  if [ $speed_type -eq 1 ]; then
    # disable phy register 'Link Status Changed' interrupt
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 22 data 0" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 18 data 0" | nc 127.0.0.1 54321 > /dev/null 2>&1
  else
    # disable phy register 'Temperature Sensor' interrupt    
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf089 phyDev 31 data 0x0" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf08a phyDev 31 data 0xcd00" | nc 127.0.0.1 54321 > /dev/null 2>&1
  fi

  # read phy interrupt status (read & clear)
  if [ $speed_type -eq 1 ]; then
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 22 data 0" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterRead  devNum $dev_id portNum $start_port phyReg 19" | nc 127.0.0.1 54321 > /dev/null 2>&1
  else
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterRead  devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf089 phyDev 31" | nc 127.0.0.1 54321 > /dev/null 2>&1
  fi

  # disable CPLD phy interrupt
  echo 0 > "$CPLD_SYSFS_PREFIX/$cpld_sysfs"

  if [ $speed_type -eq 1 ]; then
    # disable phy stub -> loopback module would link 'DOWN'
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 22 data 6" | nc 127.0.0.1 54321 > /dev/null 2>&1
    echo "do cpss-api call cpssDxChPhyPortSmiRegisterWrite devNum $dev_id portNum $start_port phyReg 18 data 0" | nc 127.0.0.1 54321 > /dev/null 2>&1
  else
    # restore default threshold
    echo "cpss-api call cpssDxChPhyPort10GSmiRegisterWrite devNum $dev_id portNum $start_port phyId $driver_phy_id useExternalPhy true phyReg 0xf08c phyDev 31 data 0x9600" | nc 127.0.0.1 54321 > /dev/null 2>&1
  fi

  # should be high due to low active
  if check_gpio_level; then
    RELEASE_LIST+=('low ')
  else
    RELEASE_LIST+=('high ')
  fi
}

check_gpio_level() {
  local level=`cat $MPP_13_LEVEL`

  if [  $level -eq 0 ]; then
    #echo MPP_13_LEVEL $level
    return 0
  else
    #echo MPP_13_LEVEL $level
    return 1
  fi
}

confirm_all_result() {
  local phy_id=0
  local level=""
  local none_lo_list=()
  local none_hi_list=()

  # ${RESULT_LIST[@]} should be all 'low'
  for level in "${RESULT_LIST[@]}"; do
    #echo phy_id $phy_id level $level
    if [ $level != low ]; then
      none_lo_list+=($phy_id, )
    fi
    phy_id=$((phy_id+1))
  done

  # ${RELEASE_LIST[@]} should be all 'high'
  phy_id=0
  for level in "${RELEASE_LIST[@]}"; do
    #echo phy_id $phy_id level $level
    if [ $level != high ]; then
      none_hi_list+=($phy_id, )
    fi
    phy_id=$((phy_id+1))
  done

  if [ ${#none_lo_list[@]} -eq 0 ] && [ ${#none_hi_list[@]} -eq 0 ]; then
    res=$PASS
    quit $res
  fi

  if [ ${#none_lo_list[@]} -ne 0 ]; then
    #remove the last ','
    none_lo_list[${#none_lo_list[@]}-1]=${none_lo_list[${#none_lo_list[@]}-1]::-1}

    if [ ${#RESULT_LIST[@]} -gt 1 ]; then
      echo "FAIL: Following PHY's interrupt cannot deliver to CPU."
      echo "ID ${none_lo_list[@]}"
    else
      echo "FAIL: PHY ID $1 interrupt cannot deliver to CPU."
    fi
  fi

  if [ ${#none_hi_list[@]} -ne 0 ]; then
    #remove the last ','
    none_hi_list[${#none_hi_list[@]}-1]=${none_hi_list[${#none_hi_list[@]}-1]::-1}

    if [ ${#RESULT_LIST[@]} -gt 1 ]; then
      echo "FAIL: Following PHY's interrupt cannot release."
      echo "ID ${none_hi_list[@]}"
    else
      echo "FAIL: PHY ID $1 interrupt cannot release."
    fi
  fi

  #echo $PHY_ID_LIST
  #echo ${RESULT_LIST[@]}
  #echo ${RELEASE_LIST[@]}

  if [ ${#RESULT_LIST[@]} -eq 1 ]; then
    res=3
  else
    res=1
  fi

  quit $res
}

while getopts "hap:" arg; do
  case $arg in
    a) # test all phy.
      get_phy_id_list
      for id in $PHY_ID_LIST; do
        generate_interrupt $id
        release_interrupt $id
      done
      confirm_all_result
      ;;
    p) # test specific phy id.
      PHY_ID=${OPTARG}
      get_phy_id_list
      for id in $PHY_ID_LIST; do
        if [ $id -eq $PHY_ID ]; then
          generate_interrupt $id
          release_interrupt $id
          confirm_all_result $id
        fi
      done
      echo "FAIL: Invalid PHY ID$PHY_ID for $SKU."
      res=2
      quit $res
      ;;
    h | *) # display usage.
      usage
      quit_ok
      ;;
  esac
done
