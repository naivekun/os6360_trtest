#!/bin/bash

# ## Default Consts ## #

set -e
prog_name=`echo $0 | awk -F / '{print $NF}'`

PASS=0
FAIL=1

# ## Functions ## #

function usage() {
echo "
Usage:
NAME
       ${prog_name} - parse data from the EEPROM

SYNOPSIS
       ${prog_name} [-r] [-x Address_range] [-s Address_range]
                     [-d Address_range] [-h]

DESCRIPTION
       ${prog_name} is used to parse data from the EEPROM. It will 
       display all information from the EEPROM. Additionally, User 
       can inserted byte address range to get hexadecimal, string or
       decimal data which is in the range of byte address.

MANDATORY OPTIONS
       At least one optional option is needed.

OPTIONAL OPTIONS
       -r    Read EEPROM data
	   
       -x    Get hexadecimal data in the range of byte address

       -s    Get string data in the range of byte address

       -d    Get decimal data in the range of byte address

       -h    Help message

PASS CRITERIA
       - Read EEPROM data (-r):
           SUCCESS: Display all information from the EEPROM
             Display: PASS
             Return code: 0

           ERROR: Can't display information from the EEPROM
             Display: FAIL
             Return code: 1 (input  error)
                          2 (option error)
                          3 (system error)
                          4 (read   error)

Example:
       eeprom_parser -r
       eeprom_parser -x 1,4
       eeprom_parser -s 5,29
       eeprom_parser -d 68,69
" >&2
}

function quit() {
	local rc=''

	if [ "$1" = "" ]; then
		rc=$FAIL
		echo -e "\nquit(): miss input argument\n" >&2
	else
		rc=$1
	fi

	if [ "$rc" = "$PASS" ]; then
		echo -e "\nResult: PASS\n"
	else
		echo -e "\nResult: FAIL\n" >&2
	fi

	exit $rc
}

function quit_ok() {
    exit 0
}

function check_valid_int() {
    
    # 1: integer

    if [[ ! ${1} =~ ^[0-9]+$ ]]; then
        error_msg 1 "Variable \"${1}\" isn't a integer"
    fi
}

function calculate_checksum() {

    # 1: hex sequence (like: 0103ff4e002c), 2: checksum
    
    local sum_array=(`echo -n ${1} | sed 's/../ &/g'`)
    local total
    
    for ((i = 0 ; i < ${#sum_array[@]} ; i+=2)); do
        if [ $((i + 1)) -ge ${#sum_array[@]} ]; then
            total=$((${total} + 0x${sum_array[i]}))
        else
            total=$((${total} + 0x${sum_array[i]}${sum_array[i+1]}))
        fi
    done
    if  [ $((${total}>>16)) -gt 0 ]; then
        total=$((${total}&0xFFFF))
    fi

    printf '%04x\n' "${total}"
}

function check_hex_len() {

    # 1: hex_value, 2: length

    local hex_list=(`echo ${1} | sed 's/../& /g'`)

    if [ ${#hex_list[@]} -ne ${2} ]; then
        error_msg 4 "Binfile length(${#hex_list[@]}) isn't consistent with ${2}"
    fi
}
 
function get_field_hex() {

    local container=${1}
    local start=$((${2}*2))
    local char_num=$(( $((${3}+1))*2 - ${start} ))
    echo ${container:start:char_num}
}

function error_msg() {

    # 1: error_code, 2: error_msg

    # ERROR CODE
    #   Input error : 1
    #   Option error: 2
    #   System error: 3
    #   Read error  : 4
    #   Write error : 5 
    #   Test error  : 6 

    if [ ${1} -eq 1 ]; then
        echo -e "\n[Input error] ${2}" >&2
    elif [ ${1} -eq 2 ]; then
        :
    elif [ ${1} -eq 3 ]; then
        echo -e "\n[System error] ${2}" >&2
    elif [ ${1} -eq 4 ]; then
        echo -e "\n[Read error] ${2}" >&2
    elif [ ${1} -eq 5 ]; then
        echo -e "\n[Write error] ${2}" >&2
    elif [ ${1} -eq 6 ]; then
        echo -e "\n[Test error] ${2}" >&2
    fi
    quit ${1}
}

function get_byte_address_range() {
    
    # 1: addres_range, 2: max_size

    local lower=`echo ${1} | awk -F , '{print $1}'`
    check_valid_int ${lower}
    [ ${lower} -gt ${2} ] && error_msg 1 "Byte address: ${lower} is out of range(${2})"
    
    local upper=`echo ${1} | awk -F , '{print $2}'`
    check_valid_int ${upper}
    [ ${upper} -gt ${2} ] && error_msg 1 "Byte address: ${upper} is out of range(${2})"

    if [ ${upper} -ge ${lower} ]; then
        local list=("${lower}" "${upper}")
    else
        error_msg 1 "Wrong address, lower_speed: ${lower}, upper_speed: ${upper}"
    fi
    echo "${list[@]}"
}

# ## Initial variables ## #

binfile_container=""
binfile_size=256
mode=""
address_range=""

BUS_ID=5
ADDR=0x50

# ## Check sys argvs ## #

if [ $# -lt 1 ]; then

    usage
    error_msg 2
    # error_msg 2 "At least one optional option is needed."
fi

while getopts ":rx:s:d:h" arg
do
    case ${arg} in      
        r)
            mode="read"
            ;;
        x)
            mode="hex"
            address_range=${OPTARG}
            ;;
        s)
            mode="string" 
            address_range=${OPTARG}      
            ;;
        d)
            mode="dec"
            address_range=${OPTARG}
            ;;
        h)
            usage
            quit_ok
            ;;
        :)
            usage
            error_msg 2
            # error_msg 2 "Option \"-${OPTARG}\" requires an argument"
            ;;
        ?)
            usage
            error_msg 2
            # error_msg 2 "Unknown option \"-${OPTARG}\""
            ;;
    esac
done

if [ ${OPTIND} -eq 1 ]; then
    usage
    error_msg 2
    # error_msg 2 "No options were passed"
fi

binfile_container=$(echo -n `i2cdump -f -y -r 0-207 ${BUS_ID} ${ADDR} b | sed -n '2,$p' | awk -F: '{print $2}' | \
                    awk -F"    " '{print $1}' | tr -d " "` | tr -d " " 2> /dev/null)
[ -z {binfile_container} ] && error_msg 4 "Can't get EEPROM data"

# Checksum (Hexadecimal, 206-207)
checksum=`get_field_hex "${binfile_container}" 206 207`
check_contents=`get_field_hex "${binfile_container}" 0 205`
file_checksum=`calculate_checksum ${check_contents}`
[[ 0x${checksum} -ne 0x${file_checksum} ]] && echo -e "\nWarning: checksum expected 0x${file_checksum} got 0x${checksum}"

if [ ${mode} == "hex" ]; then
    range_list=( `get_byte_address_range "${address_range}" ${binfile_size}` )
    echo -n `get_field_hex "${binfile_container}" ${range_list[0]} ${range_list[1]}`
    quit_ok
elif [ ${mode} == "string" ]; then
    range_list=( `get_byte_address_range "${address_range}" ${binfile_size}` )
    string_hex=`get_field_hex "${binfile_container}" ${range_list[0]} ${range_list[1]} | sed 's/../\\\x&/g'`
    echo -ne ${string_hex} | tr -d '\0'
    quit_ok
elif [ ${mode} == "dec" ]; then
    range_list=( `get_byte_address_range "${address_range}" ${binfile_size}` )
    echo -n $((0x`get_field_hex "${binfile_container}" ${range_list[0]} ${range_list[1]}`))
    quit_ok
fi

# EEPROM format number (Hexadecimal, 0)
eeprom_format_number=`get_field_hex "${binfile_container}" 0 0`

# Module ID (Hexadecimal, 1-4)
module_id=`get_field_hex "${binfile_container}" 1 4`

# PCBA Part Number (String, 5-29)
pcba_part_number_hex=`get_field_hex "${binfile_container}" 5 29 | sed 's/../\\\x&/g'`
pcba_part_number=`echo -e ${pcba_part_number_hex} | tr -d '\0'`

# PCBA Revision number (String, 30-32)
pcba_revision_number_hex=`get_field_hex "${binfile_container}" 30 32 | sed 's/../\\\x&/g'`
pcba_revision_number=`echo -e ${pcba_revision_number_hex} | tr -d '\0'`

# Serial Number (String, 33-57)
serial_number_hex=`get_field_hex "${binfile_container}" 33 57 | sed 's/../\\\x&/g'`
serial_number=`echo -e ${serial_number_hex} | tr -d '\0'`

# Manufacturing Date (Time, 58-61)
mfg_date_hex=0x`get_field_hex "${binfile_container}" 58 61`
LANG=en_us_88591
mfg_date=`TZ=UTC printf "%(%Y-%m-%d %H:%M:%S)T\n" ${mfg_date_hex}`
# mfg_date=`date -d @$((${mfg_date_hex})) +"%b,%d,%Y %H:%M:%S"`

# Base MAC Range 1 (Hex String, 62-67)
base_mac_range_1=`get_field_hex "${binfile_container}" 62 67`
if [ ${base_mac_range_1} == "000000000000" ]; then
    base_mac_range_1="No MAC Required"
else
    base_mac_range_1=`echo ${base_mac_range_1}| sed 's/../:&/g' | sed 's/^://g' | tr '[:upper:]' '[:lower:]'`
fi

# # MAC Count Range 1 (Decimal, 68-69)
mac_count_range_1=$((0x`get_field_hex "${binfile_container}" 68 69`))

# Base MAC Range 2 (Hex String, 70-75)
base_mac_range_2=`get_field_hex "${binfile_container}" 70 75`
if [ ${base_mac_range_2} == "000000000000" ]; then
    base_mac_range_2="No MAC Required"
else
    base_mac_range_2=`echo ${base_mac_range_2}| sed 's/../:&/g' | sed 's/^://g' | tr '[:upper:]' '[:lower:]'`
fi

# MAC Count Range 2 (Decimal, 76-77)
mac_count_range_2=$((0x`get_field_hex "${binfile_container}" 76 77`))

# Base MAC Range 3 (Hex String, 78-83)
base_mac_range_3=`get_field_hex "${binfile_container}" 78 83`
if [ ${base_mac_range_3} == "000000000000" ]; then
    base_mac_range_3="No MAC Required"
else
    base_mac_range_3=`echo ${base_mac_range_3}| sed 's/../:&/g' | sed 's/^://g' | tr '[:upper:]' '[:lower:]'`
fi

# MAC Count Range 3 (Decimal, 84-85)
mac_count_range_3=$((0x`get_field_hex "${binfile_container}" 84 85`))

# Base MAC Range 4 (Hex String, 86-91)
base_mac_range_4=`get_field_hex "${binfile_container}" 86 91`
if [ ${base_mac_range_4} == "000000000000" ]; then
    base_mac_range_4="No MAC Required"
else
    base_mac_range_4=`echo ${base_mac_range_4}| sed 's/../:&/g' | sed 's/^://g' | tr '[:upper:]' '[:lower:]'`
fi

# MAC Count Range 4 (Decimal, 92-93)
mac_count_range_4=$((0x`get_field_hex "${binfile_container}" 92 93`))

# Module Description (String, 94-125)
module_description_hex=`get_field_hex "${binfile_container}" 94 125 | sed 's/../\\\x&/g'`
module_description=`echo -e ${module_description_hex} | tr -d '\0'`

# FRU (String, 126-150)
fru_part_number_hex=`get_field_hex "${binfile_container}" 126 150 | sed 's/../\\\x&/g'`
fru_part_number=`echo -e ${fru_part_number_hex} | tr -d '\0'`

# FRU Revision Number (String, 151-153)
fru_revision_number_hex=`get_field_hex "${binfile_container}" 151 153 | sed 's/../\\\x&/g'`
fru_revision_number=`echo -e ${fru_revision_number_hex} | tr -d '\0'`

# # Power Consumption (Decimal, 154-155)
power_consumption=$((0x`get_field_hex "${binfile_container}" 154 155`))

# Variant (Hex String, 156-163)
variant=`get_field_hex "${binfile_container}" 156 163`

# ## Output to screen ## #

left="-30"
right="+40"

echo -e "\n----------------------------------------------------------------------"
printf "%${left}s%${right}s\n" "Binfile:" "${eeprom_file_path}"
echo "----------------------------------------------------------------------"
printf "%${left}s%${right}s\n" "EEPROM format number:" "${eeprom_format_number}"
printf "%${left}s%${right}s\n" "Module ID:"            "${module_id}"
printf "%${left}s%${right}s\n" "PCBA Part Number:"     "${pcba_part_number}"
printf "%${left}s%${right}s\n" "PCBA Revision number:" "${pcba_revision_number}"
printf "%${left}s%${right}s\n" "Serial Number:"        "${serial_number}"
printf "%${left}s%${right}s\n" "Manufacturing Date:"   "${mfg_date}"
printf "%${left}s%${right}s\n" "Base MAC Range 1:"     "${base_mac_range_1}"
printf "%${left}s%${right}s\n" "MAC Count Range 1:"    "${mac_count_range_1}"
printf "%${left}s%${right}s\n" "Base MAC Range 2:"     "${base_mac_range_2}"
printf "%${left}s%${right}s\n" "MAC Count Range 2:"    "${mac_count_range_2}"
printf "%${left}s%${right}s\n" "Base MAC Range 3:"     "${base_mac_range_3}"
printf "%${left}s%${right}s\n" "MAC Count Range 3:"    "${mac_count_range_3}"
printf "%${left}s%${right}s\n" "Base MAC Range 4:"     "${base_mac_range_4}"
printf "%${left}s%${right}s\n" "MAC Count Range 4:"    "${mac_count_range_4}"
printf "%${left}s%${right}s\n" "Module Description:"   "${module_description}"
printf "%${left}s%${right}s\n" "FRU Part Number:"      "${fru_part_number}"
printf "%${left}s%${right}s\n" "FRU Revision Number:"  "${fru_revision_number}"
printf "%${left}s%${right}s\n" "Power Consumption:"    "${power_consumption}"
printf "%${left}s%${right}s\n" "Variant :"             "${variant}"
echo -e "----------------------------------------------------------------------\n"

quit ${PASS}